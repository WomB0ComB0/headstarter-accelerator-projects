"use strict";var L=Object.defineProperty;var re=Object.getOwnPropertyDescriptor;var ne=Object.getOwnPropertyNames;var ie=Object.prototype.hasOwnProperty;var se=(e,n)=>{for(var l in n)L(e,l,{get:n[l],enumerable:!0})},ae=(e,n,l,d)=>{if(n&&typeof n=="object"||typeof n=="function")for(let f of ne(n))!ie.call(e,f)&&f!==l&&L(e,f,{get:()=>n[f],enumerable:!(d=re(n,f))||d.enumerable});return e};var oe=e=>ae(L({},"__esModule",{value:!0}),e);var _e={};se(_e,{convertFromDB:()=>qe,convertToDB:()=>Se,createFieldAttribute:()=>Oe,createInternalAdapter:()=>Fe,getAdapter:()=>Ne,getAuthTables:()=>v,getMigrations:()=>Me,getSchema:()=>j,getWithHooks:()=>V,matchType:()=>ee,toZodSchema:()=>Ie});module.exports=oe(_e);var E=(e,n="ms")=>new Date(Date.now()+(n==="sec"?e*1e3:e));var x=require("zod"),de=require("better-call"),$e=x.z.object({id:x.z.string(),providerId:x.z.string(),accountId:x.z.string(),userId:x.z.string(),accessToken:x.z.string().nullish(),refreshToken:x.z.string().nullish(),idToken:x.z.string().nullish(),accessTokenExpiresAt:x.z.date().nullish(),refreshTokenExpiresAt:x.z.date().nullish(),scope:x.z.string().nullish(),password:x.z.string().nullish(),createdAt:x.z.date().default(()=>new Date),updatedAt:x.z.date().default(()=>new Date)}),He=x.z.object({id:x.z.string(),email:x.z.string().transform(e=>e.toLowerCase()),emailVerified:x.z.boolean().default(!1),name:x.z.string(),image:x.z.string().nullish(),createdAt:x.z.date().default(()=>new Date),updatedAt:x.z.date().default(()=>new Date)}),Ke=x.z.object({id:x.z.string(),userId:x.z.string(),expiresAt:x.z.date(),createdAt:x.z.date().default(()=>new Date),updatedAt:x.z.date().default(()=>new Date),token:x.z.string(),ipAddress:x.z.string().nullish(),userAgent:x.z.string().nullish()}),We=x.z.object({id:x.z.string(),value:x.z.string(),createdAt:x.z.date().default(()=>new Date),updatedAt:x.z.date().default(()=>new Date),expiresAt:x.z.date(),identifier:x.z.string()});function $(e,n){let l=n.fields,d={};for(let f in e){let g=l[f];if(!g){d[f]=e[f];continue}g.returned!==!1&&(d[f]=e[f])}return d}function H(e,n){let l={...n==="user"?e.user?.additionalFields:{},...n==="session"?e.session?.additionalFields:{}};for(let d of e.plugins||[])d.schema&&d.schema[n]&&(l={...l,...d.schema[n].fields});return l}function P(e,n){let l=H(e,"user");return $(n,{fields:l})}function U(e,n){let l=H(e,"session");return $(n,{fields:l})}function V(e,n){let l=n.hooks;async function d(u,m,t){let r=u;for(let o of l||[]){let c=o[m]?.create?.before;if(c){let s=await c(u);if(s===!1)return null;typeof s=="object"&&"data"in s&&(r=s.data)}}let i=t?await t.fn(r):null,a=!t||t.executeMainFn?await e.create({model:m,data:r}):i;for(let o of l||[]){let c=o[m]?.create?.after;c&&await c(a)}return a}async function f(u,m,t,r){let i=u;for(let c of l||[]){let s=c[t]?.update?.before;if(s){let p=await s(u);if(p===!1)return null;i=typeof p=="object"?p.data:p}}let a=r?await r.fn(i):null,o=!r||r.executeMainFn?await e.update({model:t,update:i,where:m}):a;for(let c of l||[]){let s=c[t]?.update?.after;s&&await s(o)}return o}async function g(u,m,t,r){let i=u;for(let c of l||[]){let s=c[t]?.update?.before;if(s){let p=await s(u);if(p===!1)return null;i=typeof p=="object"?p.data:p}}let a=r?await r.fn(i):null,o=!r||r.executeMainFn?await e.updateMany({model:t,update:i,where:m}):a;for(let c of l||[]){let s=c[t]?.update?.after;s&&await s(o)}return o}return{createWithHooks:d,updateWithHooks:f,updateManyWithHooks:g}}var N=Object.create(null),O=e=>globalThis.process?.env||globalThis.Deno?.env.toObject()||globalThis.__env__||(e?N:globalThis),K=new Proxy(N,{get(e,n){return O()[n]??N[n]},has(e,n){let l=O();return n in l||n in N},set(e,n,l){let d=O(!0);return d[n]=l,!0},deleteProperty(e,n){if(!n)return!1;let l=O(!0);return delete l[n],!0},ownKeys(){let e=O(!0);return Object.keys(e)}});function ue(e){return e?e!=="false":!1}var ce=typeof process<"u"&&process.env&&process.env.NODE_ENV||"";var W=ce==="test"||ue(K.TEST);function J(e,n){if(n.advanced?.ipAddress?.disableIpTracking)return null;let l="127.0.0.1";if(W)return l;let f=n.advanced?.ipAddress?.ipAddressHeaders||["x-client-ip","x-forwarded-for","cf-connecting-ip","fastly-client-ip","x-real-ip","x-cluster-client-ip","x-forwarded","forwarded-for","forwarded"],g=e instanceof Request?e.headers:e;for(let u of f){let m=g.get(u);if(typeof m=="string"){let t=m.split(",")[0].trim();if(t)return t}}return null}function S(e){try{return JSON.parse(e)}catch{return null}}var z=require("@better-auth/utils/random"),F=e=>(0,z.createRandomStringGenerator)("a-z","A-Z","0-9")(e||32);var be=require("zod"),ve=require("better-call");var I=class extends Error{constructor(n,l){super(n),this.name="BetterAuthError",this.message=n,this.cause=l,this.stack=""}};var he=require("@better-auth/utils/hash"),xe=require("@noble/ciphers/chacha"),M=require("@noble/ciphers/utils"),we=require("@noble/ciphers/webcrypto");var fe=require("@better-auth/utils/hash");var pe=require("jose");var me=require("@noble/hashes/scrypt"),ye=require("uncrypto"),ge=require("@better-auth/utils/hex");var G=require("@better-auth/utils/random"),Ae=(0,G.createRandomStringGenerator)("a-z","0-9","A-Z","-_");var _=["info","success","warn","error","debug"];function Te(e,n){return _.indexOf(n)<=_.indexOf(e)}var b={reset:"\x1B[0m",bright:"\x1B[1m",dim:"\x1B[2m",underscore:"\x1B[4m",blink:"\x1B[5m",reverse:"\x1B[7m",hidden:"\x1B[8m",fg:{black:"\x1B[30m",red:"\x1B[31m",green:"\x1B[32m",yellow:"\x1B[33m",blue:"\x1B[34m",magenta:"\x1B[35m",cyan:"\x1B[36m",white:"\x1B[37m"},bg:{black:"\x1B[40m",red:"\x1B[41m",green:"\x1B[42m",yellow:"\x1B[43m",blue:"\x1B[44m",magenta:"\x1B[45m",cyan:"\x1B[46m",white:"\x1B[47m"}},ke={info:b.fg.blue,success:b.fg.green,warn:b.fg.yellow,error:b.fg.red,debug:b.fg.magenta},Re=(e,n)=>{let l=new Date().toISOString();return`${b.dim}${l}${b.reset} ${ke[e]}${e.toUpperCase()}${b.reset} ${b.bright}[Better Auth]:${b.reset} ${n}`},C=e=>{let n=e?.disabled!==!0,l=e?.level??"error",d=(f,g,u=[])=>{if(!n||!Te(l,f))return;let m=Re(f,g);if(!e||typeof e.log!="function"){f==="error"?console.error(m,...u):f==="warn"?console.warn(m,...u):console.log(m,...u);return}e.log(f==="success"?"info":f,g,...u)};return Object.fromEntries(_.map(f=>[f,(...[g,...u])=>d(f,g,u)]))},Z=C();var Fe=(e,n)=>{let l=n.options,d=l.secondaryStorage,f=l.session?.expiresIn||60*60*24*7,{createWithHooks:g,updateWithHooks:u,updateManyWithHooks:m}=V(e,n);return{createOAuthUser:async(t,r)=>{let i=await g({createdAt:new Date,updatedAt:new Date,...t},"user"),a=await g({...r,userId:i.id||t.id,createdAt:new Date,updatedAt:new Date},"account");return{user:i,account:a}},createUser:async t=>await g({createdAt:new Date,updatedAt:new Date,emailVerified:!1,...t,email:t.email.toLowerCase()},"user"),createAccount:async t=>await g({createdAt:new Date,updatedAt:new Date,...t},"account"),listSessions:async t=>{if(d){let i=await d.get(`active-sessions-${t}`);if(!i)return[];let a=S(i)||[],o=Date.now(),c=a.filter(p=>p.expiresAt>o),s=[];for(let p of c){let A=await d.get(p.token);if(A){let y=JSON.parse(A),w=U(n.options,{...y.session,expiresAt:new Date(y.session.expiresAt)});s.push(w)}}return s}return await e.findMany({model:"session",where:[{field:"userId",value:t}]})},listUsers:async(t,r,i,a)=>await e.findMany({model:"user",limit:t,offset:r,sortBy:i,where:a}),deleteUser:async t=>{await e.deleteMany({model:"session",where:[{field:"userId",value:t}]}),await e.deleteMany({model:"account",where:[{field:"userId",value:t}]}),await e.delete({model:"user",where:[{field:"id",value:t}]})},createSession:async(t,r,i,a)=>{let o=r instanceof Request?r.headers:r,{id:c,...s}=a||{},p={ipAddress:r&&J(r,n.options)||"",userAgent:o?.get("user-agent")||"",...s,expiresAt:i?E(60*60*24,"sec"):E(f,"sec"),userId:t,token:F(32),createdAt:new Date,updatedAt:new Date};return await g(p,"session",d?{fn:async y=>{let w=await d.get(`active-sessions-${t}`),h=[],R=Date.now();return w&&(h=S(w)||[],h=h.filter(te=>te.expiresAt>R)),h.push({token:p.token,expiresAt:R+f*1e3}),await d.set(`active-sessions-${t}`,JSON.stringify(h),f),y},executeMainFn:l.session?.storeSessionInDatabase}:void 0)},findSession:async t=>{if(d){let c=await d.get(t);if(c){let s=JSON.parse(c),p=U(n.options,{...s.session,expiresAt:new Date(s.session.expiresAt),createdAt:new Date(s.session.createdAt),updatedAt:new Date(s.session.updatedAt)}),A=P(n.options,{...s.user,createdAt:new Date(s.user.createdAt),updatedAt:new Date(s.user.updatedAt)});return{session:p,user:A}}}let r=await e.findOne({model:"session",where:[{value:t,field:"token"}]});if(!r)return null;let i=await e.findOne({model:"user",where:[{value:r.userId,field:"id"}]});if(!i)return null;let a=U(n.options,r),o=P(n.options,i);return d&&await d?.set(t,JSON.stringify({session:a,user:o}),a.expiresAt?Math.floor(((a.expiresAt instanceof Date?a.expiresAt.getTime():new Date(a.expiresAt).getTime())-Date.now())/1e3):f),{session:a,user:o}},findSessions:async t=>{if(d){let o=[];for(let c of t){let s=await d.get(c);if(s){let p=JSON.parse(s),A={session:{...p.session,expiresAt:new Date(p.session.expiresAt)},user:{...p.user,createdAt:new Date(p.user.createdAt),updatedAt:new Date(p.user.updatedAt)}};o.push(A)}}return o}let r=await e.findMany({model:"session",where:[{field:"token",value:t,operator:"in"}]}),i=r.map(o=>o.userId);if(!i.length)return[];let a=await e.findMany({model:"user",where:[{field:"id",value:i,operator:"in"}]});return r.map(o=>{let c=a.find(s=>s.id===o.userId);return c?{session:o,user:c}:null})},updateSession:async(t,r)=>await u(r,[{field:"token",value:t}],"session",d?{async fn(a){let o=await d.get(t),c=null;return o?(c={...JSON.parse(o).session,...a},c):null},executeMainFn:l.session?.storeSessionInDatabase}:void 0),deleteSession:async t=>{if(d){await d.delete(t),l.session?.storeSessionInDatabase&&await e.delete({model:"session",where:[{field:"token",value:t}]});return}await e.delete({model:"session",where:[{field:"token",value:t}]})},deleteAccounts:async t=>{await e.deleteMany({model:"account",where:[{field:"userId",value:t}]})},deleteAccount:async(t,r)=>{await e.delete({model:"account",where:[{field:"providerId",value:t},{field:"userId",value:r}]})},deleteSessions:async t=>{if(d){if(typeof t=="string"){let r=await d.get(`active-sessions-${t}`),i=r?S(r):[];if(!i)return;for(let a of i)await d.delete(a.token)}else for(let r of t)await d.get(r)&&await d.delete(r);l.session?.storeSessionInDatabase&&await e.deleteMany({model:"session",where:[{field:Array.isArray(t)?"token":"userId",value:t,operator:Array.isArray(t)?"in":void 0}]});return}await e.deleteMany({model:"session",where:[{field:Array.isArray(t)?"token":"userId",value:t,operator:Array.isArray(t)?"in":void 0}]})},findOAuthUser:async(t,r,i)=>{let a=await e.findOne({model:"account",where:[{value:r,field:"accountId"},{value:i,field:"providerId"}]});if(a){let o=await e.findOne({model:"user",where:[{value:a.userId,field:"id"}]});return o?{user:o,accounts:[a]}:null}else{let o=await e.findOne({model:"user",where:[{value:t.toLowerCase(),field:"email"}]});if(o){let c=await e.findMany({model:"account",where:[{value:o.id,field:"userId"}]});return{user:o,accounts:c||[]}}else return null}},findUserByEmail:async(t,r)=>{let i=await e.findOne({model:"user",where:[{value:t.toLowerCase(),field:"email"}]});if(!i)return null;if(r?.includeAccounts){let a=await e.findMany({model:"account",where:[{value:i.id,field:"userId"}]});return{user:i,accounts:a}}return{user:i,accounts:[]}},findUserById:async t=>await e.findOne({model:"user",where:[{field:"id",value:t}]}),linkAccount:async t=>await g({...t,createdAt:new Date,updatedAt:new Date},"account"),updateUser:async(t,r)=>await u(r,[{field:"id",value:t}],"user"),updateUserByEmail:async(t,r)=>await u(r,[{field:"email",value:t}],"user"),updatePassword:async(t,r)=>{await m({password:r},[{field:"userId",value:t},{field:"providerId",value:"credential"}],"account")},findAccounts:async t=>await e.findMany({model:"account",where:[{field:"userId",value:t}]}),findAccount:async t=>await e.findOne({model:"account",where:[{field:"accountId",value:t}]}),findAccountByUserId:async t=>await e.findMany({model:"account",where:[{field:"userId",value:t}]}),updateAccount:async(t,r)=>await u(r,[{field:"id",value:t}],"account"),createVerificationValue:async t=>await g({createdAt:new Date,updatedAt:new Date,...t},"verification"),findVerificationValue:async t=>(await e.findMany({model:"verification",where:[{field:"identifier",value:t}],sortBy:{field:"createdAt",direction:"desc"},limit:1}))[0],deleteVerificationValue:async t=>{await e.delete({model:"verification",where:[{field:"id",value:t}]})},deleteVerificationByIdentifier:async t=>{await e.delete({model:"verification",where:[{field:"identifier",value:t}]})},updateVerificationValue:async(t,r)=>await u(r,[{field:"id",value:t}],"verification")}};var Oe=(e,n)=>({type:e,...n});var v=e=>{let n=e.plugins?.reduce((t,r)=>{let i=r.schema;if(!i)return t;for(let[a,o]of Object.entries(i))t[a]={fields:{...t[a]?.fields,...o.fields},modelName:o.modelName||a};return t},{}),l=e.rateLimit?.storage==="database",d={rateLimit:{modelName:e.rateLimit?.modelName||"rateLimit",fields:{key:{type:"string",fieldName:e.rateLimit?.fields?.key||"key"},count:{type:"number",fieldName:e.rateLimit?.fields?.count||"count"},lastRequest:{type:"number",fieldName:e.rateLimit?.fields?.lastRequest||"lastRequest"}}}},{user:f,session:g,account:u,...m}=n||{};return{user:{modelName:e.user?.modelName||"user",fields:{name:{type:"string",required:!0,fieldName:e.user?.fields?.name||"name"},email:{type:"string",unique:!0,required:!0,fieldName:e.user?.fields?.email||"email"},emailVerified:{type:"boolean",defaultValue:()=>!1,required:!0,fieldName:e.user?.fields?.emailVerified||"emailVerified"},image:{type:"string",required:!1,fieldName:e.user?.fields?.image||"image"},createdAt:{type:"date",defaultValue:()=>new Date,required:!0,fieldName:e.user?.fields?.createdAt||"createdAt"},updatedAt:{type:"date",defaultValue:()=>new Date,required:!0,fieldName:e.user?.fields?.updatedAt||"updatedAt"},...f?.fields,...e.user?.additionalFields},order:1},session:{modelName:e.session?.modelName||"session",fields:{expiresAt:{type:"date",required:!0,fieldName:e.session?.fields?.expiresAt||"expiresAt"},token:{type:"string",required:!0,fieldName:e.session?.fields?.token||"token",unique:!0},createdAt:{type:"date",required:!0,fieldName:e.session?.fields?.createdAt||"createdAt"},updatedAt:{type:"date",required:!0,fieldName:e.session?.fields?.updatedAt||"updatedAt"},ipAddress:{type:"string",required:!1,fieldName:e.session?.fields?.ipAddress||"ipAddress"},userAgent:{type:"string",required:!1,fieldName:e.session?.fields?.userAgent||"userAgent"},userId:{type:"string",fieldName:e.session?.fields?.userId||"userId",references:{model:e.user?.modelName||"user",field:"id",onDelete:"cascade"},required:!0},...g?.fields,...e.session?.additionalFields},order:2},account:{modelName:e.account?.modelName||"account",fields:{accountId:{type:"string",required:!0,fieldName:e.account?.fields?.accountId||"accountId"},providerId:{type:"string",required:!0,fieldName:e.account?.fields?.providerId||"providerId"},userId:{type:"string",references:{model:e.user?.modelName||"user",field:"id",onDelete:"cascade"},required:!0,fieldName:e.account?.fields?.userId||"userId"},accessToken:{type:"string",required:!1,fieldName:e.account?.fields?.accessToken||"accessToken"},refreshToken:{type:"string",required:!1,fieldName:e.account?.fields?.refreshToken||"refreshToken"},idToken:{type:"string",required:!1,fieldName:e.account?.fields?.idToken||"idToken"},accessTokenExpiresAt:{type:"date",required:!1,fieldName:e.account?.fields?.accessTokenExpiresAt||"accessTokenExpiresAt"},refreshTokenExpiresAt:{type:"date",required:!1,fieldName:e.account?.fields?.accessTokenExpiresAt||"refreshTokenExpiresAt"},scope:{type:"string",required:!1,fieldName:e.account?.fields?.scope||"scope"},password:{type:"string",required:!1,fieldName:e.account?.fields?.password||"password"},createdAt:{type:"date",required:!0,fieldName:e.account?.fields?.createdAt||"createdAt"},updatedAt:{type:"date",required:!0,fieldName:e.account?.fields?.updatedAt||"updatedAt"},...u?.fields},order:3},verification:{modelName:e.verification?.modelName||"verification",fields:{identifier:{type:"string",required:!0,fieldName:e.verification?.fields?.identifier||"identifier"},value:{type:"string",required:!0,fieldName:e.verification?.fields?.value||"value"},expiresAt:{type:"date",required:!0,fieldName:e.verification?.fields?.expiresAt||"expiresAt"},createdAt:{type:"date",required:!1,defaultValue:()=>new Date,fieldName:e.verification?.fields?.createdAt||"createdAt"},updatedAt:{type:"date",required:!1,defaultValue:()=>new Date,fieldName:e.verification?.fields?.updatedAt||"updatedAt"}},order:4},...m,...l?d:{}}};var k=require("zod");function Ie(e){return k.z.object({...Object.keys(e).reduce((l,d)=>{let f=e[d];if(!f)return l;if(f.type==="string[]"||f.type==="number[]")return{...l,[d]:k.z.array(f.type==="string[]"?k.z.string():k.z.number())};if(Array.isArray(f.type))return{...l,[d]:k.z.any()};let g=k.z[f.type]();return f?.required===!1&&(g=g.optional()),f?.returned===!1?l:{...l,[d]:g}},{})})}var D=require("kysely"),T=require("kysely");function Q(e){if(!e)return null;if("dialect"in e)return Q(e.dialect);if("createDriver"in e){if(e instanceof T.SqliteDialect)return"sqlite";if(e instanceof T.MysqlDialect)return"mysql";if(e instanceof T.PostgresDialect)return"postgres";if(e instanceof D.MssqlDialect)return"mssql"}return"aggregate"in e?"sqlite":"getConnection"in e?"mysql":"connect"in e?"postgres":null}var q=async e=>{let n=e.database;if(!n)return{kysely:null,databaseType:null};if("db"in n)return{kysely:n.db,databaseType:n.type};if("dialect"in n)return{kysely:new D.Kysely({dialect:n.dialect}),databaseType:n.type};let l,d=Q(n);return"createDriver"in n&&(l=n),"aggregate"in n&&(l=new T.SqliteDialect({database:n})),"getConnection"in n&&(l=new T.MysqlDialect(n)),"connect"in n&&(l=new T.PostgresDialect({pool:n})),{kysely:l?new D.Kysely({dialect:l}):null,databaseType:d}};function B(e,n,l){return l==="update"?e:e==null&&n.defaultValue?typeof n.defaultValue=="function"?n.defaultValue():n.defaultValue:e}var De=(e,n,l)=>{let d=v(n);function f(r,i){if(i==="id")return i;let a=d[r].fields[i];return a||console.log("Field not found",r,i),a.fieldName||i}function g(r,i,a){let{type:o="sqlite"}=l||{},c=d[i].fields[a];return c.type==="boolean"&&o==="sqlite"&&r!==null&&r!==void 0?r?1:0:c.type==="date"&&r&&r instanceof Date&&o==="sqlite"?r.toISOString():r}function u(r,i,a){let{type:o="sqlite"}=l||{},c=d[i].fields[a];return c.type==="boolean"&&o==="sqlite"&&r!==null?r===1:c.type==="date"&&r?new Date(r):r}function m(r){return d[r].modelName}let t=n?.advanced?.generateId===!1;return{transformInput(r,i,a){let o=t||a==="update"?{}:{id:n.advanced?.generateId?n.advanced.generateId({model:i}):r.id||F()},c=d[i].fields;for(let s in c){let p=r[s];o[c[s].fieldName||s]=B(g(p,i,s),c[s],a)}return o},transformOutput(r,i,a=[]){if(!r)return null;let o=r.id?a.length===0||a.includes("id")?{id:r.id}:{}:{},c=d[i].fields;for(let s in c){if(a.length&&!a.includes(s))continue;let p=c[s];p&&(o[s]=u(r[p.fieldName||s],i,s))}return o},convertWhereClause(r,i){if(!i)return{and:null,or:null};let a={and:[],or:[]};return i.forEach(o=>{let{field:c,value:s,operator:p="=",connector:A="AND"}=o,y=f(r,c),w=h=>p.toLowerCase()==="in"?h(y,"in",Array.isArray(s)?s:[s]):p==="contains"?h(y,"like",`%${s}%`):p==="starts_with"?h(y,"like",`${s}%`):p==="ends_with"?h(y,"like",`%${s}`):p==="eq"?h(y,"=",s):p==="ne"?h(y,"<>",s):p==="gt"?h(y,">",s):p==="gte"?h(y,">=",s):p==="lt"?h(y,"<",s):p==="lte"?h(y,"<=",s):h(y,p,s);A==="OR"?a.or.push(w):a.and.push(w)}),{and:a.and.length?a.and:null,or:a.or.length?a.or:null}},async withReturning(r,i,a,o){let c;if(l?.type!=="mysql")c=await i.returningAll().executeTakeFirst();else{await i.execute();let s=r.id?"id":o[0].field?o[0].field:"id",p=r[s]||o[0].value;c=await e.selectFrom(m(a)).selectAll().where(f(a,s),"=",p).executeTakeFirst()}return c},getModelName:m,getField:f}},X=(e,n)=>l=>{let{transformInput:d,withReturning:f,transformOutput:g,convertWhereClause:u,getModelName:m,getField:t}=De(e,l,n);return{id:"kysely",async create(r){let{model:i,data:a,select:o}=r,c=d(a,i,"create"),s=e.insertInto(m(i)).values(c);return g(await f(c,s,i,[]),i,o)},async findOne(r){let{model:i,where:a,select:o}=r,{and:c,or:s}=u(i,a),p=e.selectFrom(m(i)).selectAll();c&&(p=p.where(y=>y.and(c.map(w=>w(y))))),s&&(p=p.where(y=>y.or(s.map(w=>w(y)))));let A=await p.executeTakeFirst();return A?g(A,i,o):null},async findMany(r){let{model:i,where:a,limit:o,offset:c,sortBy:s}=r,{and:p,or:A}=u(i,a),y=e.selectFrom(m(i));p&&(y=y.where(h=>h.and(p.map(R=>R(h))))),A&&(y=y.where(h=>h.or(A.map(R=>R(h))))),y=y.limit(o||100),c&&(y=y.offset(c)),s&&(y=y.orderBy(t(i,s.field),s.direction));let w=await y.selectAll().execute();return w?w.map(h=>g(h,i)):[]},async update(r){let{model:i,where:a,update:o}=r,{and:c,or:s}=u(i,a),p=d(o,i,"update"),A=e.updateTable(m(i)).set(p);return c&&(A=A.where(w=>w.and(c.map(h=>h(w))))),s&&(A=A.where(w=>w.or(s.map(h=>h(w))))),await g(await f(p,A,i,a),i)},async updateMany(r){let{model:i,where:a,update:o}=r,{and:c,or:s}=u(i,a),p=d(o,i,"update"),A=e.updateTable(m(i)).set(p);return c&&(A=A.where(w=>w.and(c.map(h=>h(w))))),s&&(A=A.where(w=>w.or(s.map(h=>h(w))))),(await A.execute()).length},async delete(r){let{model:i,where:a}=r,{and:o,or:c}=u(i,a),s=e.deleteFrom(m(i));o&&(s=s.where(p=>p.and(o.map(A=>A(p))))),c&&(s=s.where(p=>p.or(c.map(A=>A(p))))),await s.execute()},async deleteMany(r){let{model:i,where:a}=r,{and:o,or:c}=u(i,a),s=e.deleteFrom(m(i));return o&&(s=s.where(p=>p.and(o.map(A=>A(p))))),c&&(s=s.where(p=>p.or(c.map(A=>A(p))))),(await s.execute()).length},options:n}};var Ue=e=>{let n=v(e);function l(d,f){return f==="id"?f:n[d].fields[f].fieldName||f}return{transformInput(d,f,g){let u=g==="update"?{}:{id:e.advanced?.generateId?e.advanced.generateId({model:f}):d.id||F()},m=n[f].fields;for(let t in m){let r=d[t];r===void 0&&!m[t].defaultValue||(u[m[t].fieldName||t]=B(r,m[t],g))}return u},transformOutput(d,f,g=[]){if(!d)return null;let u=d.id||d._id?g.length===0||g.includes("id")?{id:d.id}:{}:{},m=n[f].fields;for(let t in m){if(g.length&&!g.includes(t))continue;let r=m[t];r&&(u[t]=d[r.fieldName||t])}return u},convertWhereClause(d,f,g){return f.filter(u=>d.every(m=>{let{field:t,value:r,operator:i}=m,a=l(g,t);if(i==="in"){if(!Array.isArray(r))throw new Error("Value must be an array");return r.includes(u[a])}else return i==="contains"?u[a].includes(r):i==="starts_with"?u[a].startsWith(r):i==="ends_with"?u[a].endsWith(r):u[a]===r}))},getField:l}},Y=e=>n=>{let{transformInput:l,transformOutput:d,convertWhereClause:f,getField:g}=Ue(n);return{id:"memory",create:async({model:u,data:m})=>{let t=l(m,u,"create");return e[u].push(t),d(t,u)},findOne:async({model:u,where:m,select:t})=>{let r=e[u],a=f(m,r,u)[0]||null;return d(a,u,t)},findMany:async({model:u,where:m,sortBy:t,limit:r,offset:i})=>{let a=e[u];return m&&(a=f(m,a,u)),t&&(a=a.sort((o,c)=>{let s=g(u,t.field);return t.direction==="asc"?o[s]>c[s]?1:-1:o[s]<c[s]?1:-1})),i!==void 0&&(a=a.slice(i)),r!==void 0&&(a=a.slice(0,r)),a.map(o=>d(o,u))},update:async({model:u,where:m,update:t})=>{let r=e[u],i=f(m,r,u);return i.forEach(a=>{Object.assign(a,l(t,u,"update"))}),d(i[0],u)},delete:async({model:u,where:m})=>{let t=e[u],r=f(m,t,u);e[u]=t.filter(i=>!r.includes(i))},deleteMany:async({model:u,where:m})=>{let t=e[u],r=f(m,t,u),i=0;return e[u]=t.filter(a=>r.includes(a)?(i++,!1):!r.includes(a)),i},updateMany(u){let{model:m,where:t,update:r}=u,i=e[m],a=f(t,i,m);return a.forEach(o=>{Object.assign(o,r)}),a[0]||null}}};async function Ne(e){if(!e.database){let d=v(e),f=Object.keys(d).reduce((g,u)=>(g[u]=[],g),{});return Z.warn("No database configuration provided. Using memory adapter in development"),Y(f)(e)}if(typeof e.database=="function")return e.database(e);let{kysely:n,databaseType:l}=await q(e);if(!n)throw new I("Failed to initialize database adapter");return X(n,{type:l||"sqlite"})(e)}function Se(e,n){let l=n.id?{id:n.id}:{};for(let d in e){let f=e[d],g=n[d];g!==void 0&&(l[f.fieldName||d]=g)}return l}function qe(e,n){if(!n)return null;let l={id:n.id};for(let[d,f]of Object.entries(e))l[d]=n[f.fieldName||d];return l}function j(e){let n=v(e),l={};for(let d in n){let f=n[d],g=f.fields,u={};if(Object.entries(g).forEach(([m,t])=>{if(u[t.fieldName||m]=t,t.references){let r=n[t.references.model];r&&(u[t.fieldName||m].references={model:r.modelName,field:t.references.field})}}),l[f.modelName]){l[f.modelName].fields={...l[f.modelName].fields,...u};continue}l[f.modelName]={fields:u,order:f.order||1/0}}return l}var Be={string:["character varying","text"],number:["int4","integer","bigint","smallint","numeric","real","double precision"],boolean:["bool","boolean"],date:["timestamp","date"]},Le={string:["varchar","text"],number:["integer","int","bigint","smallint","decimal","float","double"],boolean:["boolean","tinyint"],date:["timestamp","datetime","date"]},Ee={string:["TEXT"],number:["INTEGER","REAL"],boolean:["INTEGER","BOOLEAN"],date:["DATE","INTEGER"]},Pe={string:["nvarchar","varchar"],number:["int","bigint","smallint","decimal","float","double"],boolean:["bit","boolean"],date:["datetime","date"]},Ve={postgres:Be,mysql:Le,sqlite:Ee,mssql:Pe};function ee(e,n,l){if(n==="string[]"||n==="number[]")return e.toLowerCase().includes("json");let d=Ve[l];return(Array.isArray(n)?d.string.map(u=>u.toLowerCase()):d[n].map(u=>u.toLowerCase())).includes(e.toLowerCase())}async function Me(e){let n=j(e),l=C(e.logger),{kysely:d,databaseType:f}=await q(e);f||(l.warn("Could not determine database type, defaulting to sqlite. Please provide a type in the database options to avoid this."),f="sqlite"),d||(l.error("Only kysely adapter is supported for migrations. You can use `generate` command to generate the schema, if you're using a different adapter."),process.exit(1));let g=await d.introspection.getTables(),u=[],m=[];for(let[o,c]of Object.entries(n)){let s=g.find(A=>A.name===o);if(!s){let A=u.findIndex(h=>h.table===o),y={table:o,fields:c.fields,order:c.order||1/0},w=u.findIndex(h=>(h.order||1/0)>y.order);w===-1?A===-1?u.push(y):u[A].fields={...u[A].fields,...c.fields}:u.splice(w,0,y);continue}let p={};for(let[A,y]of Object.entries(c.fields)){let w=s.columns.find(h=>h.name===A);if(!w){p[A]=y;continue}ee(w.dataType,y.type,f)||l.warn(`Field ${A} in table ${o} has a different type in the database. Expected ${y.type} but got ${w.dataType}.`)}Object.keys(p).length>0&&m.push({table:o,fields:p,order:c.order||1/0})}let t=[];function r(o){let c=o.type,s={string:{sqlite:"text",postgres:"text",mysql:o.unique?"varchar(255)":o.references?"varchar(36)":"text",mssql:"text"},boolean:{sqlite:"integer",postgres:"boolean",mysql:"boolean",mssql:"boolean"},number:{sqlite:"integer",postgres:"integer",mysql:"integer",mssql:"integer"},date:{sqlite:"date",postgres:"timestamp",mysql:"datetime",mssql:"datetime"}};return f==="sqlite"&&(c==="string[]"||c==="number[]")?"text":c==="string[]"||c==="number[]"?"jsonb":Array.isArray(c)?"text":s[c][f||"sqlite"]}if(m.length)for(let o of m)for(let[c,s]of Object.entries(o.fields)){let p=r(s),A=d.schema.alterTable(o.table).addColumn(c,p,y=>(y=s.required!==!1?y.notNull():y,s.references&&(y=y.references(`${s.references.model}.${s.references.field}`)),s.unique&&(y=y.unique()),y));t.push(A)}if(u.length)for(let o of u){let c=d.schema.createTable(o.table).addColumn("id",f==="mysql"?"varchar(36)":"text",s=>s.primaryKey().notNull());for(let[s,p]of Object.entries(o.fields)){let A=r(p);c=c.addColumn(s,A,y=>(y=p.required!==!1?y.notNull():y,p.references&&(y=y.references(`${p.references.model}.${p.references.field}`)),p.unique&&(y=y.unique()),y))}t.push(c)}async function i(){for(let o of t)await o.execute()}async function a(){return t.map(c=>c.compile().sql).join(`;

`)}return{toBeCreated:u,toBeAdded:m,runMigrations:i,compileMigrations:a}}0&&(module.exports={convertFromDB,convertToDB,createFieldAttribute,createInternalAdapter,getAdapter,getAuthTables,getMigrations,getSchema,getWithHooks,matchType,toZodSchema});
