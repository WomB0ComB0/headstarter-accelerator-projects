"use strict";var Ee=Object.defineProperty;var zt=Object.getOwnPropertyDescriptor;var Mt=Object.getOwnPropertyNames;var qt=Object.prototype.hasOwnProperty;var Ft=(e,t)=>{for(var r in t)Ee(e,r,{get:t[r],enumerable:!0})},Ht=(e,t,r,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of Mt(t))!qt.call(e,i)&&i!==r&&Ee(e,i,{get:()=>t[i],enumerable:!(o=zt(t,i))||o.enumerable});return e};var Gt=e=>Ht(Ee({},"__esModule",{value:!0}),e);var ao={};Ft(ao,{sso:()=>so});module.exports=Gt(ao);var y=require("zod");var pe=require("better-call");var Oe=require("better-call");var X=require("better-call"),$e=(0,X.createMiddleware)(async()=>({})),ie=(0,X.createMiddlewareCreator)({use:[$e,(0,X.createMiddleware)(async()=>({}))]}),w=(0,X.createEndpointCreator)({use:[$e]});function Ue(e){return e==="-"||e==="^"||e==="$"||e==="+"||e==="."||e==="("||e===")"||e==="|"||e==="["||e==="]"||e==="{"||e==="}"||e==="*"||e==="?"||e==="\\"?`\\${e}`:e}function Wt(e){let t="";for(let r=0;r<e.length;r++)t+=Ue(e[r]);return t}function Ve(e,t=!0){if(Array.isArray(e))return`(?:${e.map(l=>`^${Ve(l,t)}$`).join("|")})`;let r="",o="",i=".";t===!0?(r="/",o="[/\\\\]",i="[^/\\\\]"):t&&(r=t,o=Wt(r),o.length>1?(o=`(?:${o})`,i=`((?!${o}).)`):i=`[^${o}]`);let n=t?`${o}+?`:"",a=t?`${o}*?`:"",d=t?e.split(r):[e],s="";for(let c=0;c<d.length;c++){let l=d[c],u=d[c+1],p="";if(!(!l&&c>0)){if(t&&(c===d.length-1?p=a:u!=="**"?p=n:p=""),t&&l==="**"){p&&(s+=c===0?"":p,s+=`(?:${i}*?${p})*?`);continue}for(let g=0;g<l.length;g++){let m=l[g];m==="\\"?g<l.length-1&&(s+=Ue(l[g+1]),g++):m==="?"?s+=i:m==="*"?s+=`${i}*?`:s+=Ue(m)}s+=p}}return s}function Qt(e,t){if(typeof t!="string")throw new TypeError(`Sample must be a string, but ${typeof t} given`);return e.test(t)}function we(e,t){if(typeof e!="string"&&!Array.isArray(e))throw new TypeError(`The first argument must be a single pattern string or an array of patterns, but ${typeof e} given`);if((typeof t=="string"||typeof t=="boolean")&&(t={separator:t}),arguments.length===2&&!(typeof t>"u"||typeof t=="object"&&t!==null&&!Array.isArray(t)))throw new TypeError(`The second argument must be an options object or a string/boolean separator, but ${typeof t} given`);if(t=t||{},t.separator==="\\")throw new Error("\\ is not a valid separator because it is used for escaping. Try setting the separator to `true` instead");let r=Ve(e,t.separator),o=new RegExp(`^${r}$`,t.flags),i=Qt.bind(null,o);return i.options=t,i.pattern=e,i.regexp=o,i}var ye=Object.create(null),fe=e=>globalThis.process?.env||globalThis.Deno?.env.toObject()||globalThis.__env__||(e?ye:globalThis),Be=new Proxy(ye,{get(e,t){return fe()[t]??ye[t]},has(e,t){let r=fe();return t in r||t in ye},set(e,t,r){let o=fe(!0);return o[t]=r,!0},deleteProperty(e,t){if(!t)return!1;let r=fe(!0);return delete r[t],!0},ownKeys(){let e=fe(!0);return Object.keys(e)}});function Jt(e){return e?e!=="false":!1}var Te=typeof process<"u"&&process.env&&process.env.NODE_ENV||"";var ve=Te==="dev"||Te==="development",Zt=Te==="test"||Jt(Be.TEST);var Q=class extends Error{constructor(t,r){super(t),this.name="BetterAuthError",this.message=t,this.cause=r,this.stack=""}};function be(e){try{return new URL(e).origin}catch{return null}}function ze(e){try{return new URL(e).protocol}catch{return null}}function Se(e){return e.includes("://")?new URL(e).host:e}var Kt=ie(async e=>{if(e.request?.method!=="POST")return;let{body:t,query:r,context:o}=e,i=e.headers?.get("origin")||e.headers?.get("referer")||"",n=t?.callbackURL||r?.callbackURL,a=t?.redirectTo,d=r?.currentURL,s=t?.errorCallbackURL,c=t?.newUserCallbackURL,l=o.trustedOrigins,u=e.headers?.has("cookie"),p=(m,U)=>{if(m.startsWith("/"))return!1;if(U.includes("*"))return we(U)(Se(m));let V=ze(m);return V==="http:"||V==="https:"||!V?U===be(m):m.startsWith(U)},g=(m,U)=>{if(!m)return;if(!l.some(j=>p(m,j)||m?.startsWith("/")&&U!=="origin"&&!m.includes(":")))throw e.context.logger.error(`Invalid ${U}: ${m}`),e.context.logger.info(`If it's a valid URL, please add ${m} to trustedOrigins in your auth config
`,`Current list of trustedOrigins: ${l}`),new Oe.APIError("FORBIDDEN",{message:`Invalid ${U}`})};u&&!e.context.options.advanced?.disableCSRFCheck&&g(i,"origin"),n&&g(n,"callbackURL"),a&&g(a,"redirectURL"),d&&g(d,"currentURL"),s&&g(s,"errorCallbackURL"),c&&g(c,"newUserCallbackURL")}),ne=e=>ie(async t=>{let{context:r}=t,o=e(t),i=r.trustedOrigins,n=(d,s)=>d.startsWith("/")?!1:s.includes("*")?we(s)(Se(d)):d.startsWith(s);o&&((d,s)=>{if(!d)return;if(!i.some(l=>n(d,l)||d?.startsWith("/")&&s!=="origin"&&!d.includes(":")))throw t.context.logger.error(`Invalid ${s}: ${d}`),t.context.logger.info(`If it's a valid URL, please add ${d} to trustedOrigins in your auth config
`,`Current list of trustedOrigins: ${i}`),new Oe.APIError("FORBIDDEN",{message:`Invalid ${s}`})})(o,"callbackURL")});var O=require("better-call"),T=require("zod");var J=(e,t="ms")=>new Date(Date.now()+(t==="sec"?e*1e3:e));var Me=require("@better-auth/utils/base64");var qe=require("@better-auth/utils/hmac");async function Ie(e,t){if(e.context.options.session?.cookieCache?.enabled){let o=Me.base64Url.encode(JSON.stringify({session:t,expiresAt:J(e.context.authCookies.sessionData.options.maxAge||60,"sec").getTime(),signature:await(0,qe.createHMAC)("SHA-256","base64urlnopad").sign(e.context.secret,JSON.stringify(t))}),{padding:!1});if(o.length>4093)throw new Q("Session data is too large to store in the cookie. Please disable session cookie caching or reduce the size of the session data");e.setCookie(e.context.authCookies.sessionData.name,o,e.context.authCookies.sessionData.options)}}async function L(e,t,r,o){let i=e.context.authCookies.sessionToken.options,n=r?void 0:e.context.sessionConfig.expiresIn;await e.setSignedCookie(e.context.authCookies.sessionToken.name,t.session.token,e.context.secret,{...i,maxAge:n,...o}),r&&await e.setSignedCookie(e.context.authCookies.dontRememberToken.name,"true",e.context.secret,e.context.authCookies.dontRememberToken.options),await Ie(e,t),e.context.setNewSession(t),e.context.options.secondaryStorage&&await e.context.secondaryStorage?.set(t.session.token,JSON.stringify({user:t.user,session:t.session}),Math.floor((new Date(t.session.expiresAt).getTime()-Date.now())/1e3))}function B(e){e.setCookie(e.context.authCookies.sessionToken.name,"",{...e.context.authCookies.sessionToken.options,maxAge:0}),e.setCookie(e.context.authCookies.sessionData.name,"",{...e.context.authCookies.sessionData.options,maxAge:0}),e.setCookie(e.context.authCookies.dontRememberToken.name,"",{...e.context.authCookies.dontRememberToken.options,maxAge:0})}var Yt=Object.defineProperty,Xt=Object.defineProperties,er=Object.getOwnPropertyDescriptors,Fe=Object.getOwnPropertySymbols,tr=Object.prototype.hasOwnProperty,rr=Object.prototype.propertyIsEnumerable,He=(e,t,r)=>t in e?Yt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,ee=(e,t)=>{for(var r in t||(t={}))tr.call(t,r)&&He(e,r,t[r]);if(Fe)for(var r of Fe(t))rr.call(t,r)&&He(e,r,t[r]);return e},te=(e,t)=>Xt(e,er(t)),Le=class extends Error{constructor(e,t,r){super(t||e.toString(),{cause:r}),this.status=e,this.statusText=t,this.error=r}},or=async(e,t)=>{var r,o,i,n,a,d;let s=t||{},c={onRequest:[t?.onRequest],onResponse:[t?.onResponse],onSuccess:[t?.onSuccess],onError:[t?.onError],onRetry:[t?.onRetry]};if(!t||!t?.plugins)return{url:e,options:s,hooks:c};for(let l of t?.plugins||[]){if(l.init){let u=await((r=l.init)==null?void 0:r.call(l,e.toString(),t));s=u.options||s,e=u.url}c.onRequest.push((o=l.hooks)==null?void 0:o.onRequest),c.onResponse.push((i=l.hooks)==null?void 0:i.onResponse),c.onSuccess.push((n=l.hooks)==null?void 0:n.onSuccess),c.onError.push((a=l.hooks)==null?void 0:a.onError),c.onRetry.push((d=l.hooks)==null?void 0:d.onRetry)}return{url:e,options:s,hooks:c}},Ge=class{constructor(e){this.options=e}shouldAttemptRetry(e,t){return this.options.shouldRetry?Promise.resolve(e<this.options.attempts&&this.options.shouldRetry(t)):Promise.resolve(e<this.options.attempts)}getDelay(){return this.options.delay}},ir=class{constructor(e){this.options=e}shouldAttemptRetry(e,t){return this.options.shouldRetry?Promise.resolve(e<this.options.attempts&&this.options.shouldRetry(t)):Promise.resolve(e<this.options.attempts)}getDelay(e){return Math.min(this.options.maxDelay,this.options.baseDelay*2**e)}};function nr(e){if(typeof e=="number")return new Ge({type:"linear",attempts:e,delay:1e3});switch(e.type){case"linear":return new Ge(e);case"exponential":return new ir(e);default:throw new Error("Invalid retry strategy")}}var sr=e=>{let t={},r=o=>typeof o=="function"?o():o;if(e?.auth){if(e.auth.type==="Bearer"){let o=r(e.auth.token);if(!o)return t;t.authorization=`Bearer ${o}`}else if(e.auth.type==="Basic"){let o=r(e.auth.username),i=r(e.auth.password);if(!o||!i)return t;t.authorization=`Basic ${btoa(`${o}:${i}`)}`}else if(e.auth.type==="Custom"){let o=r(e.auth.value);if(!o)return t;t.authorization=`${r(e.auth.prefix)} ${o}`}}return t},Je=["get","post","put","patch","delete"];var ar=/^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;function dr(e){let t=e.headers.get("content-type"),r=new Set(["image/svg","application/xml","application/xhtml","application/html"]);if(!t)return"json";let o=t.split(";").shift()||"";return ar.test(o)?"json":r.has(o)||o.startsWith("text/")?"text":"blob"}function cr(e){try{return JSON.parse(e),!0}catch{return!1}}function Ze(e){if(e===void 0)return!1;let t=typeof e;return t==="string"||t==="number"||t==="boolean"||t===null?!0:t!=="object"?!1:Array.isArray(e)?!0:e.buffer?!1:e.constructor&&e.constructor.name==="Object"||typeof e.toJSON=="function"}function We(e){try{return JSON.parse(e)}catch{return e}}function Qe(e){return typeof e=="function"}function lr(e){if(e?.customFetchImpl)return e.customFetchImpl;if(typeof globalThis<"u"&&Qe(globalThis.fetch))return globalThis.fetch;if(typeof window<"u"&&Qe(window.fetch))return window.fetch;throw new Error("No fetch implementation found")}function ur(e){let t=new Headers(e?.headers),r=sr(e);for(let[o,i]of Object.entries(r||{}))t.set(o,i);if(!t.has("content-type")){let o=pr(e?.body);o&&t.set("content-type",o)}return t}function pr(e){return Ze(e)?"application/json":null}function fr(e){if(!e?.body)return null;let t=new Headers(e?.headers);return Ze(e.body)&&!t.has("content-type")?JSON.stringify(e.body):e.body}function mr(e,t){var r;if(t?.method)return t.method.toUpperCase();if(e.startsWith("@")){let o=(r=e.split("@")[1])==null?void 0:r.split("/")[0];return Je.includes(o)?o.toUpperCase():t?.body?"POST":"GET"}return t?.body?"POST":"GET"}function gr(e,t){let r;return!e?.signal&&e?.timeout&&(r=setTimeout(()=>t?.abort(),e?.timeout)),{abortTimeout:r,clearTimeout:()=>{r&&clearTimeout(r)}}}function hr(e,t){let{baseURL:r,params:o,query:i}=t||{query:{},params:{},baseURL:""},n=e.startsWith("http")?e.split("/").slice(0,3).join("/"):r;if(!n)throw new TypeError(`Invalid URL ${e}. Are you passing in a relative URL but not setting the baseURL?`);if(e.startsWith("@")){let u=e.toString().split("@")[1].split("/")[0];Je.includes(u)&&(e=e.replace(`@${u}/`,"/"))}n.endsWith("/")||(n+="/");let[a,d]=e.replace(n,"").split("?"),s=new URLSearchParams(d);for(let[u,p]of Object.entries(i||{}))s.set(u,String(p));if(o)if(Array.isArray(o)){let u=a.split("/").filter(p=>p.startsWith(":"));for(let[p,g]of u.entries()){let m=o[p];a=a.replace(g,m)}}else for(let[u,p]of Object.entries(o))a=a.replace(`:${u}`,String(p));a=a.split("/").map(encodeURIComponent).join("/"),a.startsWith("/")&&(a=a.slice(1));let c=s.size>0?`?${s}`.replace(/\+/g,"%20"):"";return new URL(`${a}${c}`,n)}var R=async(e,t)=>{var r,o,i,n,a,d,s,c;let{hooks:l,url:u,options:p}=await or(e,t),g=lr(p),m=new AbortController,U=(r=p.signal)!=null?r:m.signal,V=hr(u,p),j=fr(p),F=ur(p),A=mr(u,p),b=te(ee({},p),{url:V,headers:F,body:j,method:A,signal:U});for(let C of l.onRequest)if(C){let I=await C(b);I instanceof Object&&(b=I)}("pipeTo"in b&&typeof b.pipeTo=="function"||typeof((o=t?.body)==null?void 0:o.pipe)=="function")&&("duplex"in b||(b.duplex="half"));let{clearTimeout:N}=gr(p,m),k=await g(b.url,b);N();let he={response:k,request:b};for(let C of l.onResponse)if(C){let I=await C(te(ee({},he),{response:(i=t?.hookOptions)!=null&&i.cloneResponse?k.clone():k}));I instanceof Response?k=I:I instanceof Object&&(k=I.response)}if(k.ok){if(!(b.method!=="HEAD"))return{data:"",error:null};let I=dr(k),H={data:"",response:k,request:b};if(I==="json"||I==="text"){let G=await k.text(),Bt=await((n=b.jsonParser)!=null?n:We)(G);H.data=Bt}else H.data=await k[I]();b?.output&&b.output&&!b.disableValidation&&(H.data=b.output.parse(H.data));for(let G of l.onSuccess)G&&await G(te(ee({},H),{response:(a=t?.hookOptions)!=null&&a.cloneResponse?k.clone():k}));return t?.throw?H.data:{data:H.data,error:null}}let $t=(d=t?.jsonParser)!=null?d:We,Ne=await k.text(),_e=cr(Ne)?await $t(Ne):{},Vt={response:k,request:b,error:te(ee({},_e),{status:k.status,statusText:k.statusText})};for(let C of l.onError)C&&await C(te(ee({},Vt),{response:(s=t?.hookOptions)!=null&&s.cloneResponse?k.clone():k}));if(t?.retry){let C=nr(t.retry),I=(c=t.retryAttempt)!=null?c:0;if(await C.shouldAttemptRetry(I,k)){for(let G of l.onRetry)G&&await G(he);let H=C.getDelay(I);return await new Promise(G=>setTimeout(G,H)),await R(e,te(ee({},t),{retryAttempt:I+1}))}}if(t?.throw)throw new Le(k.status,k.statusText,_e);return{data:null,error:te(ee({},_e),{status:k.status,statusText:k.statusText})}};var nt=require("better-call"),Z=require("jose");var Ke=require("@better-auth/utils/hash"),Ye=require("@better-auth/utils/base64");async function Xe(e){let t=await(0,Ke.createHash)("SHA-256").digest(e);return Ye.base64Url.encode(new Uint8Array(t),{padding:!1})}function Ae(e){return{tokenType:e.token_type,accessToken:e.access_token,refreshToken:e.refresh_token,accessTokenExpiresAt:e.expires_in?J(e.expires_in,"sec"):void 0,scopes:e?.scope?typeof e.scope=="string"?e.scope.split(" "):e.scope:[],idToken:e.id_token}}async function E({id:e,options:t,authorizationEndpoint:r,state:o,codeVerifier:i,scopes:n,claims:a,redirectURI:d,duration:s}){let c=new URL(r);if(c.searchParams.set("response_type","code"),c.searchParams.set("client_id",t.clientId),c.searchParams.set("state",o),c.searchParams.set("scope",n.join(" ")),c.searchParams.set("redirect_uri",t.redirectURI||d),i){let l=await Xe(i);c.searchParams.set("code_challenge_method","S256"),c.searchParams.set("code_challenge",l)}if(a){let l=a.reduce((u,p)=>(u[p]=null,u),{});c.searchParams.set("claims",JSON.stringify({id_token:{email:null,email_verified:null,...l}}))}return s&&c.searchParams.set("duration",s),c}var et=require("jose");async function _({code:e,codeVerifier:t,redirectURI:r,options:o,tokenEndpoint:i,authentication:n}){let a=new URLSearchParams,d={"content-type":"application/x-www-form-urlencoded",accept:"application/json","user-agent":"better-auth"};if(a.set("grant_type","authorization_code"),a.set("code",e),t&&a.set("code_verifier",t),a.set("redirect_uri",r),n==="basic"){let u=btoa(`${o.clientId}:${o.clientSecret}`);d.authorization=`Basic ${u}`}else a.set("client_id",o.clientId),a.set("client_secret",o.clientSecret);let{data:s,error:c}=await R(i,{method:"POST",body:a,headers:d});if(c)throw c;return Ae(s)}async function tt(e,t){let{data:r,error:o}=await R(t,{method:"GET",headers:{accept:"application/json","user-agent":"better-auth"}});if(o)throw o;let i=r.keys,n=JSON.parse(atob(e.split(".")[0])),a=i.find(s=>s.kid===n.kid);if(!a)throw new Error("Key not found");return await(0,et.jwtVerify)(e,a)}var z=require("zod"),xe=require("better-call");var kr=require("@better-auth/utils/hash"),_r=require("@noble/ciphers/chacha"),Pe=require("@noble/ciphers/utils"),Er=require("@noble/ciphers/webcrypto");var yr=require("@better-auth/utils/hash");var rt=require("jose");async function ot(e,t,r=3600){return await new rt.SignJWT(e).setProtectedHeader({alg:"HS256"}).setIssuedAt().setExpirationTime(Math.floor(Date.now()/1e3)+r).sign(new TextEncoder().encode(t))}var br=require("@noble/hashes/scrypt"),Ar=require("uncrypto"),Rr=require("@better-auth/utils/hex");var it=require("@better-auth/utils/random"),me=(0,it.createRandomStringGenerator)("a-z","0-9","A-Z","-_");async function se(e,t){let r=e.body?.callbackURL||(e.query?.currentURL?be(e.query?.currentURL):"")||e.context.options.baseURL;if(!r)throw new xe.APIError("BAD_REQUEST",{message:"callbackURL is required"});let o=me(128),i=me(32),n=JSON.stringify({callbackURL:r,codeVerifier:o,errorURL:e.body?.errorCallbackURL||e.query?.currentURL,newUserURL:e.body?.newUserCallbackURL,link:t,expiresAt:Date.now()+10*60*1e3}),a=new Date;a.setMinutes(a.getMinutes()+10);let d=await e.context.internalAdapter.createVerificationValue({value:n,identifier:i,expiresAt:a});if(!d)throw e.context.logger.error("Unable to create verification. Make sure the database adapter is properly working and there is a verification table in the database"),new xe.APIError("INTERNAL_SERVER_ERROR",{message:"Unable to create verification"});return{state:d.identifier,codeVerifier:o}}async function Re(e){let t=e.query.state||e.body.state,r=await e.context.internalAdapter.findVerificationValue(t);if(!r)throw e.context.logger.error("State Mismatch. Verification not found",{state:t}),e.redirect(`${e.context.baseURL}/error?error=please_restart_the_process`);let o=z.z.object({callbackURL:z.z.string(),codeVerifier:z.z.string(),errorURL:z.z.string().optional(),newUserURL:z.z.string().optional(),expiresAt:z.z.number(),link:z.z.object({email:z.z.string(),userId:z.z.string()}).optional()}).parse(JSON.parse(r.value));if(o.errorURL||(o.errorURL=`${e.context.baseURL}/error`),o.expiresAt<Date.now())throw await e.context.internalAdapter.deleteVerificationValue(r.id),e.context.logger.error("State expired.",{state:t}),e.redirect(`${e.context.baseURL}/error?error=please_restart_the_process`);return await e.context.internalAdapter.deleteVerificationValue(r.id),o}var st=e=>{let t="https://appleid.apple.com/auth/token";return{id:"apple",name:"Apple",createAuthorizationURL({state:r,scopes:o,redirectURI:i}){let n=o||["email","name"];return e.scope&&n.push(...e.scope),new URL(`https://appleid.apple.com/auth/authorize?client_id=${e.clientId}&response_type=code&redirect_uri=${e.redirectURI||i}&scope=${n.join(" ")}&state=${r}&response_mode=form_post`)},validateAuthorizationCode:async({code:r,codeVerifier:o,redirectURI:i})=>_({code:r,codeVerifier:o,redirectURI:e.redirectURI||i,options:e,tokenEndpoint:t}),async verifyIdToken(r,o){if(e.disableIdTokenSignIn)return!1;if(e.verifyIdToken)return e.verifyIdToken(r,o);let i=(0,Z.decodeProtectedHeader)(r),{kid:n,alg:a}=i;if(!n||!a)return!1;let d=await Ur(n),{payload:s}=await(0,Z.jwtVerify)(r,d,{algorithms:[a],issuer:"https://appleid.apple.com",audience:e.appBundleIdentifier||e.clientId,maxTokenAge:"1h"});return["email_verified","is_private_email"].forEach(c=>{s[c]!==void 0&&(s[c]=!!s[c])}),o&&s.nonce!==o?!1:!!s},async getUserInfo(r){if(e.getUserInfo)return e.getUserInfo(r);if(!r.idToken)return null;let o=(0,Z.decodeJwt)(r.idToken);if(!o)return null;let i=o.user?`${o.user.name.firstName} ${o.user.name.lastName}`:o.email,n=await e.mapProfileToUser?.(o);return{user:{id:o.sub,name:i,emailVerified:!1,email:o.email,...n},data:o}}}},Ur=async e=>{let t="https://appleid.apple.com",r="/auth/keys",{data:o}=await R(`${t}${r}`);if(!o?.keys)throw new nt.APIError("BAD_REQUEST",{message:"Keys not found"});let i=o.keys.find(n=>n.kid===e);if(!i)throw new Error(`JWK with kid ${e} not found`);return await(0,Z.importJWK)(i,i.alg)};var at=e=>({id:"discord",name:"Discord",createAuthorizationURL({state:t,scopes:r,redirectURI:o}){let i=r||["identify","email"];return e.scope&&i.push(...e.scope),new URL(`https://discord.com/api/oauth2/authorize?scope=${i.join("+")}&response_type=code&client_id=${e.clientId}&redirect_uri=${encodeURIComponent(e.redirectURI||o)}&state=${t}&prompt=${e.prompt||"none"}`)},validateAuthorizationCode:async({code:t,redirectURI:r})=>_({code:t,redirectURI:e.redirectURI||r,options:e,tokenEndpoint:"https://discord.com/api/oauth2/token"}),async getUserInfo(t){if(e.getUserInfo)return e.getUserInfo(t);let{data:r,error:o}=await R("https://discord.com/api/users/@me",{headers:{authorization:`Bearer ${t.accessToken}`}});if(o)return null;if(r.avatar===null){let n=r.discriminator==="0"?Number(BigInt(r.id)>>BigInt(22))%6:parseInt(r.discriminator)%5;r.image_url=`https://cdn.discordapp.com/embed/avatars/${n}.png`}else{let n=r.avatar.startsWith("a_")?"gif":"png";r.image_url=`https://cdn.discordapp.com/avatars/${r.id}/${r.avatar}.${n}`}let i=await e.mapProfileToUser?.(r);return{user:{id:r.id,name:r.display_name||r.username||"",email:r.email,emailVerified:r.verified,image:r.image_url,...i},data:r}}});var dt=e=>({id:"facebook",name:"Facebook",async createAuthorizationURL({state:t,scopes:r,redirectURI:o}){let i=r||["email","public_profile"];return e.scope&&i.push(...e.scope),await E({id:"facebook",options:e,authorizationEndpoint:"https://www.facebook.com/v21.0/dialog/oauth",scopes:i,state:t,redirectURI:o})},validateAuthorizationCode:async({code:t,redirectURI:r})=>_({code:t,redirectURI:e.redirectURI||r,options:e,tokenEndpoint:"https://graph.facebook.com/oauth/access_token"}),async getUserInfo(t){if(e.getUserInfo)return e.getUserInfo(t);let r=["id","name","email","picture",...e?.fields||[]],{data:o,error:i}=await R("https://graph.facebook.com/me?fields="+r.join(","),{auth:{type:"Bearer",token:t.accessToken}});if(i)return null;let n=await e.mapProfileToUser?.(o);return{user:{id:o.id,name:o.name,email:o.email,image:o.picture.data.url,emailVerified:o.email_verified,...n},data:o}}});var ct=e=>{let t="https://github.com/login/oauth/access_token";return{id:"github",name:"GitHub",createAuthorizationURL({state:r,scopes:o,codeVerifier:i,redirectURI:n}){let a=o||["user:email"];return e.scope&&a.push(...e.scope),E({id:"github",options:e,authorizationEndpoint:"https://github.com/login/oauth/authorize",scopes:a,state:r,redirectURI:n})},validateAuthorizationCode:async({code:r,redirectURI:o})=>_({code:r,redirectURI:e.redirectURI||o,options:e,tokenEndpoint:t}),async getUserInfo(r){if(e.getUserInfo)return e.getUserInfo(r);let{data:o,error:i}=await R("https://api.github.com/user",{headers:{"User-Agent":"better-auth",authorization:`Bearer ${r.accessToken}`}});if(i)return null;let n=!1,{data:a}=await R("https://api.github.com/user/emails",{headers:{authorization:`Bearer ${r.accessToken}`,"User-Agent":"better-auth"}});a&&(o.email=(a.find(s=>s.primary)??a[0])?.email,n=a.find(s=>s.email===o.email)?.verified??!1);let d=await e.mapProfileToUser?.(o);return{user:{id:o.id.toString(),name:o.name||o.login,email:o.email,image:o.avatar_url,emailVerified:n,...d},data:o}}}};var lt=require("jose");var Ce=["info","success","warn","error","debug"];function Tr(e,t){return Ce.indexOf(t)<=Ce.indexOf(e)}var M={reset:"\x1B[0m",bright:"\x1B[1m",dim:"\x1B[2m",underscore:"\x1B[4m",blink:"\x1B[5m",reverse:"\x1B[7m",hidden:"\x1B[8m",fg:{black:"\x1B[30m",red:"\x1B[31m",green:"\x1B[32m",yellow:"\x1B[33m",blue:"\x1B[34m",magenta:"\x1B[35m",cyan:"\x1B[36m",white:"\x1B[37m"},bg:{black:"\x1B[40m",red:"\x1B[41m",green:"\x1B[42m",yellow:"\x1B[43m",blue:"\x1B[44m",magenta:"\x1B[45m",cyan:"\x1B[46m",white:"\x1B[47m"}},vr={info:M.fg.blue,success:M.fg.green,warn:M.fg.yellow,error:M.fg.red,debug:M.fg.magenta},Sr=(e,t)=>{let r=new Date().toISOString();return`${M.dim}${r}${M.reset} ${vr[e]}${e.toUpperCase()}${M.reset} ${M.bright}[Better Auth]:${M.reset} ${t}`},Or=e=>{let t=e?.disabled!==!0,r=e?.level??"error",o=(i,n,a=[])=>{if(!t||!Tr(r,i))return;let d=Sr(i,n);if(!e||typeof e.log!="function"){i==="error"?console.error(d,...a):i==="warn"?console.warn(d,...a):console.log(d,...a);return}e.log(i==="success"?"info":i,n,...a)};return Object.fromEntries(Ce.map(i=>[i,(...[n,...a])=>o(i,n,a)]))},$=Or();var ut=e=>({id:"google",name:"Google",async createAuthorizationURL({state:t,scopes:r,codeVerifier:o,redirectURI:i}){if(!e.clientId||!e.clientSecret)throw $.error("Client Id and Client Secret is required for Google. Make sure to provide them in the options."),new Q("CLIENT_ID_AND_SECRET_REQUIRED");if(!o)throw new Q("codeVerifier is required for Google");let n=r||["email","profile","openid"];e.scope&&n.push(...e.scope);let a=await E({id:"google",options:e,authorizationEndpoint:"https://accounts.google.com/o/oauth2/auth",scopes:n,state:t,codeVerifier:o,redirectURI:i});return e.accessType&&a.searchParams.set("access_type",e.accessType),e.prompt&&a.searchParams.set("prompt",e.prompt),e.display&&a.searchParams.set("display",e.display),e.hd&&a.searchParams.set("hd",e.hd),a},validateAuthorizationCode:async({code:t,codeVerifier:r,redirectURI:o})=>_({code:t,codeVerifier:r,redirectURI:e.redirectURI||o,options:e,tokenEndpoint:"https://oauth2.googleapis.com/token"}),async verifyIdToken(t,r){if(e.disableIdTokenSignIn)return!1;if(e.verifyIdToken)return e.verifyIdToken(t,r);let o=`https://www.googleapis.com/oauth2/v3/tokeninfo?id_token=${t}`,{data:i}=await R(o);return i?i.aud===e.clientId&&i.iss==="https://accounts.google.com":!1},async getUserInfo(t){if(e.getUserInfo)return e.getUserInfo(t);if(!t.idToken)return null;let r=(0,lt.decodeJwt)(t.idToken),o=await e.mapProfileToUser?.(r);return{user:{id:r.sub,name:r.name,email:r.email,image:r.picture,emailVerified:r.email_verified,...o},data:r}}});var pt=require("jose"),ft=e=>{let t=e.tenantId||"common",r=`https://login.microsoftonline.com/${t}/oauth2/v2.0/authorize`,o=`https://login.microsoftonline.com/${t}/oauth2/v2.0/token`;return{id:"microsoft",name:"Microsoft EntraID",createAuthorizationURL(i){let n=i.scopes||["openid","profile","email","User.Read"];return e.scope&&n.push(...e.scope),E({id:"microsoft",options:e,authorizationEndpoint:r,state:i.state,codeVerifier:i.codeVerifier,scopes:n,redirectURI:i.redirectURI})},validateAuthorizationCode({code:i,codeVerifier:n,redirectURI:a}){return _({code:i,codeVerifier:n,redirectURI:e.redirectURI||a,options:e,tokenEndpoint:o})},async getUserInfo(i){if(e.getUserInfo)return e.getUserInfo(i);if(!i.idToken)return null;let n=(0,pt.decodeJwt)(i.idToken),a=e.profilePhotoSize||48;await R(`https://graph.microsoft.com/v1.0/me/photos/${a}x${a}/$value`,{headers:{Authorization:`Bearer ${i.accessToken}`},async onResponse(s){if(!(e.disableProfilePhoto||!s.response.ok))try{let l=await s.response.clone().arrayBuffer(),u=Buffer.from(l).toString("base64");n.picture=`data:image/jpeg;base64, ${u}`}catch(c){$.error(c&&typeof c=="object"&&"name"in c?c.name:"",c)}}});let d=await e.mapProfileToUser?.(n);return{user:{id:n.sub,name:n.name,email:n.email,image:n.picture,emailVerified:!0,...d},data:n}}}};var mt=e=>({id:"spotify",name:"Spotify",createAuthorizationURL({state:t,scopes:r,codeVerifier:o,redirectURI:i}){let n=r||["user-read-email"];return e.scope&&n.push(...e.scope),E({id:"spotify",options:e,authorizationEndpoint:"https://accounts.spotify.com/authorize",scopes:n,state:t,codeVerifier:o,redirectURI:i})},validateAuthorizationCode:async({code:t,codeVerifier:r,redirectURI:o})=>_({code:t,codeVerifier:r,redirectURI:e.redirectURI||o,options:e,tokenEndpoint:"https://accounts.spotify.com/api/token"}),async getUserInfo(t){if(e.getUserInfo)return e.getUserInfo(t);let{data:r,error:o}=await R("https://api.spotify.com/v1/me",{method:"GET",headers:{Authorization:`Bearer ${t.accessToken}`}});if(o)return null;let i=await e.mapProfileToUser?.(r);return{user:{id:r.id,name:r.display_name,email:r.email,image:r.images[0]?.url,emailVerified:!1,...i},data:r}}});var ae={isAction:!1};var gt=require("@better-auth/utils/random"),ht=e=>(0,gt.createRandomStringGenerator)("a-z","A-Z","0-9")(e||32);var wt=require("jose"),yt=e=>({id:"twitch",name:"Twitch",createAuthorizationURL({state:t,scopes:r,redirectURI:o}){let i=r||["user:read:email","openid"];return e.scope&&i.push(...e.scope),E({id:"twitch",redirectURI:o,options:e,authorizationEndpoint:"https://id.twitch.tv/oauth2/authorize",scopes:i,state:t,claims:e.claims||["email","email_verified","preferred_username","picture"]})},validateAuthorizationCode:async({code:t,redirectURI:r})=>_({code:t,redirectURI:e.redirectURI||r,options:e,tokenEndpoint:"https://id.twitch.tv/oauth2/token"}),async getUserInfo(t){if(e.getUserInfo)return e.getUserInfo(t);let r=t.idToken;if(!r)return $.error("No idToken found in token"),null;let o=(0,wt.decodeJwt)(r),i=await e.mapProfileToUser?.(o);return{user:{id:o.sub,name:o.preferred_username,email:o.email,image:o.picture,emailVerified:!1,...i},data:o}}});var bt=e=>({id:"twitter",name:"Twitter",createAuthorizationURL(t){let r=t.scopes||["users.read","tweet.read","offline.access"];return e.scope&&r.push(...e.scope),E({id:"twitter",options:e,authorizationEndpoint:"https://x.com/i/oauth2/authorize",scopes:r,state:t.state,codeVerifier:t.codeVerifier,redirectURI:t.redirectURI})},validateAuthorizationCode:async({code:t,codeVerifier:r,redirectURI:o})=>_({code:t,codeVerifier:r,authentication:"basic",redirectURI:e.redirectURI||o,options:e,tokenEndpoint:"https://api.x.com/2/oauth2/token"}),async getUserInfo(t){if(e.getUserInfo)return e.getUserInfo(t);let{data:r,error:o}=await R("https://api.x.com/2/users/me?user.fields=profile_image_url",{method:"GET",headers:{Authorization:`Bearer ${t.accessToken}`}});if(o)return null;let i=await e.mapProfileToUser?.(r);return{user:{id:r.data.id,name:r.data.name,email:r.data.username||null,image:r.data.profile_image_url,emailVerified:r.data.verified||!1,...i},data:r}}});var At=e=>{let t="https://api.dropboxapi.com/oauth2/token";return{id:"dropbox",name:"Dropbox",createAuthorizationURL:async({state:r,scopes:o,codeVerifier:i,redirectURI:n})=>{let a=o||["account_info.read"];return e.scope&&a.push(...e.scope),await E({id:"dropbox",options:e,authorizationEndpoint:"https://www.dropbox.com/oauth2/authorize",scopes:a,state:r,redirectURI:n,codeVerifier:i})},validateAuthorizationCode:async({code:r,codeVerifier:o,redirectURI:i})=>await _({code:r,codeVerifier:o,redirectURI:e.redirectURI||i,options:e,tokenEndpoint:t}),async getUserInfo(r){if(e.getUserInfo)return e.getUserInfo(r);let{data:o,error:i}=await R("https://api.dropboxapi.com/2/users/get_current_account",{method:"POST",headers:{Authorization:`Bearer ${r.accessToken}`}});if(i)return null;let n=await e.mapProfileToUser?.(o);return{user:{id:o.account_id,name:o.name?.display_name,email:o.email,emailVerified:o.email_verified||!1,image:o.profile_photo_url,...n},data:o}}}};var Rt=e=>{let t="https://www.linkedin.com/oauth/v2/authorization",r="https://www.linkedin.com/oauth/v2/accessToken";return{id:"linkedin",name:"Linkedin",createAuthorizationURL:async({state:o,scopes:i,redirectURI:n})=>{let a=i||["profile","email","openid"];return e.scope&&a.push(...e.scope),await E({id:"linkedin",options:e,authorizationEndpoint:t,scopes:a,state:o,redirectURI:n})},validateAuthorizationCode:async({code:o,redirectURI:i})=>await _({code:o,redirectURI:e.redirectURI||i,options:e,tokenEndpoint:r}),async getUserInfo(o){let{data:i,error:n}=await R("https://api.linkedin.com/v2/userinfo",{method:"GET",headers:{Authorization:`Bearer ${o.accessToken}`}});if(n)return null;let a=await e.mapProfileToUser?.(i);return{user:{id:i.sub,name:i.name,email:i.email,emailVerified:i.email_verified||!1,image:i.picture,...a},data:i}}}};var De=(e="")=>e.split("://").map(t=>t.replace(/\/{2,}/g,"/")).join("://"),Ir=e=>{let t=e||"https://gitlab.com";return{authorizationEndpoint:De(`${t}/oauth/authorize`),tokenEndpoint:De(`${t}/oauth/token`),userinfoEndpoint:De(`${t}/api/v4/user`)}},kt=e=>{let{authorizationEndpoint:t,tokenEndpoint:r,userinfoEndpoint:o}=Ir(e.issuer),i="gitlab";return{id:i,name:"Gitlab",createAuthorizationURL:async({state:a,scopes:d,codeVerifier:s,redirectURI:c})=>{let l=d||["read_user"];return e.scope&&l.push(...e.scope),await E({id:i,options:e,authorizationEndpoint:t,scopes:l,state:a,redirectURI:c,codeVerifier:s})},validateAuthorizationCode:async({code:a,redirectURI:d,codeVerifier:s})=>_({code:a,redirectURI:e.redirectURI||d,options:e,codeVerifier:s,tokenEndpoint:r}),async getUserInfo(a){if(e.getUserInfo)return e.getUserInfo(a);let{data:d,error:s}=await R(o,{headers:{authorization:`Bearer ${a.accessToken}`}});if(s||d.state!=="active"||d.locked)return null;let c=await e.mapProfileToUser?.(d);return{user:{id:d.id.toString(),name:d.name??d.username,email:d.email,image:d.avatar_url,emailVerified:!0,...c},data:d}}}};var _t=e=>({id:"reddit",name:"Reddit",createAuthorizationURL({state:t,scopes:r,redirectURI:o}){let i=r||["identity"];return e.scope&&i.push(...e.scope),E({id:"reddit",options:e,authorizationEndpoint:"https://www.reddit.com/api/v1/authorize",scopes:i,state:t,redirectURI:o,duration:e.duration})},validateAuthorizationCode:async({code:t,redirectURI:r})=>{let o=new URLSearchParams({grant_type:"authorization_code",code:t,redirect_uri:e.redirectURI||r}),i={"content-type":"application/x-www-form-urlencoded",accept:"text/plain","user-agent":"better-auth",Authorization:`Basic ${Buffer.from(`${e.clientId}:${e.clientSecret}`).toString("base64")}`},{data:n,error:a}=await R("https://www.reddit.com/api/v1/access_token",{method:"POST",headers:i,body:o.toString()});if(a)throw a;return Ae(n)},async getUserInfo(t){if(e.getUserInfo)return e.getUserInfo(t);let{data:r,error:o}=await R("https://oauth.reddit.com/api/v1/me",{headers:{Authorization:`Bearer ${t.accessToken}`,"User-Agent":"better-auth"}});if(o)return null;let i=await e.mapProfileToUser?.(r);return{user:{id:r.id,name:r.name,email:r.oauth_client_id,emailVerified:r.has_verified_email,image:r.icon_img?.split("?")[0],...i},data:r}}});var Et=require("zod"),Lr={apple:st,discord:at,facebook:dt,github:ct,microsoft:ft,google:ut,spotify:mt,twitch:yt,twitter:bt,dropbox:At,linkedin:Rt,gitlab:kt,reddit:_t},je=Object.keys(Lr),Ut=Et.z.enum(je,{description:"OAuth2 provider to use"});var D=require("zod");var de=require("better-call");var q=require("better-call");var K=require("zod");function Tt(e){try{return JSON.parse(e)}catch{return null}}var f={USER_NOT_FOUND:"User not found",FAILED_TO_CREATE_USER:"Failed to create user",FAILED_TO_CREATE_SESSION:"Failed to create session",FAILED_TO_UPDATE_USER:"Failed to update user",FAILED_TO_GET_SESSION:"Failed to get session",INVALID_PASSWORD:"Invalid password",INVALID_EMAIL:"Invalid email",INVALID_EMAIL_OR_PASSWORD:"Invalid email or password",SOCIAL_ACCOUNT_ALREADY_LINKED:"Social account already linked",PROVIDER_NOT_FOUND:"Provider not found",INVALID_TOKEN:"invalid token",ID_TOKEN_NOT_SUPPORTED:"id_token not supported",FAILED_TO_GET_USER_INFO:"Failed to get user info",USER_EMAIL_NOT_FOUND:"User email not found",EMAIL_NOT_VERIFIED:"Email not verified",PASSWORD_TOO_SHORT:"Password too short",PASSWORD_TOO_LONG:"Password too long",USER_ALREADY_EXISTS:"User already exists",EMAIL_CAN_NOT_BE_UPDATED:"Email can not be updated",CREDENTIAL_ACCOUNT_NOT_FOUND:"Credential account not found",SESSION_EXPIRED:"Session expired. Re-authenticate to perform this action.",FAILED_TO_UNLINK_LAST_ACCOUNT:"You can't unlink your last account",ACCOUNT_NOT_FOUND:"Account not found"};var vt=require("@better-auth/utils/hmac"),St=require("@better-auth/utils/base64"),Ot=require("@better-auth/utils/binary"),It=()=>w("/get-session",{method:"GET",query:K.z.optional(K.z.object({disableCookieCache:K.z.boolean({description:"Disable cookie cache and fetch session from database"}).or(K.z.string().transform(e=>e==="true")).optional(),disableRefresh:K.z.boolean({description:"Disable session refresh. Useful for checking session status, without updating the session"}).optional()})),requireHeaders:!0,metadata:{openapi:{description:"Get the current session",responses:{200:{description:"Success",content:{"application/json":{schema:{type:"object",properties:{session:{type:"object",properties:{token:{type:"string"},userId:{type:"string"},expiresAt:{type:"string"}}},user:{type:"object",$ref:"#/components/schemas/User"}}}}}}}}}},async e=>{try{let t=await e.getSignedCookie(e.context.authCookies.sessionToken.name,e.context.secret);if(!t)return e.json(null);let r=e.getCookie(e.context.authCookies.sessionData.name),o=r?Tt(Ot.binary.decode(St.base64.decode(r))):null;if(o&&!await(0,vt.createHMAC)("SHA-256","base64urlnopad").verify(e.context.secret,JSON.stringify(o.session),o.signature))return B(e),e.json(null);let i=await e.getSignedCookie(e.context.authCookies.dontRememberToken.name,e.context.secret);if(o?.session&&e.context.options.session?.cookieCache?.enabled&&!e.query?.disableCookieCache){let l=o.session;if(o.expiresAt<Date.now()||l.session.expiresAt<new Date){let p=e.context.authCookies.sessionData.name;e.setCookie(p,"",{maxAge:0})}else return e.json(l)}let n=await e.context.internalAdapter.findSession(t);if(e.context.session=n,!n||n.session.expiresAt<new Date)return B(e),n&&await e.context.internalAdapter.deleteSession(n.session.token),e.json(null);if(i||e.query?.disableRefresh)return e.json(n);let a=e.context.sessionConfig.expiresIn,d=e.context.sessionConfig.updateAge;if(n.session.expiresAt.valueOf()-a*1e3+d*1e3<=Date.now()){let l=await e.context.internalAdapter.updateSession(n.session.token,{expiresAt:J(e.context.sessionConfig.expiresIn,"sec")});if(!l)return B(e),e.json(null,{status:401});let u=(l.expiresAt.valueOf()-Date.now())/1e3;return await L(e,{session:l,user:n.user},!1,{maxAge:u}),e.json({session:l,user:n.user})}return await Ie(e,n),e.json(n)}catch(t){throw e.context.logger.error("INTERNAL_SERVER_ERROR",t),new q.APIError("INTERNAL_SERVER_ERROR",{message:f.FAILED_TO_GET_SESSION})}}),re=async(e,t)=>{if(e.context.session)return e.context.session;let r=await It()({...e,_flag:"json",headers:e.headers,query:t}).catch(o=>null);return e.context.session=r,r},P=ie(async e=>{let t=await re(e);if(!t?.session)throw new q.APIError("UNAUTHORIZED");return{session:t}}),Lt=ie(async e=>{let t=await re(e);if(!t?.session)throw new q.APIError("UNAUTHORIZED");if(e.context.sessionConfig.freshAge===0)return{session:t};let r=e.context.sessionConfig.freshAge,o=t.session.updatedAt?.valueOf()||t.session.createdAt.valueOf();if(!(Date.now()-o<r*1e3))throw new q.APIError("FORBIDDEN",{message:"Session is not fresh"});return{session:t}});var Pr=w("/revoke-session",{method:"POST",body:K.z.object({token:K.z.string({description:"The token to revoke"})}),use:[P],requireHeaders:!0,metadata:{openapi:{description:"Revoke a single session",requestBody:{content:{"application/json":{schema:{type:"object",properties:{token:{type:"string"}},required:["token"]}}}}}}},async e=>{let t=e.body.token,r=await e.context.internalAdapter.findSession(t);if(!r)throw new q.APIError("BAD_REQUEST",{message:"Session not found"});if(r.session.userId!==e.context.session.user.id)throw new q.APIError("UNAUTHORIZED");try{await e.context.internalAdapter.deleteSession(t)}catch(o){throw e.context.logger.error(o&&typeof o=="object"&&"name"in o?o.name:"",o),new q.APIError("INTERNAL_SERVER_ERROR")}return e.json({status:!0})}),xr=w("/revoke-sessions",{method:"POST",use:[P],requireHeaders:!0,metadata:{openapi:{description:"Revoke all sessions for the user",responses:{200:{description:"Success",content:{"application/json":{schema:{type:"object",properties:{status:{type:"boolean"}},required:["status"]}}}}}}}},async e=>{try{await e.context.internalAdapter.deleteSessions(e.context.session.user.id)}catch(t){throw e.context.logger.error(t&&typeof t=="object"&&"name"in t?t.name:"",t),new q.APIError("INTERNAL_SERVER_ERROR")}return e.json({status:!0})}),Cr=w("/revoke-other-sessions",{method:"POST",requireHeaders:!0,use:[P],metadata:{openapi:{description:"Revoke all other sessions for the user except the current one",responses:{200:{description:"Success",content:{"application/json":{schema:{type:"object",properties:{status:{type:"boolean"}}}}}}}}}},async e=>{let t=e.context.session;if(!t.user)throw new q.APIError("UNAUTHORIZED");let i=(await e.context.internalAdapter.listSessions(t.user.id)).filter(n=>n.expiresAt>new Date).filter(n=>n.token!==e.context.session.session.token);return await Promise.all(i.map(n=>e.context.internalAdapter.deleteSession(n.token))),e.json({status:!0})});var Pt=require("jose");var xt=require("jose/errors");async function W(e,t,r,o=3600){return await ot({email:t.toLowerCase(),updateTo:r},e,o)}async function Dr(e,t){if(!e.context.options.emailVerification?.sendVerificationEmail)throw e.context.logger.error("Verification email isn't enabled."),new de.APIError("BAD_REQUEST",{message:"Verification email isn't enabled"});let r=await W(e.context.secret,t.email,void 0,e.context.options.emailVerification?.expiresIn),o=`${e.context.baseURL}/verify-email?token=${r}&callbackURL=${e.body.callbackURL||e.query?.currentURL||"/"}`;await e.context.options.emailVerification.sendVerificationEmail({user:t,url:o,token:r},e.request)}var jr=w("/send-verification-email",{method:"POST",query:D.z.object({currentURL:D.z.string({description:"The URL to use for email verification callback"}).optional()}).optional(),body:D.z.object({email:D.z.string({description:"The email to send the verification email to"}).email(),callbackURL:D.z.string({description:"The URL to use for email verification callback"}).optional()}),metadata:{openapi:{description:"Send a verification email to the user",requestBody:{content:{"application/json":{schema:{type:"object",properties:{email:{type:"string",description:"The email to send the verification email to"},callbackURL:{type:"string",description:"The URL to use for email verification callback"}},required:["email"]}}}},responses:{200:{description:"Success",content:{"application/json":{schema:{type:"object",properties:{status:{type:"boolean"}}}}}}}}}},async e=>{if(!e.context.options.emailVerification?.sendVerificationEmail)throw e.context.logger.error("Verification email isn't enabled."),new de.APIError("BAD_REQUEST",{message:"Verification email isn't enabled"});let{email:t}=e.body,r=await e.context.internalAdapter.findUserByEmail(t);if(!r)throw new de.APIError("BAD_REQUEST",{message:f.USER_NOT_FOUND});return await Dr(e,r.user),e.json({status:!0})}),Nr=w("/verify-email",{method:"GET",query:D.z.object({token:D.z.string({description:"The token to verify the email"}),callbackURL:D.z.string({description:"The URL to redirect to after email verification"}).optional()}),use:[ne(e=>e.query.callbackURL)],metadata:{openapi:{description:"Verify the email of the user",responses:{200:{description:"Success",content:{"application/json":{schema:{type:"object",properties:{user:{type:"object"},status:{type:"boolean"}},required:["user","status"]}}}}}}}},async e=>{function t(d){throw e.query.callbackURL?e.query.callbackURL.includes("?")?e.redirect(`${e.query.callbackURL}&error=${d}`):e.redirect(`${e.query.callbackURL}?error=${d}`):new de.APIError("UNAUTHORIZED",{message:d})}let{token:r}=e.query,o;try{o=await(0,Pt.jwtVerify)(r,new TextEncoder().encode(e.context.secret),{algorithms:["HS256"]})}catch(d){return d instanceof xt.JWTExpired?t("token_expired"):t("invalid_token")}let n=D.z.object({email:D.z.string().email(),updateTo:D.z.string().optional()}).parse(o.payload),a=await e.context.internalAdapter.findUserByEmail(n.email);if(!a)return t("user_not_found");if(n.updateTo){let d=await re(e);if(!d){if(e.query.callbackURL)throw e.redirect(`${e.query.callbackURL}?error=unauthorized`);return t("unauthorized")}if(d.user.email!==n.email){if(e.query.callbackURL)throw e.redirect(`${e.query.callbackURL}?error=unauthorized`);return t("unauthorized")}let s=await e.context.internalAdapter.updateUserByEmail(n.email,{email:n.updateTo,emailVerified:!1}),c=await W(e.context.secret,n.updateTo);if(await e.context.options.emailVerification?.sendVerificationEmail?.({user:s,url:`${e.context.baseURL}/verify-email?token=${c}`,token:c},e.request),e.query.callbackURL)throw e.redirect(e.query.callbackURL);return e.json({status:!0,user:{id:s.id,email:s.email,name:s.name,image:s.image,emailVerified:s.emailVerified,createdAt:s.createdAt,updatedAt:s.updatedAt}})}if(await e.context.internalAdapter.updateUserByEmail(n.email,{emailVerified:!0}),e.context.options.emailVerification?.autoSignInAfterVerification){let d=await re(e);if(!d||d.user.email!==n.email){let s=await e.context.internalAdapter.createSession(a.user.id,e.request);if(!s)throw new de.APIError("INTERNAL_SERVER_ERROR",{message:"Failed to create session"});await L(e,{session:s,user:a.user})}}if(e.query.callbackURL)throw e.redirect(e.query.callbackURL);return e.json({status:!0,user:null})});async function ce(e,{userInfo:t,account:r,callbackURL:o}){let i=await e.context.internalAdapter.findOAuthUser(t.email.toLowerCase(),r.accountId,r.providerId).catch(s=>{throw $.error(`Better auth was unable to query your database.
Error: `,s),e.redirect(`${e.context.baseURL}/error?error=internal_server_error`)}),n=i?.user,a=!n;if(i){let s=i.accounts.find(c=>c.providerId===r.providerId);if(s){let c=Object.fromEntries(Object.entries({accessToken:r.accessToken,idToken:r.idToken,refreshToken:r.refreshToken,accessTokenExpiresAt:r.accessTokenExpiresAt,refreshTokenExpiresAt:r.refreshTokenExpiresAt}).filter(([l,u])=>u!==void 0));Object.keys(c).length>0&&await e.context.internalAdapter.updateAccount(s.id,c)}else{if(!e.context.options.account?.accountLinking?.trustedProviders?.includes(r.providerId)&&!t.emailVerified||e.context.options.account?.accountLinking?.enabled===!1)return ve&&$.warn(`User already exist but account isn't linked to ${r.providerId}. To read more about how account linking works in Better Auth see https://www.better-auth.com/docs/concepts/users-accounts#account-linking.`),{error:"account not linked",data:null};try{await e.context.internalAdapter.linkAccount({providerId:r.providerId,accountId:t.id.toString(),userId:i.user.id,accessToken:r.accessToken,idToken:r.idToken,refreshToken:r.refreshToken,accessTokenExpiresAt:r.accessTokenExpiresAt,refreshTokenExpiresAt:r.refreshTokenExpiresAt,scope:r.scope})}catch(u){return $.error("Unable to link account",u),{error:"unable to link account",data:null}}}}else try{if(n=await e.context.internalAdapter.createOAuthUser({...t,email:t.email.toLowerCase(),id:void 0},{accessToken:r.accessToken,idToken:r.idToken,refreshToken:r.refreshToken,accessTokenExpiresAt:r.accessTokenExpiresAt,refreshTokenExpiresAt:r.refreshTokenExpiresAt,scope:r.scope,providerId:r.providerId,accountId:t.id.toString()}).then(s=>s?.user),!t.emailVerified&&n&&e.context.options.emailVerification?.sendOnSignUp){let s=await W(e.context.secret,n.email,void 0,e.context.options.emailVerification?.expiresIn),c=`${e.context.baseURL}/verify-email?token=${s}&callbackURL=${o}`;await e.context.options.emailVerification?.sendVerificationEmail?.({user:n,url:c,token:s},e.request)}}catch(s){return s instanceof oe.APIError?{error:s.message,data:null,isRegister:!1}:{error:"unable to create user",data:null,isRegister:!1}}if(!n)return{error:"unable to create user",data:null,isRegister:!1};let d=await e.context.internalAdapter.createSession(n.id,e.request);return d?{data:{session:d,user:n},error:null,isRegister:a}:{error:"unable to create session",data:null,isRegister:!1}}var $r=w("/sign-in/social",{method:"POST",query:T.z.object({currentURL:T.z.string().optional()}).optional(),body:T.z.object({callbackURL:T.z.string({description:"Callback URL to redirect to after the user has signed in"}).optional(),newUserCallbackURL:T.z.string().optional(),errorCallbackURL:T.z.string({description:"Callback URL to redirect to if an error happens"}).optional(),provider:Ut,disableRedirect:T.z.boolean({description:"Disable automatic redirection to the provider. Useful for handling the redirection yourself"}).optional(),idToken:T.z.optional(T.z.object({token:T.z.string({description:"ID token from the provider"}),nonce:T.z.string({description:"Nonce used to generate the token"}).optional(),accessToken:T.z.string({description:"Access token from the provider"}).optional(),refreshToken:T.z.string({description:"Refresh token from the provider"}).optional(),expiresAt:T.z.number({description:"Expiry date of the token"}).optional()}),{description:"ID token from the provider to sign in the user with id token"})}),metadata:{openapi:{description:"Sign in with a social provider",responses:{200:{description:"Success",content:{"application/json":{schema:{type:"object",properties:{session:{type:"string"},user:{type:"object"},url:{type:"string"},redirect:{type:"boolean"}},required:["session","user","url","redirect"]}}}}}}}},async e=>{let t=e.context.socialProviders.find(n=>n.id===e.body.provider);if(!t)throw e.context.logger.error("Provider not found. Make sure to add the provider in your auth config",{provider:e.body.provider}),new O.APIError("NOT_FOUND",{message:f.PROVIDER_NOT_FOUND});if(e.body.idToken){if(!t.verifyIdToken)throw e.context.logger.error("Provider does not support id token verification",{provider:e.body.provider}),new O.APIError("NOT_FOUND",{message:f.ID_TOKEN_NOT_SUPPORTED});let{token:n,nonce:a}=e.body.idToken;if(!await t.verifyIdToken(n,a))throw e.context.logger.error("Invalid id token",{provider:e.body.provider}),new O.APIError("UNAUTHORIZED",{message:f.INVALID_TOKEN});let s=await t.getUserInfo({idToken:n,accessToken:e.body.idToken.accessToken,refreshToken:e.body.idToken.refreshToken});if(!s||!s?.user)throw e.context.logger.error("Failed to get user info",{provider:e.body.provider}),new O.APIError("UNAUTHORIZED",{message:f.FAILED_TO_GET_USER_INFO});if(!s.user.email)throw e.context.logger.error("User email not found",{provider:e.body.provider}),new O.APIError("UNAUTHORIZED",{message:f.USER_EMAIL_NOT_FOUND});let c=await ce(e,{userInfo:{email:s.user.email,id:s.user.id,name:s.user.name||"",image:s.user.image,emailVerified:s.user.emailVerified||!1},account:{providerId:t.id,accountId:s.user.id,accessToken:e.body.idToken.accessToken}});if(c.error)throw new O.APIError("UNAUTHORIZED",{message:c.error});return await L(e,c.data),e.json({redirect:!1,token:c.data.session.token,url:void 0,user:{id:c.data.user.id,email:c.data.user.email,name:c.data.user.name,image:c.data.user.image,emailVerified:c.data.user.emailVerified,createdAt:c.data.user.createdAt,updatedAt:c.data.user.updatedAt}})}let{codeVerifier:r,state:o}=await se(e),i=await t.createAuthorizationURL({state:o,codeVerifier:r,redirectURI:`${e.context.baseURL}/callback/${t.id}`});return e.json({url:i.toString(),redirect:!e.body.disableRedirect})}),Vr=w("/sign-in/email",{method:"POST",body:T.z.object({email:T.z.string({description:"Email of the user"}),password:T.z.string({description:"Password of the user"}),callbackURL:T.z.string({description:"Callback URL to use as a redirect for email verification"}).optional(),rememberMe:T.z.boolean({description:"If this is false, the session will not be remembered. Default is `true`."}).default(!0).optional()}),metadata:{openapi:{description:"Sign in with email and password",responses:{200:{description:"Success",content:{"application/json":{schema:{type:"object",properties:{user:{type:"object"},url:{type:"string"},redirect:{type:"boolean"}},required:["session","user","url","redirect"]}}}}}}}},async e=>{if(!e.context.options?.emailAndPassword?.enabled)throw e.context.logger.error("Email and password is not enabled. Make sure to enable it in the options on you `auth.ts` file. Check `https://better-auth.com/docs/authentication/email-password` for more!"),new O.APIError("BAD_REQUEST",{message:"Email and password is not enabled"});let{email:t,password:r}=e.body;if(!T.z.string().email().safeParse(t).success)throw new O.APIError("BAD_REQUEST",{message:f.INVALID_EMAIL});let i=await e.context.internalAdapter.findUserByEmail(t,{includeAccounts:!0});if(!i)throw await e.context.password.hash(r),e.context.logger.error("User not found",{email:t}),new O.APIError("UNAUTHORIZED",{message:f.INVALID_EMAIL_OR_PASSWORD});let n=i.accounts.find(c=>c.providerId==="credential");if(!n)throw e.context.logger.error("Credential account not found",{email:t}),new O.APIError("UNAUTHORIZED",{message:f.INVALID_EMAIL_OR_PASSWORD});let a=n?.password;if(!a)throw e.context.logger.error("Password not found",{email:t}),new O.APIError("UNAUTHORIZED",{message:f.INVALID_EMAIL_OR_PASSWORD});if(!await e.context.password.verify({hash:a,password:r}))throw e.context.logger.error("Invalid password"),new O.APIError("UNAUTHORIZED",{message:f.INVALID_EMAIL_OR_PASSWORD});if(e.context.options?.emailAndPassword?.requireEmailVerification&&!i.user.emailVerified){if(!e.context.options?.emailVerification?.sendVerificationEmail)throw new O.APIError("UNAUTHORIZED",{message:f.EMAIL_NOT_VERIFIED});let c=await W(e.context.secret,i.user.email,void 0,e.context.options.emailVerification?.expiresIn),l=`${e.context.baseURL}/verify-email?token=${c}&callbackURL=${e.body.callbackURL||"/"}`;throw await e.context.options.emailVerification.sendVerificationEmail({user:i.user,url:l,token:c},e.request),new O.APIError("FORBIDDEN",{message:f.EMAIL_NOT_VERIFIED})}let s=await e.context.internalAdapter.createSession(i.user.id,e.headers,e.body.rememberMe===!1);if(!s)throw e.context.logger.error("Failed to create session"),new O.APIError("UNAUTHORIZED",{message:f.FAILED_TO_CREATE_SESSION});return await L(e,{session:s,user:i.user},e.body.rememberMe===!1),e.json({redirect:!!e.body.callbackURL,token:s.token,url:e.body.callbackURL,user:{id:i.user.id,email:i.user.email,name:i.user.name,image:i.user.image,emailVerified:i.user.emailVerified,createdAt:i.user.createdAt,updatedAt:i.user.updatedAt}})});var le=require("zod");var ke=le.z.object({code:le.z.string().optional(),error:le.z.string().optional(),error_description:le.z.string().optional(),state:le.z.string().optional()}),Br=w("/callback/:id",{method:["GET","POST"],body:ke.optional(),query:ke.optional(),metadata:ae},async e=>{let t;try{if(e.method==="GET")t=ke.parse(e.query);else if(e.method==="POST")t=ke.parse(e.body);else throw new Error("Unsupported method")}catch(A){throw e.context.logger.error("INVALID_CALLBACK_REQUEST",A),e.redirect(`${e.context.baseURL}/error?error=invalid_callback_request`)}let{code:r,error:o,state:i,error_description:n}=t;if(!i)throw e.context.logger.error("State not found",o),e.redirect(`${e.context.baseURL}/error?error=state_not_found`);if(!r)throw e.context.logger.error("Code not found"),e.redirect(`${e.context.baseURL}/error?error=${o||"no_code"}&error_description=${n}`);let a=e.context.socialProviders.find(A=>A.id===e.params.id);if(!a)throw e.context.logger.error("Oauth provider with id",e.params.id,"not found"),e.redirect(`${e.context.baseURL}/error?error=oauth_provider_not_found`);let{codeVerifier:d,callbackURL:s,link:c,errorURL:l,newUserURL:u}=await Re(e),p;try{p=await a.validateAuthorizationCode({code:r,codeVerifier:d,redirectURI:`${e.context.baseURL}/callback/${a.id}`})}catch(A){throw e.context.logger.error("",A),e.redirect(`${e.context.baseURL}/error?error=please_restart_the_process`)}let g=await a.getUserInfo(p).then(A=>A?.user);function m(A){let b=l||s||`${e.context.baseURL}/error`;throw b.includes("?")?b=`${b}&error=${A}`:b=`${b}?error=${A}`,e.redirect(b)}if(!g)return e.context.logger.error("Unable to get user info"),m("unable_to_get_user_info");if(!g.email)return e.context.logger.error("Provider did not return email. This could be due to misconfiguration in the provider settings."),m("email_not_found");if(!s)throw e.context.logger.error("No callback URL found"),e.redirect(`${e.context.baseURL}/error?error=please_restart_the_process`);if(c){if(c.email!==g.email.toLowerCase())return m("email_doesn't_match");if(!await e.context.internalAdapter.createAccount({userId:c.userId,providerId:a.id,accountId:g.id}))return m("unable_to_link_account");let b;try{b=s.toString()}catch{b=s}throw e.redirect(b)}let U=await ce(e,{userInfo:{...g,email:g.email,name:g.name||g.email},account:{providerId:a.id,accountId:g.id,...p,scope:p.scopes?.join(",")},callbackURL:s});if(U.error)return e.context.logger.error(U.error.split(" ").join("_")),m(U.error.split(" ").join("_"));let{session:V,user:j}=U.data;await L(e,{session:V,user:j});let F;try{F=(U.isRegister&&u||s).toString()}catch{F=U.isRegister&&u||s}throw e.redirect(F)});var Ct=require("better-call");var zr=w("/sign-out",{method:"POST",requireHeaders:!0,metadata:{openapi:{description:"Sign out the current user",responses:{200:{description:"Success",content:{"application/json":{schema:{type:"object",properties:{success:{type:"boolean"}}}}}}}}}},async e=>{let t=await e.getSignedCookie(e.context.authCookies.sessionToken.name,e.context.secret);if(!t)throw B(e),new Ct.APIError("BAD_REQUEST",{message:f.FAILED_TO_GET_SESSION});return await e.context.internalAdapter.deleteSession(t),B(e),e.json({success:!0})});var x=require("zod");var ue=require("better-call");function Dt(e,t,r){let o=t?new URL(t,e.baseURL):new URL(`${e.baseURL}/error`);return r&&Object.entries(r).forEach(([i,n])=>o.searchParams.set(i,n)),o.href}function Mr(e,t,r){let o=new URL(t,e.baseURL);return r&&Object.entries(r).forEach(([i,n])=>o.searchParams.set(i,n)),o.href}var qr=w("/forget-password",{method:"POST",body:x.z.object({email:x.z.string({description:"The email address of the user to send a password reset email to"}).email(),redirectTo:x.z.string({description:"The URL to redirect the user to reset their password. If the token isn't valid or expired, it'll be redirected with a query parameter `?error=INVALID_TOKEN`. If the token is valid, it'll be redirected with a query parameter `?token=VALID_TOKEN"}).optional()}),metadata:{openapi:{description:"Send a password reset email to the user",responses:{200:{description:"Success",content:{"application/json":{schema:{type:"object",properties:{status:{type:"boolean"}}}}}}}}}},async e=>{if(!e.context.options.emailAndPassword?.sendResetPassword)throw e.context.logger.error("Reset password isn't enabled.Please pass an emailAndPassword.sendResetPasswordToken function in your auth config!"),new ue.APIError("BAD_REQUEST",{message:"Reset password isn't enabled"});let{email:t,redirectTo:r}=e.body,o=await e.context.internalAdapter.findUserByEmail(t,{includeAccounts:!0});if(!o)return e.context.logger.error("Reset Password: User not found",{email:t}),e.json({status:!1},{body:{status:!0}});let i=60*60*1,n=J(e.context.options.emailAndPassword.resetPasswordTokenExpiresIn||i,"sec"),a=ht(24);await e.context.internalAdapter.createVerificationValue({value:o.user.id.toString(),identifier:`reset-password:${a}`,expiresAt:n});let d=`${e.context.baseURL}/reset-password/${a}?callbackURL=${r}`;return await e.context.options.emailAndPassword.sendResetPassword({user:o.user,url:d,token:a},e.request),e.json({status:!0})}),Fr=w("/reset-password/:token",{method:"GET",query:x.z.object({callbackURL:x.z.string({description:"The URL to redirect the user to reset their password"})}),use:[ne(e=>e.query.callbackURL)],metadata:{openapi:{description:"Redirects the user to the callback URL with the token",responses:{200:{description:"Success",content:{"application/json":{schema:{type:"object",properties:{token:{type:"string"}}}}}}}}}},async e=>{let{token:t}=e.params,{callbackURL:r}=e.query;if(!t||!r)throw e.redirect(Dt(e.context,r,{error:"INVALID_TOKEN"}));let o=await e.context.internalAdapter.findVerificationValue(`reset-password:${t}`);throw!o||o.expiresAt<new Date?e.redirect(Dt(e.context,r,{error:"INVALID_TOKEN"})):e.redirect(Mr(e.context,r,{token:t}))}),Hr=w("/reset-password",{query:x.z.optional(x.z.object({token:x.z.string().optional(),currentURL:x.z.string().optional()})),method:"POST",body:x.z.object({newPassword:x.z.string({description:"The new password to set"}),token:x.z.string({description:"The token to reset the password"}).optional()}),metadata:{openapi:{description:"Reset the password for a user",responses:{200:{description:"Success",content:{"application/json":{schema:{type:"object",properties:{status:{type:"boolean"}}}}}}}}}},async e=>{let t=e.body.token||e.query?.token||(e.query?.currentURL?new URL(e.query.currentURL).searchParams.get("token"):"");if(!t)throw new ue.APIError("BAD_REQUEST",{message:f.INVALID_TOKEN});let{newPassword:r}=e.body,o=e.context.password?.config.minPasswordLength,i=e.context.password?.config.maxPasswordLength;if(r.length<o)throw new ue.APIError("BAD_REQUEST",{message:f.PASSWORD_TOO_SHORT});if(r.length>i)throw new ue.APIError("BAD_REQUEST",{message:f.PASSWORD_TOO_LONG});let n=`reset-password:${t}`,a=await e.context.internalAdapter.findVerificationValue(n);if(!a||a.expiresAt<new Date)throw new ue.APIError("BAD_REQUEST",{message:f.INVALID_TOKEN});await e.context.internalAdapter.deleteVerificationValue(a.id);let d=a.value,s=await e.context.password.hash(r);return(await e.context.internalAdapter.findAccounts(d)).find(u=>u.providerId==="credential")?(await e.context.internalAdapter.updatePassword(d,s),e.json({status:!0})):(await e.context.internalAdapter.createAccount({userId:d,providerId:"credential",password:s,accountId:d}),e.json({status:!0}))});var S=require("zod");var v=require("better-call");var h=require("zod"),Gr=require("better-call"),Ls=h.z.object({id:h.z.string(),providerId:h.z.string(),accountId:h.z.string(),userId:h.z.string(),accessToken:h.z.string().nullish(),refreshToken:h.z.string().nullish(),idToken:h.z.string().nullish(),accessTokenExpiresAt:h.z.date().nullish(),refreshTokenExpiresAt:h.z.date().nullish(),scope:h.z.string().nullish(),password:h.z.string().nullish(),createdAt:h.z.date().default(()=>new Date),updatedAt:h.z.date().default(()=>new Date)}),Ps=h.z.object({id:h.z.string(),email:h.z.string().transform(e=>e.toLowerCase()),emailVerified:h.z.boolean().default(!1),name:h.z.string(),image:h.z.string().nullish(),createdAt:h.z.date().default(()=>new Date),updatedAt:h.z.date().default(()=>new Date)}),xs=h.z.object({id:h.z.string(),userId:h.z.string(),expiresAt:h.z.date(),createdAt:h.z.date().default(()=>new Date),updatedAt:h.z.date().default(()=>new Date),token:h.z.string(),ipAddress:h.z.string().nullish(),userAgent:h.z.string().nullish()}),Cs=h.z.object({id:h.z.string(),value:h.z.string(),createdAt:h.z.date().default(()=>new Date),updatedAt:h.z.date().default(()=>new Date),expiresAt:h.z.date(),identifier:h.z.string()});var Qr=w("/change-password",{method:"POST",body:S.z.object({newPassword:S.z.string({description:"The new password to set"}),currentPassword:S.z.string({description:"The current password"}),revokeOtherSessions:S.z.boolean({description:"Revoke all other sessions"}).optional()}),use:[P],metadata:{openapi:{description:"Change the password of the user",responses:{200:{description:"Success",content:{"application/json":{schema:{type:"object",properties:{user:{description:"The user object",$ref:"#/components/schemas/User"}}}}}}}}}},async e=>{let{newPassword:t,currentPassword:r,revokeOtherSessions:o}=e.body,i=e.context.session,n=e.context.password.config.minPasswordLength;if(t.length<n)throw e.context.logger.error("Password is too short"),new v.APIError("BAD_REQUEST",{message:f.PASSWORD_TOO_SHORT});let a=e.context.password.config.maxPasswordLength;if(t.length>a)throw e.context.logger.error("Password is too long"),new v.APIError("BAD_REQUEST",{message:f.PASSWORD_TOO_LONG});let s=(await e.context.internalAdapter.findAccounts(i.user.id)).find(p=>p.providerId==="credential"&&p.password);if(!s||!s.password)throw new v.APIError("BAD_REQUEST",{message:f.CREDENTIAL_ACCOUNT_NOT_FOUND});let c=await e.context.password.hash(t);if(!await e.context.password.verify({hash:s.password,password:r}))throw new v.APIError("BAD_REQUEST",{message:f.INVALID_PASSWORD});await e.context.internalAdapter.updateAccount(s.id,{password:c});let u=null;if(o){await e.context.internalAdapter.deleteSessions(i.user.id);let p=await e.context.internalAdapter.createSession(i.user.id,e.headers);if(!p)throw new v.APIError("INTERNAL_SERVER_ERROR",{message:f.FAILED_TO_GET_SESSION});await L(e,{session:p,user:i.user}),u=p.token}return e.json({token:u,user:{id:i.user.id,email:i.user.email,name:i.user.name,image:i.user.image,emailVerified:i.user.emailVerified,createdAt:i.user.createdAt,updatedAt:i.user.updatedAt}})}),Jr=w("/set-password",{method:"POST",body:S.z.object({newPassword:S.z.string()}),metadata:{SERVER_ONLY:!0},use:[P]},async e=>{let{newPassword:t}=e.body,r=e.context.session,o=e.context.password.config.minPasswordLength;if(t.length<o)throw e.context.logger.error("Password is too short"),new v.APIError("BAD_REQUEST",{message:f.PASSWORD_TOO_SHORT});let i=e.context.password.config.maxPasswordLength;if(t.length>i)throw e.context.logger.error("Password is too long"),new v.APIError("BAD_REQUEST",{message:f.PASSWORD_TOO_LONG});let a=(await e.context.internalAdapter.findAccounts(r.user.id)).find(s=>s.providerId==="credential"&&s.password),d=await e.context.password.hash(t);if(!a)return await e.context.internalAdapter.linkAccount({userId:r.user.id,providerId:"credential",accountId:r.user.id,password:d}),e.json({status:!0});throw new v.APIError("BAD_REQUEST",{message:"user already has a password"})}),Zr=w("/delete-user",{method:"POST",use:[P],body:S.z.object({callbackURL:S.z.string().optional(),password:S.z.string().optional(),token:S.z.string().optional()}),metadata:{openapi:{description:"Delete the user",responses:{200:{description:"Success",content:{"application/json":{schema:{type:"object"}}}}}}}},async e=>{if(!e.context.options.user?.deleteUser?.enabled)throw e.context.logger.error("Delete user is disabled. Enable it in the options",{session:e.context.session}),new v.APIError("NOT_FOUND");let t=e.context.session;if(e.body.password){let n=(await e.context.internalAdapter.findAccounts(t.user.id)).find(d=>d.providerId==="credential"&&d.password);if(!n||!n.password)throw new v.APIError("BAD_REQUEST",{message:f.CREDENTIAL_ACCOUNT_NOT_FOUND});if(!await e.context.password.verify({hash:n.password,password:e.body.password}))throw new v.APIError("BAD_REQUEST",{message:f.INVALID_PASSWORD})}else if(e.context.options.session?.freshAge){let i=t.session.createdAt.getTime(),n=e.context.options.session.freshAge;if(Date.now()-i>n)throw new v.APIError("BAD_REQUEST",{message:f.SESSION_EXPIRED})}if(e.body.token)return await jt({...e,query:{token:e.body.token}}),e.json({success:!0,message:"User deleted"});if(e.context.options.user.deleteUser?.sendDeleteAccountVerification){let i=me(32,"0-9","a-z");await e.context.internalAdapter.createVerificationValue({value:t.user.id,identifier:`delete-account-${i}`,expiresAt:new Date(Date.now()+1e3*60*60*24)});let n=`${e.context.baseURL}/delete-user/callback?token=${i}&callbackURL=${e.body.callbackURL||"/"}`;return await e.context.options.user.deleteUser.sendDeleteAccountVerification({user:t.user,url:n,token:i},e.request),e.json({success:!0,message:"Verification email sent"})}let r=e.context.options.user.deleteUser?.beforeDelete;r&&await r(t.user,e.request),await e.context.internalAdapter.deleteUser(t.user.id),await e.context.internalAdapter.deleteSessions(t.user.id),await e.context.internalAdapter.deleteAccounts(t.user.id),B(e);let o=e.context.options.user.deleteUser?.afterDelete;return o&&await o(t.user,e.request),e.json({success:!0,message:"User deleted"})}),jt=w("/delete-user/callback",{method:"GET",query:S.z.object({token:S.z.string(),callbackURL:S.z.string().optional()}),use:[ne(e=>e.query.callbackURL)]},async e=>{if(!e.context.options.user?.deleteUser?.enabled)throw e.context.logger.error("Delete user is disabled. Enable it in the options"),new v.APIError("NOT_FOUND");let t=await re(e);if(!t)throw new v.APIError("NOT_FOUND",{message:f.FAILED_TO_GET_USER_INFO});let r=await e.context.internalAdapter.findVerificationValue(`delete-account-${e.query.token}`);if(!r||r.expiresAt<new Date)throw r&&await e.context.internalAdapter.deleteVerificationValue(r.id),new v.APIError("NOT_FOUND",{message:f.INVALID_TOKEN});if(r.value!==t.user.id)throw new v.APIError("NOT_FOUND",{message:f.INVALID_TOKEN});let o=e.context.options.user.deleteUser?.beforeDelete;o&&await o(t.user,e.request),await e.context.internalAdapter.deleteUser(t.user.id),await e.context.internalAdapter.deleteSessions(t.user.id),await e.context.internalAdapter.deleteAccounts(t.user.id),await e.context.internalAdapter.deleteVerificationValue(r.id),B(e);let i=e.context.options.user.deleteUser?.afterDelete;if(i&&await i(t.user,e.request),e.query.callbackURL)throw e.redirect(e.query.callbackURL||"/");return e.json({success:!0,message:"User deleted"})}),Kr=w("/change-email",{method:"POST",query:S.z.object({currentURL:S.z.string().optional()}).optional(),body:S.z.object({newEmail:S.z.string({description:"The new email to set"}).email(),callbackURL:S.z.string({description:"The URL to redirect to after email verification"}).optional()}),use:[P],metadata:{openapi:{responses:{200:{description:"Success",content:{"application/json":{schema:{type:"object",properties:{user:{type:"object"},status:{type:"boolean"}}}}}}}}}},async e=>{if(!e.context.options.user?.changeEmail?.enabled)throw e.context.logger.error("Change email is disabled."),new v.APIError("BAD_REQUEST",{message:"Change email is disabled"});if(e.body.newEmail===e.context.session.user.email)throw e.context.logger.error("Email is the same"),new v.APIError("BAD_REQUEST",{message:"Email is the same"});if(await e.context.internalAdapter.findUserByEmail(e.body.newEmail))throw e.context.logger.error("Email already exists"),new v.APIError("BAD_REQUEST",{message:"Couldn't update your email"});if(e.context.session.user.emailVerified!==!0){let i=await e.context.internalAdapter.updateUserByEmail(e.context.session.user.email,{email:e.body.newEmail});return e.json({status:!0})}if(!e.context.options.user.changeEmail.sendChangeEmailVerification)throw e.context.logger.error("Verification email isn't enabled."),new v.APIError("BAD_REQUEST",{message:"Verification email isn't enabled"});let r=await W(e.context.secret,e.context.session.user.email,e.body.newEmail,e.context.options.emailVerification?.expiresIn),o=`${e.context.baseURL}/verify-email?token=${r}&callbackURL=${e.body.callbackURL||e.query?.currentURL||"/"}`;return await e.context.options.user.changeEmail.sendChangeEmailVerification({user:e.context.session.user,newEmail:e.body.newEmail,url:o,token:r},e.request),e.json({status:!0})});var Yr=(e="Unknown")=>`<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Authentication Error</title>
    <style>
        :root {
            --bg-color: #f8f9fa;
            --text-color: #212529;
            --accent-color: #000000;
            --error-color: #dc3545;
            --border-color: #e9ecef;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            line-height: 1.5;
        }
        .error-container {
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            padding: 2.5rem;
            text-align: center;
            max-width: 90%;
            width: 400px;
        }
        h1 {
            color: var(--error-color);
            font-size: 1.75rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }
        p {
            margin-bottom: 1.5rem;
            color: #495057;
        }
        .btn {
            background-color: var(--accent-color);
            color: #ffffff;
            text-decoration: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            transition: all 0.3s ease;
            display: inline-block;
            font-weight: 500;
            border: 2px solid var(--accent-color);
        }
        .btn:hover {
            background-color: #131721;
        }
        .error-code {
            font-size: 0.875rem;
            color: #6c757d;
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
        }
        .icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>
    <div class="error-container">
        <div class="icon">\u26A0\uFE0F</div>
        <h1>Better Auth Error</h1>
        <p>We encountered an issue while processing your request. Please try again or contact the application owner if the problem persists.</p>
        <a href="/" id="returnLink" class="btn">Return to Application</a>
        <div class="error-code">Error Code: <span id="errorCode">${e}</span></div>
    </div>
</body>
</html>`,Xr=w("/error",{method:"GET",metadata:{...ae,openapi:{description:"Displays an error page",responses:{200:{description:"Success",content:{"text/html":{schema:{type:"string"}}}}}}}},async e=>{let t=new URL(e.request?.url||"").searchParams.get("error")||"Unknown";return new Response(Yr(t),{headers:{"Content-Type":"text/html"}})});var eo=w("/ok",{method:"GET",metadata:{...ae,openapi:{description:"Check if the API is working",responses:{200:{description:"Success",content:{"application/json":{schema:{type:"object",properties:{ok:{type:"boolean"}}}}}}}}}},async e=>e.json({ok:!0}));var to=require("zod");var ro=require("better-call");var Y=require("zod");var ge=require("better-call");var oo=w("/list-accounts",{method:"GET",use:[P],metadata:{openapi:{description:"List all accounts linked to the user",responses:{200:{description:"Success",content:{"application/json":{schema:{type:"array",items:{type:"object",properties:{id:{type:"string"},provider:{type:"string"}}}}}}}}}}},async e=>{let t=e.context.session,r=await e.context.internalAdapter.findAccounts(t.user.id);return e.json(r.map(o=>({id:o.id,provider:o.providerId,createdAt:o.createdAt,updatedAt:o.updatedAt,accountId:o.accountId,scopes:o.scope?.split(",")||[]})))}),io=w("/link-social",{method:"POST",requireHeaders:!0,query:Y.z.object({currentURL:Y.z.string().optional()}).optional(),body:Y.z.object({callbackURL:Y.z.string({description:"The URL to redirect to after the user has signed in"}).optional(),provider:Y.z.enum(je,{description:"The OAuth2 provider to use"})}),use:[P],metadata:{openapi:{description:"Link a social account to the user",responses:{200:{description:"Success",content:{"application/json":{schema:{type:"object",properties:{url:{type:"string"},redirect:{type:"boolean"}},required:["url","redirect"]}}}}}}}},async e=>{let t=e.context.session;if((await e.context.internalAdapter.findAccounts(t.user.id)).find(d=>d.providerId===e.body.provider))throw new ge.APIError("BAD_REQUEST",{message:f.SOCIAL_ACCOUNT_ALREADY_LINKED});let i=e.context.socialProviders.find(d=>d.id===e.body.provider);if(!i)throw e.context.logger.error("Provider not found. Make sure to add the provider in your auth config",{provider:e.body.provider}),new ge.APIError("NOT_FOUND",{message:f.PROVIDER_NOT_FOUND});let n=await se(e,{userId:t.user.id,email:t.user.email}),a=await i.createAuthorizationURL({state:n.state,codeVerifier:n.codeVerifier,redirectURI:`${e.context.baseURL}/callback/${i.id}`});return e.json({url:a.toString(),redirect:!0})}),no=w("/unlink-account",{method:"POST",body:Y.z.object({providerId:Y.z.string()}),use:[Lt]},async e=>{let t=await e.context.internalAdapter.findAccounts(e.context.session.user.id);if(t.length===1)throw new ge.APIError("BAD_REQUEST",{message:f.FAILED_TO_UNLINK_LAST_ACCOUNT});if(!t.find(o=>o.providerId===e.body.providerId))throw new ge.APIError("BAD_REQUEST",{message:f.ACCOUNT_NOT_FOUND});return await e.context.internalAdapter.deleteAccount(e.body.providerId,e.context.session.user.id),e.json({status:!0})});var oe=require("better-call");var Nt=require("jose");var so=e=>({id:"sso",endpoints:{createOIDCProvider:w("/sso/register",{method:"POST",body:y.z.object({providerId:y.z.string({description:"The ID of the provider. This is used to identify the provider during login and callback"}),issuer:y.z.string({description:"The issuer url of the provider (e.g. https://idp.example.com)"}),domain:y.z.string({description:"The domain of the provider. This is used for email matching"}),clientId:y.z.string({description:"The client ID"}),clientSecret:y.z.string({description:"The client secret"}),authorizationEndpoint:y.z.string({description:"The authorization endpoint"}).optional(),tokenEndpoint:y.z.string({description:"The token endpoint"}).optional(),userInfoEndpoint:y.z.string({description:"The user info endpoint"}).optional(),tokenEndpointAuthentication:y.z.enum(["client_secret_post","client_secret_basic"]).optional(),jwksEndpoint:y.z.string({description:"The JWKS endpoint"}).optional(),discoveryEndpoint:y.z.string().optional(),scopes:y.z.array(y.z.string(),{description:"The scopes to request. Defaults to ['openid', 'email', 'profile', 'offline_access']"}).optional(),pkce:y.z.boolean({description:"Whether to use PKCE for the authorization flow"}).default(!0).optional(),mapping:y.z.object({id:y.z.string({description:"The field in the user info response that contains the id. Defaults to 'sub'"}),email:y.z.string({description:"The field in the user info response that contains the email. Defaults to 'email'"}),emailVerified:y.z.string({description:"The field in the user info response that contains whether the email is verified. defaults to 'email_verified'"}).optional(),name:y.z.string({description:"The field in the user info response that contains the name. Defaults to 'name'"}),image:y.z.string({description:"The field in the user info response that contains the image. Defaults to 'picture'"}).optional(),extraFields:y.z.record(y.z.string()).optional()}).optional(),organizationId:y.z.string({description:"If organization plugin is enabled, the organization id to link the provider to"}).optional()}),use:[P],metadata:{openapi:{summary:"Register an OIDC provider",description:"This endpoint is used to register an OIDC provider. This is used to configure the provider and link it to an organization",responses:{200:{description:"The created provider"}}}}},async t=>{let r=t.body;if(y.z.string().url().safeParse(r.issuer).error)throw new oe.APIError("BAD_REQUEST",{message:"Invalid issuer. Must be a valid URL"});let i=await t.context.adapter.create({model:"ssoProvider",data:{issuer:r.issuer,domain:r.domain,oidcConfig:JSON.stringify({issuer:r.issuer,clientId:r.clientId,clientSecret:r.clientSecret,authorizationEndpoint:r.authorizationEndpoint,tokenEndpoint:r.tokenEndpoint,tokenEndpointAuthentication:r.tokenEndpointAuthentication,jwksEndpoint:r.jwksEndpoint,pkce:r.pkce,discoveryEndpoint:r.discoveryEndpoint||`${r.issuer}/.well-known/openid-configuration`,mapping:r.mapping,scopes:r.scopes,userinfoEndpoint:r.userInfoEndpoint}),organizationId:r.organizationId,userId:t.context.session.user.id,providerId:r.providerId}});return t.json({...i,oidcConfig:JSON.parse(i.oidcConfig),redirectURI:`${t.context.baseURL}/sso/callback/${i.providerId}`})}),signInSSO:w("/sign-in/sso",{method:"POST",body:y.z.object({email:y.z.string({description:"The email address to sign in with. This is used to identify the issuer to sign in with. It's optional if the issuer is provided"}).optional(),organizationSlug:y.z.string({description:"The slug of the organization to sign in with"}).optional(),domain:y.z.string({description:"The domain of the provider."}).optional(),callbackURL:y.z.string({description:"The URL to redirect to after login"}),errorCallbackURL:y.z.string({description:"The URL to redirect to after login"}).optional(),newUserCallbackURL:y.z.string({description:"The URL to redirect to after login if the user is new"}).optional()}),metadata:{openapi:{summary:"Sign in with SSO provider",description:"This endpoint is used to sign in with an SSO provider. It redirects to the provider's authorization URL",requestBody:{content:{"application/json":{schema:{type:"object",properties:{email:{type:"string",description:"The email address to sign in with. This is used to identify the issuer to sign in with. It's optional if the issuer is provided"},issuer:{type:"string",description:"The issuer identifier, this is the URL of the provider and can be used to verify the provider and identify the provider during login. It's optional if the email is provided"},providerId:{type:"string",description:"The ID of the provider to sign in with. This can be provided instead of email or issuer"},callbackURL:{type:"string",description:"The URL to redirect to after login"},errorCallbackURL:{type:"string",description:"The URL to redirect to after login"},newUserCallbackURL:{type:"string",description:"The URL to redirect to after login if the user is new"}},required:["callbackURL"]}}}}}}},async t=>{let r=t.body,{email:o,organizationSlug:i,domain:n}=r;if(!o&&!i&&!n)throw new oe.APIError("BAD_REQUEST",{message:"email, organizationSlug or domain is required"});n=r.domain||o?.split("@")[1];let a="";i&&(a=await t.context.adapter.findOne({model:"organization",where:[{field:"slug",value:i}]}).then(u=>u?u.id:""));let d=await t.context.adapter.findOne({model:"ssoProvider",where:[{field:a?"organizationId":"domain",value:a||n}]}).then(u=>u?{...u,oidcConfig:JSON.parse(u.oidcConfig)}:null);if(!d)throw new oe.APIError("NOT_FOUND",{message:"No provider found for the issuer"});let s=await se(t),c=`${t.context.baseURL}/sso/callback/${d.providerId}`,l=await E({id:d.issuer,options:{clientId:d.oidcConfig.clientId,clientSecret:d.oidcConfig.clientSecret},redirectURI:c,state:s.state,codeVerifier:d.oidcConfig.pkce?s.codeVerifier:void 0,scopes:["openid","email","profile","offline_access"],authorizationEndpoint:d.oidcConfig.authorizationEndpoint});return t.json({url:l.toString(),redirect:!0})}),callbackSSO:w("/sso/callback/:providerId",{method:"GET",query:y.z.object({code:y.z.string().optional(),state:y.z.string(),error:y.z.string().optional(),error_description:y.z.string().optional()}),metadata:{isAction:!1,openapi:{summary:"Callback URL for SSO provider",description:"This endpoint is used as the callback URL for SSO providers. It handles the authorization code and exchanges it for an access token",responses:{302:{description:"Redirects to the callback URL"}}}}},async t=>{let{code:r,state:o,error:i,error_description:n}=t.query,a=await Re(t);if(!a)throw t.redirect(`${t.context.baseURL}/error?error=invalid_state`);let{callbackURL:d,errorURL:s,newUserURL:c}=a;if(!r||i)throw t.redirect(`${s||d}?error=${i}&error_description=${n}`);let l=await t.context.adapter.findOne({model:"ssoProvider",where:[{field:"providerId",value:t.params.providerId}]}).then(A=>A?{...A,oidcConfig:JSON.parse(A.oidcConfig)}:null);if(!l)throw t.redirect(`${s||d}/error?error=invalid_provider&error_description=provider not found`);let u=l.oidcConfig,p=await R(l.oidcConfig.discoveryEndpoint);if(p.data&&(u={tokenEndpoint:p.data.token_endpoint,tokenEndpointAuthentication:p.data.token_endpoint_auth_method,userInfoEndpoint:p.data.userinfo_endpoint,scopes:["openid","email","profile","offline_access"],...l.oidcConfig}),!u.tokenEndpoint)throw t.redirect(`${s||d}/error?error=invalid_provider&error_description=token_endpoint_not_found`);let g=await _({code:r,codeVerifier:l.oidcConfig.pkce?a.codeVerifier:void 0,redirectURI:`${t.context.baseURL}/sso/callback/${l.providerId}`,options:{clientId:l.oidcConfig.clientId,clientSecret:l.oidcConfig.clientSecret},tokenEndpoint:u.tokenEndpoint,authentication:u.tokenEndpointAuthentication==="client_secret_post"?"post":"basic"}).catch(A=>{if(A instanceof Le)throw t.redirect(`${s||d}?error=invalid_provider&error_description=${A.message}`);return null});if(!g)throw t.redirect(`${s||d}/error?error=invalid_provider&error_description=token_response_not_found`);let m=null;if(g.idToken){let A=(0,Nt.decodeJwt)(g.idToken);if(!u.jwksEndpoint)throw t.redirect(`${s||d}/error?error=invalid_provider&error_description=jwks_endpoint_not_found`);let b=await tt(g.idToken,u.jwksEndpoint).catch(k=>(t.context.logger.error(k),null));if(!b)throw t.redirect(`${s||d}/error?error=invalid_provider&error_description=token_not_verified`);if(b.payload.iss!==l.issuer)throw t.redirect(`${s||d}/error?error=invalid_provider&error_description=issuer_mismatch`);let N=u.mapping||{};m={...Object.fromEntries(Object.entries(N.extraFields||{}).map(([k,he])=>[k,b.payload[he]])),id:A[N.id||"sub"],email:A[N.email||"email"],emailVerified:A[N.emailVerified||"email_verified"],name:A[N.name||"name"],image:A[N.image||"picture"]}}if(!m){if(!u.userInfoEndpoint)throw t.redirect(`${s||d}/error?error=invalid_provider&error_description=user_info_endpoint_not_found`);let A=await R(u.userInfoEndpoint,{headers:{Authorization:`Bearer ${g.accessToken}`}});if(A.error)throw t.redirect(`${s||d}/error?error=invalid_provider&error_description=${A.error.message}`);m=A.data}if(!m.email||!m.id)throw t.redirect(`${s||d}/error?error=invalid_provider&error_description=missing_user_info`);let U=await ce(t,{userInfo:{email:m.email,name:m.name||m.email,id:m.id,image:m.image,emailVerified:m.emailVerified||!1},account:{idToken:g.idToken,accessToken:g.accessToken,refreshToken:g.refreshToken,accountId:m.id,providerId:l.providerId,accessTokenExpiresAt:g.accessTokenExpiresAt,refreshTokenExpiresAt:g.refreshTokenExpiresAt,scope:g.scopes?.join(",")}});if(U.error)throw t.redirect(`${s||d}/error?error=${U.error}`);let{session:V,user:j}=U.data;if(e?.provisionUser&&await e.provisionUser({user:j,userInfo:m,token:g,provider:l}),l.organizationId&&!e?.organizationProvisioning?.disabled&&t.context.options.plugins?.find(b=>b.id==="organization")&&!await t.context.adapter.findOne({model:"member",where:[{field:"organizationId",value:l.organizationId},{field:"userId",value:j.id}]})){let N=e?.organizationProvisioning?.getRole?await e.organizationProvisioning.getRole({user:j,userInfo:m,token:g,provider:l}):e?.organizationProvisioning?.defaultRole||"member";await t.context.adapter.create({model:"member",data:{organizationId:l.organizationId,userId:j.id,role:N,createdAt:new Date,updatedAt:new Date}})}await L(t,{session:V,user:j});let F;try{F=new URL(d).toString()}catch{F=d}throw t.redirect(F)})},schema:{ssoProvider:{fields:{issuer:{type:"string",required:!0},oidcConfig:{type:"string",required:!1},samlConfig:{type:"string",required:!1},userId:{type:"string",references:{model:"user",field:"id"}},providerId:{type:"string",required:!0,unique:!0},organizationId:{type:"string",required:!1},domain:{type:"string",required:!0}}}}});0&&(module.exports={sso});
