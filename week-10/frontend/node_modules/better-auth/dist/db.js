var q=(e,s="ms")=>new Date(Date.now()+(s==="sec"?e*1e3:e));import{z as x}from"zod";import{APIError as we}from"better-call";var be=x.object({id:x.string(),providerId:x.string(),accountId:x.string(),userId:x.string(),accessToken:x.string().nullish(),refreshToken:x.string().nullish(),idToken:x.string().nullish(),accessTokenExpiresAt:x.date().nullish(),refreshTokenExpiresAt:x.date().nullish(),scope:x.string().nullish(),password:x.string().nullish(),createdAt:x.date().default(()=>new Date),updatedAt:x.date().default(()=>new Date)}),ve=x.object({id:x.string(),email:x.string().transform(e=>e.toLowerCase()),emailVerified:x.boolean().default(!1),name:x.string(),image:x.string().nullish(),createdAt:x.date().default(()=>new Date),updatedAt:x.date().default(()=>new Date)}),Te=x.object({id:x.string(),userId:x.string(),expiresAt:x.date(),createdAt:x.date().default(()=>new Date),updatedAt:x.date().default(()=>new Date),token:x.string(),ipAddress:x.string().nullish(),userAgent:x.string().nullish()}),ke=x.object({id:x.string(),value:x.string(),createdAt:x.date().default(()=>new Date),updatedAt:x.date().default(()=>new Date),expiresAt:x.date(),identifier:x.string()});function P(e,s){let l=s.fields,u={};for(let p in e){let g=l[p];if(!g){u[p]=e[p];continue}g.returned!==!1&&(u[p]=e[p])}return u}function V(e,s){let l={...s==="user"?e.user?.additionalFields:{},...s==="session"?e.session?.additionalFields:{}};for(let u of e.plugins||[])u.schema&&u.schema[s]&&(l={...l,...u.schema[s].fields});return l}function B(e,s){let l=V(e,"user");return P(s,{fields:l})}function I(e,s){let l=V(e,"session");return P(s,{fields:l})}function M(e,s){let l=s.hooks;async function u(d,m,t){let r=d;for(let o of l||[]){let c=o[m]?.create?.before;if(c){let i=await c(d);if(i===!1)return null;typeof i=="object"&&"data"in i&&(r=i.data)}}let n=t?await t.fn(r):null,a=!t||t.executeMainFn?await e.create({model:m,data:r}):n;for(let o of l||[]){let c=o[m]?.create?.after;c&&await c(a)}return a}async function p(d,m,t,r){let n=d;for(let c of l||[]){let i=c[t]?.update?.before;if(i){let f=await i(d);if(f===!1)return null;n=typeof f=="object"?f.data:f}}let a=r?await r.fn(n):null,o=!r||r.executeMainFn?await e.update({model:t,update:n,where:m}):a;for(let c of l||[]){let i=c[t]?.update?.after;i&&await i(o)}return o}async function g(d,m,t,r){let n=d;for(let c of l||[]){let i=c[t]?.update?.before;if(i){let f=await i(d);if(f===!1)return null;n=typeof f=="object"?f.data:f}}let a=r?await r.fn(n):null,o=!r||r.executeMainFn?await e.updateMany({model:t,update:n,where:m}):a;for(let c of l||[]){let i=c[t]?.update?.after;i&&await i(o)}return o}return{createWithHooks:u,updateWithHooks:p,updateManyWithHooks:g}}var D=Object.create(null),F=e=>globalThis.process?.env||globalThis.Deno?.env.toObject()||globalThis.__env__||(e?D:globalThis),_=new Proxy(D,{get(e,s){return F()[s]??D[s]},has(e,s){let l=F();return s in l||s in D},set(e,s,l){let u=F(!0);return u[s]=l,!0},deleteProperty(e,s){if(!s)return!1;let l=F(!0);return delete l[s],!0},ownKeys(){let e=F(!0);return Object.keys(e)}});function Y(e){return e?e!=="false":!1}var ee=typeof process<"u"&&process.env&&process.env.NODE_ENV||"";var C=ee==="test"||Y(_.TEST);function j(e,s){if(s.advanced?.ipAddress?.disableIpTracking)return null;let l="127.0.0.1";if(C)return l;let p=s.advanced?.ipAddress?.ipAddressHeaders||["x-client-ip","x-forwarded-for","cf-connecting-ip","fastly-client-ip","x-real-ip","x-cluster-client-ip","x-forwarded","forwarded-for","forwarded"],g=e instanceof Request?e.headers:e;for(let d of p){let m=g.get(d);if(typeof m=="string"){let t=m.split(",")[0].trim();if(t)return t}}return null}function U(e){try{return JSON.parse(e)}catch{return null}}import{createRandomStringGenerator as te}from"@better-auth/utils/random";var k=e=>te("a-z","A-Z","0-9")(e||32);import{z as Tt}from"zod";import{APIError as Rt}from"better-call";var O=class extends Error{constructor(s,l){super(s),this.name="BetterAuthError",this.message=s,this.cause=l,this.stack=""}};import{createHash as at}from"@better-auth/utils/hash";import{xchacha20poly1305 as dt}from"@noble/ciphers/chacha";import{bytesToHex as ct,hexToBytes as lt,utf8ToBytes as ft}from"@noble/ciphers/utils";import{managedNonce as mt}from"@noble/ciphers/webcrypto";import{createHash as He}from"@better-auth/utils/hash";import{SignJWT as Je}from"jose";import{scryptAsync as Qe}from"@noble/hashes/scrypt";import{getRandomValues as Ye}from"uncrypto";import{hex as tt}from"@better-auth/utils/hex";import{createRandomStringGenerator as ne}from"@better-auth/utils/random";var ie=ne("a-z","0-9","A-Z","-_");var L=["info","success","warn","error","debug"];function se(e,s){return L.indexOf(s)<=L.indexOf(e)}var b={reset:"\x1B[0m",bright:"\x1B[1m",dim:"\x1B[2m",underscore:"\x1B[4m",blink:"\x1B[5m",reverse:"\x1B[7m",hidden:"\x1B[8m",fg:{black:"\x1B[30m",red:"\x1B[31m",green:"\x1B[32m",yellow:"\x1B[33m",blue:"\x1B[34m",magenta:"\x1B[35m",cyan:"\x1B[36m",white:"\x1B[37m"},bg:{black:"\x1B[40m",red:"\x1B[41m",green:"\x1B[42m",yellow:"\x1B[43m",blue:"\x1B[44m",magenta:"\x1B[45m",cyan:"\x1B[46m",white:"\x1B[47m"}},ae={info:b.fg.blue,success:b.fg.green,warn:b.fg.yellow,error:b.fg.red,debug:b.fg.magenta},oe=(e,s)=>{let l=new Date().toISOString();return`${b.dim}${l}${b.reset} ${ae[e]}${e.toUpperCase()}${b.reset} ${b.bright}[Better Auth]:${b.reset} ${s}`},E=e=>{let s=e?.disabled!==!0,l=e?.level??"error",u=(p,g,d=[])=>{if(!s||!se(l,p))return;let m=oe(p,g);if(!e||typeof e.log!="function"){p==="error"?console.error(m,...d):p==="warn"?console.warn(m,...d):console.log(m,...d);return}e.log(p==="success"?"info":p,g,...d)};return Object.fromEntries(L.map(p=>[p,(...[g,...d])=>u(p,g,d)]))},$=E();var Ht=(e,s)=>{let l=s.options,u=l.secondaryStorage,p=l.session?.expiresIn||60*60*24*7,{createWithHooks:g,updateWithHooks:d,updateManyWithHooks:m}=M(e,s);return{createOAuthUser:async(t,r)=>{let n=await g({createdAt:new Date,updatedAt:new Date,...t},"user"),a=await g({...r,userId:n.id||t.id,createdAt:new Date,updatedAt:new Date},"account");return{user:n,account:a}},createUser:async t=>await g({createdAt:new Date,updatedAt:new Date,emailVerified:!1,...t,email:t.email.toLowerCase()},"user"),createAccount:async t=>await g({createdAt:new Date,updatedAt:new Date,...t},"account"),listSessions:async t=>{if(u){let n=await u.get(`active-sessions-${t}`);if(!n)return[];let a=U(n)||[],o=Date.now(),c=a.filter(f=>f.expiresAt>o),i=[];for(let f of c){let A=await u.get(f.token);if(A){let y=JSON.parse(A),w=I(s.options,{...y.session,expiresAt:new Date(y.session.expiresAt)});i.push(w)}}return i}return await e.findMany({model:"session",where:[{field:"userId",value:t}]})},listUsers:async(t,r,n,a)=>await e.findMany({model:"user",limit:t,offset:r,sortBy:n,where:a}),deleteUser:async t=>{await e.deleteMany({model:"session",where:[{field:"userId",value:t}]}),await e.deleteMany({model:"account",where:[{field:"userId",value:t}]}),await e.delete({model:"user",where:[{field:"id",value:t}]})},createSession:async(t,r,n,a)=>{let o=r instanceof Request?r.headers:r,{id:c,...i}=a||{},f={ipAddress:r&&j(r,s.options)||"",userAgent:o?.get("user-agent")||"",...i,expiresAt:n?q(60*60*24,"sec"):q(p,"sec"),userId:t,token:k(32),createdAt:new Date,updatedAt:new Date};return await g(f,"session",u?{fn:async y=>{let w=await u.get(`active-sessions-${t}`),h=[],T=Date.now();return w&&(h=U(w)||[],h=h.filter(X=>X.expiresAt>T)),h.push({token:f.token,expiresAt:T+p*1e3}),await u.set(`active-sessions-${t}`,JSON.stringify(h),p),y},executeMainFn:l.session?.storeSessionInDatabase}:void 0)},findSession:async t=>{if(u){let c=await u.get(t);if(c){let i=JSON.parse(c),f=I(s.options,{...i.session,expiresAt:new Date(i.session.expiresAt),createdAt:new Date(i.session.createdAt),updatedAt:new Date(i.session.updatedAt)}),A=B(s.options,{...i.user,createdAt:new Date(i.user.createdAt),updatedAt:new Date(i.user.updatedAt)});return{session:f,user:A}}}let r=await e.findOne({model:"session",where:[{value:t,field:"token"}]});if(!r)return null;let n=await e.findOne({model:"user",where:[{value:r.userId,field:"id"}]});if(!n)return null;let a=I(s.options,r),o=B(s.options,n);return u&&await u?.set(t,JSON.stringify({session:a,user:o}),a.expiresAt?Math.floor(((a.expiresAt instanceof Date?a.expiresAt.getTime():new Date(a.expiresAt).getTime())-Date.now())/1e3):p),{session:a,user:o}},findSessions:async t=>{if(u){let o=[];for(let c of t){let i=await u.get(c);if(i){let f=JSON.parse(i),A={session:{...f.session,expiresAt:new Date(f.session.expiresAt)},user:{...f.user,createdAt:new Date(f.user.createdAt),updatedAt:new Date(f.user.updatedAt)}};o.push(A)}}return o}let r=await e.findMany({model:"session",where:[{field:"token",value:t,operator:"in"}]}),n=r.map(o=>o.userId);if(!n.length)return[];let a=await e.findMany({model:"user",where:[{field:"id",value:n,operator:"in"}]});return r.map(o=>{let c=a.find(i=>i.id===o.userId);return c?{session:o,user:c}:null})},updateSession:async(t,r)=>await d(r,[{field:"token",value:t}],"session",u?{async fn(a){let o=await u.get(t),c=null;return o?(c={...JSON.parse(o).session,...a},c):null},executeMainFn:l.session?.storeSessionInDatabase}:void 0),deleteSession:async t=>{if(u){await u.delete(t),l.session?.storeSessionInDatabase&&await e.delete({model:"session",where:[{field:"token",value:t}]});return}await e.delete({model:"session",where:[{field:"token",value:t}]})},deleteAccounts:async t=>{await e.deleteMany({model:"account",where:[{field:"userId",value:t}]})},deleteAccount:async(t,r)=>{await e.delete({model:"account",where:[{field:"providerId",value:t},{field:"userId",value:r}]})},deleteSessions:async t=>{if(u){if(typeof t=="string"){let r=await u.get(`active-sessions-${t}`),n=r?U(r):[];if(!n)return;for(let a of n)await u.delete(a.token)}else for(let r of t)await u.get(r)&&await u.delete(r);l.session?.storeSessionInDatabase&&await e.deleteMany({model:"session",where:[{field:Array.isArray(t)?"token":"userId",value:t,operator:Array.isArray(t)?"in":void 0}]});return}await e.deleteMany({model:"session",where:[{field:Array.isArray(t)?"token":"userId",value:t,operator:Array.isArray(t)?"in":void 0}]})},findOAuthUser:async(t,r,n)=>{let a=await e.findOne({model:"account",where:[{value:r,field:"accountId"},{value:n,field:"providerId"}]});if(a){let o=await e.findOne({model:"user",where:[{value:a.userId,field:"id"}]});return o?{user:o,accounts:[a]}:null}else{let o=await e.findOne({model:"user",where:[{value:t.toLowerCase(),field:"email"}]});if(o){let c=await e.findMany({model:"account",where:[{value:o.id,field:"userId"}]});return{user:o,accounts:c||[]}}else return null}},findUserByEmail:async(t,r)=>{let n=await e.findOne({model:"user",where:[{value:t.toLowerCase(),field:"email"}]});if(!n)return null;if(r?.includeAccounts){let a=await e.findMany({model:"account",where:[{value:n.id,field:"userId"}]});return{user:n,accounts:a}}return{user:n,accounts:[]}},findUserById:async t=>await e.findOne({model:"user",where:[{field:"id",value:t}]}),linkAccount:async t=>await g({...t,createdAt:new Date,updatedAt:new Date},"account"),updateUser:async(t,r)=>await d(r,[{field:"id",value:t}],"user"),updateUserByEmail:async(t,r)=>await d(r,[{field:"email",value:t}],"user"),updatePassword:async(t,r)=>{await m({password:r},[{field:"userId",value:t},{field:"providerId",value:"credential"}],"account")},findAccounts:async t=>await e.findMany({model:"account",where:[{field:"userId",value:t}]}),findAccount:async t=>await e.findOne({model:"account",where:[{field:"accountId",value:t}]}),findAccountByUserId:async t=>await e.findMany({model:"account",where:[{field:"userId",value:t}]}),updateAccount:async(t,r)=>await d(r,[{field:"id",value:t}],"account"),createVerificationValue:async t=>await g({createdAt:new Date,updatedAt:new Date,...t},"verification"),findVerificationValue:async t=>(await e.findMany({model:"verification",where:[{field:"identifier",value:t}],sortBy:{field:"createdAt",direction:"desc"},limit:1}))[0],deleteVerificationValue:async t=>{await e.delete({model:"verification",where:[{field:"id",value:t}]})},deleteVerificationByIdentifier:async t=>{await e.delete({model:"verification",where:[{field:"identifier",value:t}]})},updateVerificationValue:async(t,r)=>await d(r,[{field:"id",value:t}],"verification")}};var Wt=(e,s)=>({type:e,...s});var v=e=>{let s=e.plugins?.reduce((t,r)=>{let n=r.schema;if(!n)return t;for(let[a,o]of Object.entries(n))t[a]={fields:{...t[a]?.fields,...o.fields},modelName:o.modelName||a};return t},{}),l=e.rateLimit?.storage==="database",u={rateLimit:{modelName:e.rateLimit?.modelName||"rateLimit",fields:{key:{type:"string",fieldName:e.rateLimit?.fields?.key||"key"},count:{type:"number",fieldName:e.rateLimit?.fields?.count||"count"},lastRequest:{type:"number",fieldName:e.rateLimit?.fields?.lastRequest||"lastRequest"}}}},{user:p,session:g,account:d,...m}=s||{};return{user:{modelName:e.user?.modelName||"user",fields:{name:{type:"string",required:!0,fieldName:e.user?.fields?.name||"name"},email:{type:"string",unique:!0,required:!0,fieldName:e.user?.fields?.email||"email"},emailVerified:{type:"boolean",defaultValue:()=>!1,required:!0,fieldName:e.user?.fields?.emailVerified||"emailVerified"},image:{type:"string",required:!1,fieldName:e.user?.fields?.image||"image"},createdAt:{type:"date",defaultValue:()=>new Date,required:!0,fieldName:e.user?.fields?.createdAt||"createdAt"},updatedAt:{type:"date",defaultValue:()=>new Date,required:!0,fieldName:e.user?.fields?.updatedAt||"updatedAt"},...p?.fields,...e.user?.additionalFields},order:1},session:{modelName:e.session?.modelName||"session",fields:{expiresAt:{type:"date",required:!0,fieldName:e.session?.fields?.expiresAt||"expiresAt"},token:{type:"string",required:!0,fieldName:e.session?.fields?.token||"token",unique:!0},createdAt:{type:"date",required:!0,fieldName:e.session?.fields?.createdAt||"createdAt"},updatedAt:{type:"date",required:!0,fieldName:e.session?.fields?.updatedAt||"updatedAt"},ipAddress:{type:"string",required:!1,fieldName:e.session?.fields?.ipAddress||"ipAddress"},userAgent:{type:"string",required:!1,fieldName:e.session?.fields?.userAgent||"userAgent"},userId:{type:"string",fieldName:e.session?.fields?.userId||"userId",references:{model:e.user?.modelName||"user",field:"id",onDelete:"cascade"},required:!0},...g?.fields,...e.session?.additionalFields},order:2},account:{modelName:e.account?.modelName||"account",fields:{accountId:{type:"string",required:!0,fieldName:e.account?.fields?.accountId||"accountId"},providerId:{type:"string",required:!0,fieldName:e.account?.fields?.providerId||"providerId"},userId:{type:"string",references:{model:e.user?.modelName||"user",field:"id",onDelete:"cascade"},required:!0,fieldName:e.account?.fields?.userId||"userId"},accessToken:{type:"string",required:!1,fieldName:e.account?.fields?.accessToken||"accessToken"},refreshToken:{type:"string",required:!1,fieldName:e.account?.fields?.refreshToken||"refreshToken"},idToken:{type:"string",required:!1,fieldName:e.account?.fields?.idToken||"idToken"},accessTokenExpiresAt:{type:"date",required:!1,fieldName:e.account?.fields?.accessTokenExpiresAt||"accessTokenExpiresAt"},refreshTokenExpiresAt:{type:"date",required:!1,fieldName:e.account?.fields?.accessTokenExpiresAt||"refreshTokenExpiresAt"},scope:{type:"string",required:!1,fieldName:e.account?.fields?.scope||"scope"},password:{type:"string",required:!1,fieldName:e.account?.fields?.password||"password"},createdAt:{type:"date",required:!0,fieldName:e.account?.fields?.createdAt||"createdAt"},updatedAt:{type:"date",required:!0,fieldName:e.account?.fields?.updatedAt||"updatedAt"},...d?.fields},order:3},verification:{modelName:e.verification?.modelName||"verification",fields:{identifier:{type:"string",required:!0,fieldName:e.verification?.fields?.identifier||"identifier"},value:{type:"string",required:!0,fieldName:e.verification?.fields?.value||"value"},expiresAt:{type:"date",required:!0,fieldName:e.verification?.fields?.expiresAt||"expiresAt"},createdAt:{type:"date",required:!1,defaultValue:()=>new Date,fieldName:e.verification?.fields?.createdAt||"createdAt"},updatedAt:{type:"date",required:!1,defaultValue:()=>new Date,fieldName:e.verification?.fields?.updatedAt||"updatedAt"}},order:4},...m,...l?u:{}}};import{z as R}from"zod";function Zt(e){return R.object({...Object.keys(e).reduce((l,u)=>{let p=e[u];if(!p)return l;if(p.type==="string[]"||p.type==="number[]")return{...l,[u]:R.array(p.type==="string[]"?R.string():R.number())};if(Array.isArray(p.type))return{...l,[u]:R.any()};let g=R[p.type]();return p?.required===!1&&(g=g.optional()),p?.returned===!1?l:{...l,[u]:g}},{})})}import{Kysely as H,MssqlDialect as de}from"kysely";import{MysqlDialect as K,PostgresDialect as W,SqliteDialect as J}from"kysely";function z(e){if(!e)return null;if("dialect"in e)return z(e.dialect);if("createDriver"in e){if(e instanceof J)return"sqlite";if(e instanceof K)return"mysql";if(e instanceof W)return"postgres";if(e instanceof de)return"mssql"}return"aggregate"in e?"sqlite":"getConnection"in e?"mysql":"connect"in e?"postgres":null}var N=async e=>{let s=e.database;if(!s)return{kysely:null,databaseType:null};if("db"in s)return{kysely:s.db,databaseType:s.type};if("dialect"in s)return{kysely:new H({dialect:s.dialect}),databaseType:s.type};let l,u=z(s);return"createDriver"in s&&(l=s),"aggregate"in s&&(l=new J({database:s})),"getConnection"in s&&(l=new K(s)),"connect"in s&&(l=new W({pool:s})),{kysely:l?new H({dialect:l}):null,databaseType:u}};function S(e,s,l){return l==="update"?e:e==null&&s.defaultValue?typeof s.defaultValue=="function"?s.defaultValue():s.defaultValue:e}var ue=(e,s,l)=>{let u=v(s);function p(r,n){if(n==="id")return n;let a=u[r].fields[n];return a||console.log("Field not found",r,n),a.fieldName||n}function g(r,n,a){let{type:o="sqlite"}=l||{},c=u[n].fields[a];return c.type==="boolean"&&o==="sqlite"&&r!==null&&r!==void 0?r?1:0:c.type==="date"&&r&&r instanceof Date&&o==="sqlite"?r.toISOString():r}function d(r,n,a){let{type:o="sqlite"}=l||{},c=u[n].fields[a];return c.type==="boolean"&&o==="sqlite"&&r!==null?r===1:c.type==="date"&&r?new Date(r):r}function m(r){return u[r].modelName}let t=s?.advanced?.generateId===!1;return{transformInput(r,n,a){let o=t||a==="update"?{}:{id:s.advanced?.generateId?s.advanced.generateId({model:n}):r.id||k()},c=u[n].fields;for(let i in c){let f=r[i];o[c[i].fieldName||i]=S(g(f,n,i),c[i],a)}return o},transformOutput(r,n,a=[]){if(!r)return null;let o=r.id?a.length===0||a.includes("id")?{id:r.id}:{}:{},c=u[n].fields;for(let i in c){if(a.length&&!a.includes(i))continue;let f=c[i];f&&(o[i]=d(r[f.fieldName||i],n,i))}return o},convertWhereClause(r,n){if(!n)return{and:null,or:null};let a={and:[],or:[]};return n.forEach(o=>{let{field:c,value:i,operator:f="=",connector:A="AND"}=o,y=p(r,c),w=h=>f.toLowerCase()==="in"?h(y,"in",Array.isArray(i)?i:[i]):f==="contains"?h(y,"like",`%${i}%`):f==="starts_with"?h(y,"like",`${i}%`):f==="ends_with"?h(y,"like",`%${i}`):f==="eq"?h(y,"=",i):f==="ne"?h(y,"<>",i):f==="gt"?h(y,">",i):f==="gte"?h(y,">=",i):f==="lt"?h(y,"<",i):f==="lte"?h(y,"<=",i):h(y,f,i);A==="OR"?a.or.push(w):a.and.push(w)}),{and:a.and.length?a.and:null,or:a.or.length?a.or:null}},async withReturning(r,n,a,o){let c;if(l?.type!=="mysql")c=await n.returningAll().executeTakeFirst();else{await n.execute();let i=r.id?"id":o[0].field?o[0].field:"id",f=r[i]||o[0].value;c=await e.selectFrom(m(a)).selectAll().where(p(a,i),"=",f).executeTakeFirst()}return c},getModelName:m,getField:p}},G=(e,s)=>l=>{let{transformInput:u,withReturning:p,transformOutput:g,convertWhereClause:d,getModelName:m,getField:t}=ue(e,l,s);return{id:"kysely",async create(r){let{model:n,data:a,select:o}=r,c=u(a,n,"create"),i=e.insertInto(m(n)).values(c);return g(await p(c,i,n,[]),n,o)},async findOne(r){let{model:n,where:a,select:o}=r,{and:c,or:i}=d(n,a),f=e.selectFrom(m(n)).selectAll();c&&(f=f.where(y=>y.and(c.map(w=>w(y))))),i&&(f=f.where(y=>y.or(i.map(w=>w(y)))));let A=await f.executeTakeFirst();return A?g(A,n,o):null},async findMany(r){let{model:n,where:a,limit:o,offset:c,sortBy:i}=r,{and:f,or:A}=d(n,a),y=e.selectFrom(m(n));f&&(y=y.where(h=>h.and(f.map(T=>T(h))))),A&&(y=y.where(h=>h.or(A.map(T=>T(h))))),y=y.limit(o||100),c&&(y=y.offset(c)),i&&(y=y.orderBy(t(n,i.field),i.direction));let w=await y.selectAll().execute();return w?w.map(h=>g(h,n)):[]},async update(r){let{model:n,where:a,update:o}=r,{and:c,or:i}=d(n,a),f=u(o,n,"update"),A=e.updateTable(m(n)).set(f);return c&&(A=A.where(w=>w.and(c.map(h=>h(w))))),i&&(A=A.where(w=>w.or(i.map(h=>h(w))))),await g(await p(f,A,n,a),n)},async updateMany(r){let{model:n,where:a,update:o}=r,{and:c,or:i}=d(n,a),f=u(o,n,"update"),A=e.updateTable(m(n)).set(f);return c&&(A=A.where(w=>w.and(c.map(h=>h(w))))),i&&(A=A.where(w=>w.or(i.map(h=>h(w))))),(await A.execute()).length},async delete(r){let{model:n,where:a}=r,{and:o,or:c}=d(n,a),i=e.deleteFrom(m(n));o&&(i=i.where(f=>f.and(o.map(A=>A(f))))),c&&(i=i.where(f=>f.or(c.map(A=>A(f))))),await i.execute()},async deleteMany(r){let{model:n,where:a}=r,{and:o,or:c}=d(n,a),i=e.deleteFrom(m(n));return o&&(i=i.where(f=>f.and(o.map(A=>A(f))))),c&&(i=i.where(f=>f.or(c.map(A=>A(f))))),(await i.execute()).length},options:s}};var ce=e=>{let s=v(e);function l(u,p){return p==="id"?p:s[u].fields[p].fieldName||p}return{transformInput(u,p,g){let d=g==="update"?{}:{id:e.advanced?.generateId?e.advanced.generateId({model:p}):u.id||k()},m=s[p].fields;for(let t in m){let r=u[t];r===void 0&&!m[t].defaultValue||(d[m[t].fieldName||t]=S(r,m[t],g))}return d},transformOutput(u,p,g=[]){if(!u)return null;let d=u.id||u._id?g.length===0||g.includes("id")?{id:u.id}:{}:{},m=s[p].fields;for(let t in m){if(g.length&&!g.includes(t))continue;let r=m[t];r&&(d[t]=u[r.fieldName||t])}return d},convertWhereClause(u,p,g){return p.filter(d=>u.every(m=>{let{field:t,value:r,operator:n}=m,a=l(g,t);if(n==="in"){if(!Array.isArray(r))throw new Error("Value must be an array");return r.includes(d[a])}else return n==="contains"?d[a].includes(r):n==="starts_with"?d[a].startsWith(r):n==="ends_with"?d[a].endsWith(r):d[a]===r}))},getField:l}},Z=e=>s=>{let{transformInput:l,transformOutput:u,convertWhereClause:p,getField:g}=ce(s);return{id:"memory",create:async({model:d,data:m})=>{let t=l(m,d,"create");return e[d].push(t),u(t,d)},findOne:async({model:d,where:m,select:t})=>{let r=e[d],a=p(m,r,d)[0]||null;return u(a,d,t)},findMany:async({model:d,where:m,sortBy:t,limit:r,offset:n})=>{let a=e[d];return m&&(a=p(m,a,d)),t&&(a=a.sort((o,c)=>{let i=g(d,t.field);return t.direction==="asc"?o[i]>c[i]?1:-1:o[i]<c[i]?1:-1})),n!==void 0&&(a=a.slice(n)),r!==void 0&&(a=a.slice(0,r)),a.map(o=>u(o,d))},update:async({model:d,where:m,update:t})=>{let r=e[d],n=p(m,r,d);return n.forEach(a=>{Object.assign(a,l(t,d,"update"))}),u(n[0],d)},delete:async({model:d,where:m})=>{let t=e[d],r=p(m,t,d);e[d]=t.filter(n=>!r.includes(n))},deleteMany:async({model:d,where:m})=>{let t=e[d],r=p(m,t,d),n=0;return e[d]=t.filter(a=>r.includes(a)?(n++,!1):!r.includes(a)),n},updateMany(d){let{model:m,where:t,update:r}=d,n=e[m],a=p(t,n,m);return a.forEach(o=>{Object.assign(o,r)}),a[0]||null}}};async function vr(e){if(!e.database){let u=v(e),p=Object.keys(u).reduce((g,d)=>(g[d]=[],g),{});return $.warn("No database configuration provided. Using memory adapter in development"),Z(p)(e)}if(typeof e.database=="function")return e.database(e);let{kysely:s,databaseType:l}=await N(e);if(!s)throw new O("Failed to initialize database adapter");return G(s,{type:l||"sqlite"})(e)}function Tr(e,s){let l=s.id?{id:s.id}:{};for(let u in e){let p=e[u],g=s[u];g!==void 0&&(l[p.fieldName||u]=g)}return l}function kr(e,s){if(!s)return null;let l={id:s.id};for(let[u,p]of Object.entries(e))l[u]=s[p.fieldName||u];return l}function Q(e){let s=v(e),l={};for(let u in s){let p=s[u],g=p.fields,d={};if(Object.entries(g).forEach(([m,t])=>{if(d[t.fieldName||m]=t,t.references){let r=s[t.references.model];r&&(d[t.fieldName||m].references={model:r.modelName,field:t.references.field})}}),l[p.modelName]){l[p.modelName].fields={...l[p.modelName].fields,...d};continue}l[p.modelName]={fields:d,order:p.order||1/0}}return l}var le={string:["character varying","text"],number:["int4","integer","bigint","smallint","numeric","real","double precision"],boolean:["bool","boolean"],date:["timestamp","date"]},fe={string:["varchar","text"],number:["integer","int","bigint","smallint","decimal","float","double"],boolean:["boolean","tinyint"],date:["timestamp","datetime","date"]},pe={string:["TEXT"],number:["INTEGER","REAL"],boolean:["INTEGER","BOOLEAN"],date:["DATE","INTEGER"]},me={string:["nvarchar","varchar"],number:["int","bigint","smallint","decimal","float","double"],boolean:["bit","boolean"],date:["datetime","date"]},ye={postgres:le,mysql:fe,sqlite:pe,mssql:me};function ge(e,s,l){if(s==="string[]"||s==="number[]")return e.toLowerCase().includes("json");let u=ye[l];return(Array.isArray(s)?u.string.map(d=>d.toLowerCase()):u[s].map(d=>d.toLowerCase())).includes(e.toLowerCase())}async function Nr(e){let s=Q(e),l=E(e.logger),{kysely:u,databaseType:p}=await N(e);p||(l.warn("Could not determine database type, defaulting to sqlite. Please provide a type in the database options to avoid this."),p="sqlite"),u||(l.error("Only kysely adapter is supported for migrations. You can use `generate` command to generate the schema, if you're using a different adapter."),process.exit(1));let g=await u.introspection.getTables(),d=[],m=[];for(let[o,c]of Object.entries(s)){let i=g.find(A=>A.name===o);if(!i){let A=d.findIndex(h=>h.table===o),y={table:o,fields:c.fields,order:c.order||1/0},w=d.findIndex(h=>(h.order||1/0)>y.order);w===-1?A===-1?d.push(y):d[A].fields={...d[A].fields,...c.fields}:d.splice(w,0,y);continue}let f={};for(let[A,y]of Object.entries(c.fields)){let w=i.columns.find(h=>h.name===A);if(!w){f[A]=y;continue}ge(w.dataType,y.type,p)||l.warn(`Field ${A} in table ${o} has a different type in the database. Expected ${y.type} but got ${w.dataType}.`)}Object.keys(f).length>0&&m.push({table:o,fields:f,order:c.order||1/0})}let t=[];function r(o){let c=o.type,i={string:{sqlite:"text",postgres:"text",mysql:o.unique?"varchar(255)":o.references?"varchar(36)":"text",mssql:"text"},boolean:{sqlite:"integer",postgres:"boolean",mysql:"boolean",mssql:"boolean"},number:{sqlite:"integer",postgres:"integer",mysql:"integer",mssql:"integer"},date:{sqlite:"date",postgres:"timestamp",mysql:"datetime",mssql:"datetime"}};return p==="sqlite"&&(c==="string[]"||c==="number[]")?"text":c==="string[]"||c==="number[]"?"jsonb":Array.isArray(c)?"text":i[c][p||"sqlite"]}if(m.length)for(let o of m)for(let[c,i]of Object.entries(o.fields)){let f=r(i),A=u.schema.alterTable(o.table).addColumn(c,f,y=>(y=i.required!==!1?y.notNull():y,i.references&&(y=y.references(`${i.references.model}.${i.references.field}`)),i.unique&&(y=y.unique()),y));t.push(A)}if(d.length)for(let o of d){let c=u.schema.createTable(o.table).addColumn("id",p==="mysql"?"varchar(36)":"text",i=>i.primaryKey().notNull());for(let[i,f]of Object.entries(o.fields)){let A=r(f);c=c.addColumn(i,A,y=>(y=f.required!==!1?y.notNull():y,f.references&&(y=y.references(`${f.references.model}.${f.references.field}`)),f.unique&&(y=y.unique()),y))}t.push(c)}async function n(){for(let o of t)await o.execute()}async function a(){return t.map(c=>c.compile().sql).join(`;

`)}return{toBeCreated:d,toBeAdded:m,runMigrations:n,compileMigrations:a}}export{kr as convertFromDB,Tr as convertToDB,Wt as createFieldAttribute,Ht as createInternalAdapter,vr as getAdapter,v as getAuthTables,Nr as getMigrations,Q as getSchema,M as getWithHooks,ge as matchType,Zt as toZodSchema};
