{"version":3,"file":"index.cjs","sources":["../../../src/server-runtime/index.tsx"],"sourcesContent":["import { Readable } from 'node:stream'\nimport { getEvent, getRequestHeaders } from 'vinxi/http'\nimport invariant from 'tiny-invariant'\nimport { fetcher } from '../client-runtime/fetcher'\nimport { getBaseUrl } from '../client-runtime/getBaseUrl'\nimport { handleServerRequest } from '../server-handler/index'\n/**\n *\n * @returns {import('node:http').IncomingMessage}\n */\nexport function createIncomingMessage(\n  url: string,\n  method: string,\n  headers: HeadersInit,\n): Readable {\n  const readable = new Readable({ objectMode: true }) as any\n  readable._read = () => {}\n\n  readable.url = url\n  readable.method = method\n  readable.headers = headers\n  readable.connection = {}\n  readable.getHeaders = () => {\n    return headers\n  }\n  return readable\n}\n\n// function createAsyncStream(options?: WritableOptions) {\n//   let firstActivity = false\n//   let resolveActivity: () => void\n//   let finishActivity: () => void\n\n//   const initialPromise = new Promise<void>((resolve) => {\n//     resolveActivity = resolve\n//   })\n\n//   const finishPromise = new Promise<void>((resolve) => {\n//     finishActivity = resolve\n//   })\n\n//   const readable = new Readable({\n//     objectMode: true,\n//   })\n\n//   readable._read = () => {}\n\n//   const writable = new Writable({\n//     ...options,\n//     write(chunk, encoding, callback) {\n//       if (!firstActivity) {\n//         firstActivity = true\n//         resolveActivity()\n//       }\n//       readable.push(chunk, encoding)\n//       callback()\n//     },\n//   }) as any\n\n//   const headers = new Headers()\n\n//   writable.setHeader = (key: string, value: string) => {\n//     headers.set(key, value)\n//   }\n\n//   writable.on('finish', () => {\n//     readable.push(null)\n//     readable.destroy()\n//     finishActivity()\n//   })\n\n//   return {\n//     readable,\n//     writable,\n//     headers,\n//     initialPromise,\n//     finishPromise,\n//   } as const\n// }\n\nconst fakeHost = 'http://localhost:3000'\n\nexport function createServerReference(_fn: any, id: string, name: string) {\n  const functionUrl = getBaseUrl(fakeHost, id, name)\n\n  const proxyFn = (...args: Array<any>) => {\n    invariant(\n      args.length === 1,\n      'Server functions can only accept a single argument',\n    )\n\n    return fetcher(functionUrl, args, async (request) => {\n      const event = getEvent()\n\n      const ogRequestHeaders = getRequestHeaders(event)\n\n      Object.entries(ogRequestHeaders).forEach(([key, value]) => {\n        if (!request.headers.has(key)) {\n          request.headers.append(key, value!)\n        }\n      })\n\n      //   // For RSC, we need to proxy this request back to the server under\n      //   // the /_server path and let the RSC/Server-fn router handle it\n      // if (RSC) {\n\n      //   const incomingMessage = createIncomingMessage(\n      //     new URL(request.url).pathname + new URL(request.url).search,\n      //     request.method,\n      //     Object.fromEntries(request.headers.entries()),\n      //   )\n\n      //   const asyncStream = createAsyncStream()\n\n      //   const result = await handleHTTPEvent(\n      //     new H3Event(incomingMessage as any, asyncStream.writable),\n      //   )\n\n      //   console.info('awaiting initial promise', result, asyncStream)\n\n      //   await asyncStream.initialPromise\n\n      //   // Only augment the headers of the underlying document request\n      //   // if the response headers have not been sent yet\n      //   if (!(event as any).__tsrHeadersSent) {\n      //     const ogResponseHeaders = getResponseHeaders(event)\n\n      //     asyncStream.headers.forEach((value, key) => {\n      //       if (!Object.hasOwn(ogResponseHeaders, key)) {\n      //         ogResponseHeaders[key] = value\n      //       }\n      //     })\n\n      //     setResponseHeaders(event, ogResponseHeaders as any)\n      //   }\n\n      //   console.info(asyncStream.readable)\n\n      //   // if (asyncStream.headers.get('content-type') === 'application/json') {\n      //   //   await asyncStream.finishPromise\n      //   // }\n\n      //   return new Response(Readable.toWeb(asyncStream.readable) as any, {\n      //     headers: asyncStream.headers,\n      //   })\n      // }\n\n      // For now, we're not doing RSC, so we just handle the request\n      // in the current non-worker scope\n      return handleServerRequest(request, event)\n    })\n  }\n\n  return Object.assign(proxyFn, {\n    url: functionUrl.replace(fakeHost, ''),\n    filename: id,\n    functionId: name,\n  })\n}\n"],"names":["Readable","getBaseUrl","fetcher","getEvent","getRequestHeaders","handleServerRequest"],"mappings":";;;;;;;;AAUgB,SAAA,sBACd,KACA,QACA,SACU;AACV,QAAM,WAAW,IAAIA,YAAAA,SAAS,EAAE,YAAY,MAAM;AAClD,WAAS,QAAQ,MAAM;AAAA,EAAC;AAExB,WAAS,MAAM;AACf,WAAS,SAAS;AAClB,WAAS,UAAU;AACnB,WAAS,aAAa,CAAC;AACvB,WAAS,aAAa,MAAM;AACnB,WAAA;AAAA,EACT;AACO,SAAA;AACT;AAsDA,MAAM,WAAW;AAED,SAAA,sBAAsB,KAAU,IAAY,MAAc;AACxE,QAAM,cAAcC,WAAA,WAAW,UAAU,IAAI,IAAI;AAE3C,QAAA,UAAU,IAAI,SAAqB;AACvC;AAAA,MACE,KAAK,WAAW;AAAA,MAChB;AAAA,IACF;AAEA,WAAOC,gBAAQ,aAAa,MAAM,OAAO,YAAY;AACnD,YAAM,QAAQC,KAAAA,SAAS;AAEjB,YAAA,mBAAmBC,uBAAkB,KAAK;AAEzC,aAAA,QAAQ,gBAAgB,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AACzD,YAAI,CAAC,QAAQ,QAAQ,IAAI,GAAG,GAAG;AACrB,kBAAA,QAAQ,OAAO,KAAK,KAAM;AAAA,QAAA;AAAA,MACpC,CACD;AAiDM,aAAAC,MAAAA,oBAAoB,OAAc;AAAA,IAAA,CAC1C;AAAA,EACH;AAEO,SAAA,OAAO,OAAO,SAAS;AAAA,IAC5B,KAAK,YAAY,QAAQ,UAAU,EAAE;AAAA,IACrC,UAAU;AAAA,IACV,YAAY;AAAA,EAAA,CACb;AACH;;;"}