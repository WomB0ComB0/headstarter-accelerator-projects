{"version":3,"file":"serialization.cjs","sources":["../../../src/client/serialization.tsx"],"sourcesContent":["import * as React from 'react'\nimport {\n  ScriptOnce,\n  TSR_DEFERRED_PROMISE,\n  createControlledPromise,\n  defer,\n  isPlainArray,\n  isPlainObject,\n  pick,\n  useRouter,\n} from '@tanstack/react-router'\nimport jsesc from 'jsesc'\nimport invariant from 'tiny-invariant'\nimport type {\n  AnyRouteMatch,\n  AnyRouter,\n  ExtractedEntry,\n  ExtractedPromise,\n  ExtractedStream,\n  StreamState,\n} from '@tanstack/react-router'\n\nexport function serializeLoaderData(\n  dataType: '__beforeLoadContext' | 'loaderData',\n  data: any,\n  ctx: {\n    match: AnyRouteMatch\n    router: AnyRouter\n  },\n) {\n  if (!ctx.router.isServer) {\n    return data\n  }\n\n  ;(ctx.match as any).extracted = (ctx.match as any).extracted || []\n\n  const extracted = (ctx.match as any).extracted\n\n  const replacedLoaderData = replaceBy(data, (value, path) => {\n    const type =\n      value instanceof ReadableStream\n        ? 'stream'\n        : value instanceof Promise\n          ? 'promise'\n          : undefined\n\n    // If it's a stream, we need to tee it so we can read it multiple times\n    if (type === 'stream') {\n      const [copy1, copy2] = value.tee()\n      const entry: ExtractedStream = {\n        dataType,\n        type,\n        path,\n        id: extracted.length,\n        matchIndex: ctx.match.index,\n        streamState: createStreamState({ stream: copy2 }),\n      }\n\n      extracted.push(entry)\n      return copy1\n    } else if (type === 'promise') {\n      defer(value)\n      const entry: ExtractedPromise = {\n        dataType,\n        type,\n        path,\n        id: extracted.length,\n        matchIndex: ctx.match.index,\n        promiseState: value,\n      }\n      extracted.push(entry)\n    }\n\n    return value\n  })\n\n  return replacedLoaderData\n}\n\n// Right after hydration and before the first render, we need to rehydrate each match\n// This includes rehydrating the loaderData and also using the beforeLoadContext\n// to reconstruct any context that was serialized on the server\nexport function afterHydrate({ router }: { router: AnyRouter }) {\n  router.state.matches.forEach((match) => {\n    const route = router.looseRoutesById[match.routeId]!\n    const dMatch = window.__TSR__?.matches[match.index]\n    if (dMatch) {\n      const parentMatch = router.state.matches[match.index - 1]\n      const parentContext = parentMatch?.context ?? router.options.context ?? {}\n      if (dMatch.__beforeLoadContext) {\n        match.__beforeLoadContext = router.options.transformer.parse(\n          dMatch.__beforeLoadContext,\n        ) as any\n\n        match.context = {\n          ...parentContext,\n          ...match.context,\n          ...match.__beforeLoadContext,\n        }\n      }\n\n      if (dMatch.loaderData) {\n        match.loaderData = router.options.transformer.parse(dMatch.loaderData)\n      }\n\n      const extracted = dMatch.extracted\n\n      if (extracted) {\n        Object.entries(extracted).forEach(([_, ex]: any) => {\n          deepMutableSetByPath(match, ['loaderData', ...ex.path], ex.value)\n        })\n      }\n    }\n\n    const headFnContent = route.options.head?.({\n      matches: router.state.matches,\n      match,\n      params: match.params,\n      loaderData: match.loaderData,\n    })\n\n    Object.assign(match, {\n      meta: headFnContent?.meta,\n      links: headFnContent?.links,\n      scripts: headFnContent?.scripts,\n    })\n  })\n}\n\nexport function AfterEachMatch(props: { match: any; matchIndex: number }) {\n  const router = useRouter()\n\n  const fullMatch = router.state.matches[props.matchIndex]!\n\n  if (!router.isServer) {\n    return null\n  }\n\n  const extracted = (fullMatch as any).extracted as\n    | undefined\n    | Array<ExtractedEntry>\n\n  const [serializedBeforeLoadData, serializedLoaderData] = (\n    ['__beforeLoadContext', 'loaderData'] as const\n  ).map((dataType) => {\n    return extracted\n      ? extracted.reduce(\n          (acc: any, entry: ExtractedEntry) => {\n            if (entry.dataType !== dataType) {\n              return deepImmutableSetByPath(\n                acc,\n                ['temp', ...entry.path],\n                undefined,\n              )\n            }\n            return acc\n          },\n          { temp: fullMatch[dataType] },\n        ).temp\n      : fullMatch[dataType]\n  })\n\n  if (\n    serializedBeforeLoadData !== undefined ||\n    serializedLoaderData !== undefined ||\n    extracted?.length\n  ) {\n    const initCode = `__TSR__.initMatch(${jsesc(\n      {\n        index: props.matchIndex,\n        __beforeLoadContext: router.options.transformer.stringify(\n          serializedBeforeLoadData,\n        ),\n        loaderData: router.options.transformer.stringify(serializedLoaderData),\n        extracted: extracted\n          ? Object.fromEntries(\n              extracted.map((entry) => {\n                return [entry.id, pick(entry, ['type', 'path'])]\n              }),\n            )\n          : {},\n      },\n      {\n        isScriptContext: true,\n        wrap: true,\n        json: true,\n      },\n    )})`\n\n    return (\n      <>\n        <ScriptOnce children={initCode} />\n        {extracted\n          ? extracted.map((d) => {\n              if (d.type === 'stream') {\n                return <DehydrateStream key={d.id} entry={d} />\n              }\n\n              return <DehydratePromise key={d.id} entry={d} />\n            })\n          : null}\n      </>\n    )\n  }\n\n  return null\n}\n\nexport function replaceBy<T>(\n  obj: T,\n  cb: (value: any, path: Array<string>) => any,\n  path: Array<string> = [],\n): T {\n  if (isPlainArray(obj)) {\n    return obj.map((value, i) => replaceBy(value, cb, [...path, `${i}`])) as any\n  }\n\n  if (isPlainObject(obj)) {\n    // Do not allow objects with illegal\n    const newObj: any = {}\n\n    for (const key in obj) {\n      newObj[key] = replaceBy(obj[key], cb, [...path, key])\n    }\n\n    return newObj\n  }\n\n  // // Detect classes, functions, and other non-serializable objects\n  // // and return undefined. Exclude some known types that are serializable\n  // if (\n  //   typeof obj === 'function' ||\n  //   (typeof obj === 'object' &&\n  //     ![Object, Promise, ReadableStream].includes((obj as any)?.constructor))\n  // ) {\n  //   console.info(obj)\n  //   warning(false, `Non-serializable value ☝️ found at ${path.join('.')}`)\n  //   return undefined as any\n  // }\n\n  const newObj = cb(obj, path)\n\n  if (newObj !== obj) {\n    return newObj\n  }\n\n  return obj\n}\n\nfunction DehydratePromise({ entry }: { entry: ExtractedPromise }) {\n  return (\n    <div className=\"tsr-once\">\n      <React.Suspense fallback={null}>\n        <InnerDehydratePromise entry={entry} />\n      </React.Suspense>\n    </div>\n  )\n}\n\nfunction InnerDehydratePromise({ entry }: { entry: ExtractedPromise }) {\n  const router = useRouter()\n  if (entry.promiseState[TSR_DEFERRED_PROMISE].status === 'pending') {\n    throw entry.promiseState\n  }\n\n  const code = `__TSR__.resolvePromise(${jsesc(\n    { ...entry, value: entry.promiseState[TSR_DEFERRED_PROMISE] },\n    {\n      isScriptContext: true,\n      wrap: true,\n      json: true,\n    },\n  )})`\n\n  router.injectScript(code)\n\n  return <></>\n}\n\nfunction DehydrateStream({ entry }: { entry: ExtractedStream }) {\n  invariant(entry.streamState, 'StreamState should be defined')\n  const router = useRouter()\n\n  return (\n    <StreamChunks\n      streamState={entry.streamState}\n      children={(chunk) => {\n        const code = chunk\n          ? `__TSR__.matches[${entry.matchIndex}].extracted[${entry.id}].value.controller.enqueue(new TextEncoder().encode(${jsesc(\n              chunk.toString(),\n              {\n                isScriptContext: true,\n                wrap: true,\n                json: true,\n              },\n            )}))`\n          : `__TSR__.matches[${entry.matchIndex}].extracted[${entry.id}].value.controller.close()`\n\n        router.injectScript(code)\n\n        return <></>\n      }}\n    />\n  )\n}\n\n// Readable stream with state is a stream that has a promise that resolves to the next chunk\nfunction createStreamState({\n  stream,\n}: {\n  stream: ReadableStream\n}): StreamState {\n  const streamState: StreamState = {\n    promises: [],\n  }\n\n  const reader = stream.getReader()\n\n  const read = (index: number): any => {\n    streamState.promises[index] = createControlledPromise()\n\n    return reader.read().then(({ done, value }) => {\n      if (done) {\n        streamState.promises[index]!.resolve(null)\n        reader.releaseLock()\n        return\n      }\n\n      streamState.promises[index]!.resolve(value)\n\n      return read(index + 1)\n    })\n  }\n\n  read(0).catch((err: any) => {\n    console.error('stream read error', err)\n  })\n\n  return streamState\n}\n\nfunction StreamChunks({\n  streamState,\n  children,\n  __index = 0,\n}: {\n  streamState: StreamState\n  children: (chunk: string | null) => React.JSX.Element\n  __index?: number\n}) {\n  const promise = streamState.promises[__index]\n\n  if (!promise) {\n    return null\n  }\n\n  if (promise.status === 'pending') {\n    throw promise\n  }\n\n  const chunk = promise.value!\n\n  return (\n    <>\n      {children(chunk)}\n      <div className=\"tsr-once\">\n        <React.Suspense fallback={null}>\n          <StreamChunks\n            streamState={streamState}\n            __index={__index + 1}\n            children={children}\n          />\n        </React.Suspense>\n      </div>\n    </>\n  )\n}\n\nfunction deepImmutableSetByPath<T>(obj: T, path: Array<string>, value: any): T {\n  // immutable set by path retaining array and object references\n  if (path.length === 0) {\n    return value\n  }\n\n  const [key, ...rest] = path\n\n  if (Array.isArray(obj)) {\n    return obj.map((item, i) => {\n      if (i === Number(key)) {\n        return deepImmutableSetByPath(item, rest, value)\n      }\n      return item\n    }) as T\n  }\n\n  if (isPlainObject(obj)) {\n    return {\n      ...obj,\n      [key!]: deepImmutableSetByPath((obj as any)[key!], rest, value),\n    }\n  }\n\n  return obj\n}\n\nfunction deepMutableSetByPath<T>(obj: T, path: Array<string>, value: any) {\n  // mutable set by path retaining array and object references\n  if (path.length === 1) {\n    ;(obj as any)[path[0]!] = value\n  }\n\n  const [key, ...rest] = path\n\n  if (Array.isArray(obj)) {\n    deepMutableSetByPath(obj[Number(key)], rest, value)\n  } else if (isPlainObject(obj)) {\n    deepMutableSetByPath((obj as any)[key!], rest, value)\n  }\n}\n"],"names":["defer","useRouter","pick","jsxs","Fragment","jsx","ScriptOnce","isPlainArray","isPlainObject","newObj","React","TSR_DEFERRED_PROMISE","createControlledPromise"],"mappings":"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"}