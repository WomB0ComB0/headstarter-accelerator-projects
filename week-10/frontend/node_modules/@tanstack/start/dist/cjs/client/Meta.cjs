"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("react/jsx-runtime");
const React = require("react");
const reactRouter = require("@tanstack/react-router");
const jsesc = require("jsesc");
const reactCrossContext = require("@tanstack/react-cross-context");
const Asset = require("./Asset.cjs");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const React__namespace = /* @__PURE__ */ _interopNamespaceDefault(React);
const useMeta = () => {
  const router = reactRouter.useRouter();
  const routeMeta = reactRouter.useRouterState({
    select: (state) => {
      return state.matches.map((match) => match.meta).filter(Boolean);
    }
  });
  const meta = React__namespace.useMemo(() => {
    const resultMeta = [];
    const metaByAttribute = {};
    let title;
    [...routeMeta].reverse().forEach((metas) => {
      [...metas].reverse().forEach((m) => {
        if (!m) return;
        if (m.title) {
          if (!title) {
            title = {
              tag: "title",
              children: m.title
            };
          }
        } else {
          const attribute = m.name ?? m.property;
          if (attribute) {
            if (metaByAttribute[attribute]) {
              return;
            } else {
              metaByAttribute[attribute] = true;
            }
          }
          resultMeta.push({
            tag: "meta",
            attrs: {
              ...m
            }
          });
        }
      });
    });
    if (title) {
      resultMeta.push(title);
    }
    resultMeta.reverse();
    return resultMeta;
  }, [routeMeta]);
  const links = reactRouter.useRouterState({
    select: (state) => state.matches.map((match) => match.links).filter(Boolean).flat(1).map((link) => ({
      tag: "link",
      attrs: {
        ...link
      }
    })),
    structuralSharing: true
  });
  const preloadMeta = reactRouter.useRouterState({
    select: (state) => {
      const preloadMeta2 = [];
      state.matches.map((match) => router.looseRoutesById[match.routeId]).forEach(
        (route) => {
          var _a, _b, _c;
          return (_c = (_b = (_a = router.manifest) == null ? void 0 : _a.routes[route.id]) == null ? void 0 : _b.preloads) == null ? void 0 : _c.filter(Boolean).forEach((preload) => {
            preloadMeta2.push({
              tag: "link",
              attrs: {
                rel: "modulepreload",
                href: preload
              }
            });
          });
        }
      );
      return preloadMeta2;
    },
    structuralSharing: true
  });
  return uniqBy(
    [...meta, ...preloadMeta, ...links],
    (d) => {
      return JSON.stringify(d);
    }
  );
};
const useMetaElements = () => {
  const router = reactRouter.useRouter();
  const meta = useMeta();
  const dehydratedCtx = React__namespace.useContext(
    reactCrossContext.Context.get("TanStackRouterHydrationContext", {})
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    meta.map((asset, i) => /* @__PURE__ */ React.createElement(Asset.Asset, { ...asset, key: `tsr-meta-${JSON.stringify(asset)}` })),
    /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        reactRouter.ScriptOnce,
        {
          log: false,
          children: `__TSR__={matches:[],streamedValues:{},queue:[],runQueue:()=>{let e=!1;__TSR__.queue=__TSR__.queue.filter((_=>!_()||(e=!0,!1))),e&&__TSR__.runQueue()},initMatch:e=>{__TSR__.queue.push((()=>(__TSR__.matches[e.index]||(__TSR__.matches[e.index]=e,Object.entries(e.extracted).forEach((([e,_])=>{if("stream"===_.type){let e;_.value=new ReadableStream({start(_){e=_}}),_.value.controller=e}else if("promise"===_.type){let e,t;_.value=new Promise(((_,u)=>{e=_,t=u})),_.resolve=e,_.reject=t}}))),!0))),__TSR__.runQueue()},resolvePromise:e=>{__TSR__.queue.push((()=>{const _=__TSR__.matches[e.matchIndex];if(_){const t=_.extracted[e.id];if(t)return t.resolve(e.value.data),!0}return!1})),__TSR__.runQueue()},cleanScripts:()=>{document.querySelectorAll(".tsr-once").forEach((e=>{e.remove()}))}};`
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        reactRouter.ScriptOnce,
        {
          children: `__TSR__.dehydrated = ${jsesc(
            router.options.transformer.stringify(dehydratedCtx),
            {
              isScriptContext: true,
              wrap: true,
              json: true
            }
          )}`
        }
      )
    ] })
  ] });
};
const Meta = () => {
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: useMetaElements() });
};
function uniqBy(arr, fn) {
  const seen = /* @__PURE__ */ new Set();
  return arr.filter((item) => {
    const key = fn(item);
    if (seen.has(key)) {
      return false;
    }
    seen.add(key);
    return true;
  });
}
exports.Meta = Meta;
exports.useMeta = useMeta;
exports.useMetaElements = useMetaElements;
//# sourceMappingURL=Meta.cjs.map
