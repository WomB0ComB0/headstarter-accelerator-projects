import { jsxs, Fragment, jsx } from "react/jsx-runtime";
import * as React from "react";
import { useRouter, pick, ScriptOnce, isPlainArray, isPlainObject, TSR_DEFERRED_PROMISE, defer, createControlledPromise } from "@tanstack/react-router";
import jsesc from "jsesc";
import invariant from "tiny-invariant";
function serializeLoaderData(dataType, data, ctx) {
  if (!ctx.router.isServer) {
    return data;
  }
  ctx.match.extracted = ctx.match.extracted || [];
  const extracted = ctx.match.extracted;
  const replacedLoaderData = replaceBy(data, (value, path) => {
    const type = value instanceof ReadableStream ? "stream" : value instanceof Promise ? "promise" : void 0;
    if (type === "stream") {
      const [copy1, copy2] = value.tee();
      const entry = {
        dataType,
        type,
        path,
        id: extracted.length,
        matchIndex: ctx.match.index,
        streamState: createStreamState({ stream: copy2 })
      };
      extracted.push(entry);
      return copy1;
    } else if (type === "promise") {
      defer(value);
      const entry = {
        dataType,
        type,
        path,
        id: extracted.length,
        matchIndex: ctx.match.index,
        promiseState: value
      };
      extracted.push(entry);
    }
    return value;
  });
  return replacedLoaderData;
}
function afterHydrate({ router }) {
  router.state.matches.forEach((match) => {
    var _a, _b, _c;
    const route = router.looseRoutesById[match.routeId];
    const dMatch = (_a = window.__TSR__) == null ? void 0 : _a.matches[match.index];
    if (dMatch) {
      const parentMatch = router.state.matches[match.index - 1];
      const parentContext = (parentMatch == null ? void 0 : parentMatch.context) ?? router.options.context ?? {};
      if (dMatch.__beforeLoadContext) {
        match.__beforeLoadContext = router.options.transformer.parse(
          dMatch.__beforeLoadContext
        );
        match.context = {
          ...parentContext,
          ...match.context,
          ...match.__beforeLoadContext
        };
      }
      if (dMatch.loaderData) {
        match.loaderData = router.options.transformer.parse(dMatch.loaderData);
      }
      const extracted = dMatch.extracted;
      if (extracted) {
        Object.entries(extracted).forEach(([_, ex]) => {
          deepMutableSetByPath(match, ["loaderData", ...ex.path], ex.value);
        });
      }
    }
    const headFnContent = (_c = (_b = route.options).head) == null ? void 0 : _c.call(_b, {
      matches: router.state.matches,
      match,
      params: match.params,
      loaderData: match.loaderData
    });
    Object.assign(match, {
      meta: headFnContent == null ? void 0 : headFnContent.meta,
      links: headFnContent == null ? void 0 : headFnContent.links,
      scripts: headFnContent == null ? void 0 : headFnContent.scripts
    });
  });
}
function AfterEachMatch(props) {
  const router = useRouter();
  const fullMatch = router.state.matches[props.matchIndex];
  if (!router.isServer) {
    return null;
  }
  const extracted = fullMatch.extracted;
  const [serializedBeforeLoadData, serializedLoaderData] = ["__beforeLoadContext", "loaderData"].map((dataType) => {
    return extracted ? extracted.reduce(
      (acc, entry) => {
        if (entry.dataType !== dataType) {
          return deepImmutableSetByPath(
            acc,
            ["temp", ...entry.path],
            void 0
          );
        }
        return acc;
      },
      { temp: fullMatch[dataType] }
    ).temp : fullMatch[dataType];
  });
  if (serializedBeforeLoadData !== void 0 || serializedLoaderData !== void 0 || (extracted == null ? void 0 : extracted.length)) {
    const initCode = `__TSR__.initMatch(${jsesc(
      {
        index: props.matchIndex,
        __beforeLoadContext: router.options.transformer.stringify(
          serializedBeforeLoadData
        ),
        loaderData: router.options.transformer.stringify(serializedLoaderData),
        extracted: extracted ? Object.fromEntries(
          extracted.map((entry) => {
            return [entry.id, pick(entry, ["type", "path"])];
          })
        ) : {}
      },
      {
        isScriptContext: true,
        wrap: true,
        json: true
      }
    )})`;
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx(ScriptOnce, { children: initCode }),
      extracted ? extracted.map((d) => {
        if (d.type === "stream") {
          return /* @__PURE__ */ jsx(DehydrateStream, { entry: d }, d.id);
        }
        return /* @__PURE__ */ jsx(DehydratePromise, { entry: d }, d.id);
      }) : null
    ] });
  }
  return null;
}
function replaceBy(obj, cb, path = []) {
  if (isPlainArray(obj)) {
    return obj.map((value, i) => replaceBy(value, cb, [...path, `${i}`]));
  }
  if (isPlainObject(obj)) {
    const newObj2 = {};
    for (const key in obj) {
      newObj2[key] = replaceBy(obj[key], cb, [...path, key]);
    }
    return newObj2;
  }
  const newObj = cb(obj, path);
  if (newObj !== obj) {
    return newObj;
  }
  return obj;
}
function DehydratePromise({ entry }) {
  return /* @__PURE__ */ jsx("div", { className: "tsr-once", children: /* @__PURE__ */ jsx(React.Suspense, { fallback: null, children: /* @__PURE__ */ jsx(InnerDehydratePromise, { entry }) }) });
}
function InnerDehydratePromise({ entry }) {
  const router = useRouter();
  if (entry.promiseState[TSR_DEFERRED_PROMISE].status === "pending") {
    throw entry.promiseState;
  }
  const code = `__TSR__.resolvePromise(${jsesc(
    { ...entry, value: entry.promiseState[TSR_DEFERRED_PROMISE] },
    {
      isScriptContext: true,
      wrap: true,
      json: true
    }
  )})`;
  router.injectScript(code);
  return /* @__PURE__ */ jsx(Fragment, {});
}
function DehydrateStream({ entry }) {
  invariant(entry.streamState, "StreamState should be defined");
  const router = useRouter();
  return /* @__PURE__ */ jsx(
    StreamChunks,
    {
      streamState: entry.streamState,
      children: (chunk) => {
        const code = chunk ? `__TSR__.matches[${entry.matchIndex}].extracted[${entry.id}].value.controller.enqueue(new TextEncoder().encode(${jsesc(
          chunk.toString(),
          {
            isScriptContext: true,
            wrap: true,
            json: true
          }
        )}))` : `__TSR__.matches[${entry.matchIndex}].extracted[${entry.id}].value.controller.close()`;
        router.injectScript(code);
        return /* @__PURE__ */ jsx(Fragment, {});
      }
    }
  );
}
function createStreamState({
  stream
}) {
  const streamState = {
    promises: []
  };
  const reader = stream.getReader();
  const read = (index) => {
    streamState.promises[index] = createControlledPromise();
    return reader.read().then(({ done, value }) => {
      if (done) {
        streamState.promises[index].resolve(null);
        reader.releaseLock();
        return;
      }
      streamState.promises[index].resolve(value);
      return read(index + 1);
    });
  };
  read(0).catch((err) => {
    console.error("stream read error", err);
  });
  return streamState;
}
function StreamChunks({
  streamState,
  children,
  __index = 0
}) {
  const promise = streamState.promises[__index];
  if (!promise) {
    return null;
  }
  if (promise.status === "pending") {
    throw promise;
  }
  const chunk = promise.value;
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    children(chunk),
    /* @__PURE__ */ jsx("div", { className: "tsr-once", children: /* @__PURE__ */ jsx(React.Suspense, { fallback: null, children: /* @__PURE__ */ jsx(
      StreamChunks,
      {
        streamState,
        __index: __index + 1,
        children
      }
    ) }) })
  ] });
}
function deepImmutableSetByPath(obj, path, value) {
  if (path.length === 0) {
    return value;
  }
  const [key, ...rest] = path;
  if (Array.isArray(obj)) {
    return obj.map((item, i) => {
      if (i === Number(key)) {
        return deepImmutableSetByPath(item, rest, value);
      }
      return item;
    });
  }
  if (isPlainObject(obj)) {
    return {
      ...obj,
      [key]: deepImmutableSetByPath(obj[key], rest, value)
    };
  }
  return obj;
}
function deepMutableSetByPath(obj, path, value) {
  if (path.length === 1) {
    obj[path[0]] = value;
  }
  const [key, ...rest] = path;
  if (Array.isArray(obj)) {
    deepMutableSetByPath(obj[Number(key)], rest, value);
  } else if (isPlainObject(obj)) {
    deepMutableSetByPath(obj[key], rest, value);
  }
}
export {
  AfterEachMatch,
  afterHydrate,
  replaceBy,
  serializeLoaderData
};
//# sourceMappingURL=serialization.js.map
