import { O } from '@eslint-react/eff';
import * as _typescript_eslint_scope_manager from '@typescript-eslint/scope-manager';
import { Scope, Variable, ScopeManager } from '@typescript-eslint/scope-manager';
import { TSESTree } from '@typescript-eslint/types';

declare const findVariable: {
    (initialScope: Scope): (nameOrNode: string | TSESTree.Identifier) => O.Option<Variable>;
    (nameOrNode: string | TSESTree.Identifier, initialScope: Scope): O.Option<Variable>;
};

declare function getChidScopes(scope: Scope, prev?: readonly Scope[]): readonly Scope[];

declare function getScope(node: TSESTree.Node, scopeManager: ScopeManager): _typescript_eslint_scope_manager.Scope | null;

declare function getStaticValue(node: TSESTree.Node, initialScope: Scope): O.Option<unknown>;

declare function getVariableDeclaratorID(node: TSESTree.Node, prev?: TSESTree.Node): O.Option<TSESTree.BindingName | TSESTree.Expression>;

/**
 * Get the init node of the nth definition of a variable
 * @param at The index number of def in defs
 * @returns A function that takes a variable and returns the init node of the nth definition of that variable
 */
declare function getVariableNode(at: number): (variable: Variable) => O.Option<TSESTree.ClassDeclaration | TSESTree.ClassDeclarationWithName | TSESTree.ClassDeclarationWithOptionalName | TSESTree.Expression | TSESTree.FunctionDeclaration | TSESTree.FunctionDeclarationWithName | TSESTree.FunctionDeclarationWithOptionalName>;

/**
 * Get all variables from the given scope up to the global scope
 * @param initialScope The scope to start from
 * @returns All variables from the given scope up to the global scope
 */
declare function getVariables(initialScope: Scope): Variable[];

/**
 * Check if an identifier is initialized from the given source
 * @param name The top-level identifier's name
 * @param source The import source to check against
 * @param initialScope Initial scope to search for the identifier
 * @returns Whether the identifier is initialized from the given source
 */
declare function isInitializedFromSource(name: string, source: string, initialScope: Scope): boolean;

/**
 * Determines whether node value equals to another node value
 * @param a node to compare
 * @param b node to compare
 * @param initialScopes initial scopes of the two nodes
 * @returns `true` if node value equal
 */
declare function isNodeValueEqual(a: TSESTree.Node, b: TSESTree.Node, initialScopes: [
    aScope: Scope,
    bScope: Scope
]): boolean;

type ValueConstruction = {
    kind: "None";
    node: TSESTree.Node;
} | {
    kind: "ArrayExpression";
    node: TSESTree.ArrayExpression;
} | {
    kind: "CallExpression";
    node: TSESTree.CallExpression;
} | {
    kind: "ClassExpression";
    node: TSESTree.ClassExpression;
} | {
    kind: "FunctionDeclaration";
    node: TSESTree.FunctionDeclaration;
} | {
    kind: "FunctionExpression";
    node: TSESTree.FunctionExpression | TSESTree.ArrowFunctionExpression;
} | {
    kind: "JSXElement";
    node: TSESTree.JSXElement | TSESTree.JSXFragment;
} | {
    kind: "NewExpression";
    node: TSESTree.NewExpression;
} | {
    kind: "ObjectExpression";
    node: TSESTree.ObjectExpression;
} | {
    kind: "RegExpLiteral";
    node: TSESTree.RegExpLiteral;
};
declare const ValueConstructionHint: {
    None: bigint;
    StrictCallExpression: bigint;
};
/**
 * Get a function that detects the construction of a given node.
 * @param node The AST node to detect the construction of
 * @param initialScope The initial scope to use when detecting the construction
 * @param hint The hint to use when detecting the construction
 * @returns A function that detects the construction of a given node
 */
declare function getValueConstruction(node: TSESTree.Node, initialScope: Scope, hint?: bigint): ValueConstruction;

export { type ValueConstruction, ValueConstructionHint, findVariable, getChidScopes, getScope, getStaticValue, getValueConstruction, getVariableDeclaratorID, getVariableNode, getVariables, isInitializedFromSource, isNodeValueEqual };
