'use strict';

var eff = require('@eslint-react/eff');
var ASTUtils = require('@typescript-eslint/utils/ast-utils');
var types = require('@typescript-eslint/types');
var AST3 = require('@eslint-react/ast');
var scopeManager = require('@typescript-eslint/scope-manager');
var tsPattern = require('ts-pattern');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var ASTUtils__namespace = /*#__PURE__*/_interopNamespace(ASTUtils);
var AST3__namespace = /*#__PURE__*/_interopNamespace(AST3);

// src/find-variable.ts
var findVariable2 = eff.F.dual(2, (nameOrNode, initialScope) => {
  return eff.O.fromNullable(ASTUtils__namespace.findVariable(initialScope, nameOrNode));
});

// src/get-child-scopes.ts
function getChidScopes(scope, prev = []) {
  return [scope, ...scope.childScopes.reduce((acc, prev2) => getChidScopes(prev2, [...acc, prev2]), prev)];
}
function getScope(node, scopeManager) {
  const { type, parent } = node;
  const inner = type !== types.AST_NODE_TYPES.Program;
  const scope = scopeManager.acquire(node, inner);
  if (scope) return scope;
  if (parent) return getScope(parent, scopeManager);
  return null;
}
function getStaticValue2(node, initialScope) {
  return eff.F.pipe(
    eff.O.fromNullable(ASTUtils__namespace.getStaticValue(node, initialScope)),
    eff.O.map((v) => v.value)
  );
}
function getVariableDeclaratorID(node, prev) {
  switch (true) {
    case (node.type === types.AST_NODE_TYPES.VariableDeclarator && node.init === prev):
      return eff.O.some(node.id);
    case (node.type === types.AST_NODE_TYPES.AssignmentExpression && node.right === prev):
      return eff.O.some(node.left);
    case (node.type === types.AST_NODE_TYPES.BlockStatement || node.type === types.AST_NODE_TYPES.Program || node.parent === node):
      return eff.O.none();
    default:
      return getVariableDeclaratorID(node.parent, node);
  }
}
function getVariableNode(at) {
  return (variable) => {
    return eff.F.pipe(
      eff.O.some(variable),
      eff.O.flatMapNullable((v) => v.defs.at(at)),
      eff.O.flatMapNullable((def) => {
        switch (true) {
          case (def.type === scopeManager.DefinitionType.FunctionName && def.node.type === types.AST_NODE_TYPES.FunctionDeclaration):
            return def.node;
          case (def.type === scopeManager.DefinitionType.ClassName && def.node.type === types.AST_NODE_TYPES.ClassDeclaration):
            return def.node;
          case (def.type === scopeManager.DefinitionType.Parameter && AST3__namespace.isFunction(def.node)):
            return def.node;
          case ("init" in def.node && def.node.init && !("declarations" in def.node.init)):
            return def.node.init;
          default:
            return null;
        }
      })
    );
  };
}
function getVariables(initialScope) {
  let scope = initialScope;
  const variables = [...scope.variables];
  while (scope.type !== scopeManager.ScopeType.global) {
    scope = scope.upper;
    variables.push(...scope.variables);
  }
  return variables.reverse();
}
function isInitializedFromSource(name, source, initialScope) {
  const latestDef = eff.O.flatMapNullable(findVariable2(name, initialScope), (v) => v.defs.at(-1));
  if (eff.O.isNone(latestDef)) return false;
  const { node, parent } = latestDef.value;
  if (node.type === types.AST_NODE_TYPES.VariableDeclarator && node.init) {
    const { init } = node;
    if (init.type === types.AST_NODE_TYPES.MemberExpression && init.object.type === types.AST_NODE_TYPES.Identifier) {
      return isInitializedFromSource(init.object.name, source, initialScope);
    }
    if (init.type === types.AST_NODE_TYPES.Identifier) {
      return isInitializedFromSource(init.name, source, initialScope);
    }
    return eff.F.pipe(
      getRequireExpressionArguments(init),
      eff.O.flatMapNullable((args) => args[0]),
      eff.O.filter(AST3__namespace.isStringLiteral),
      // check for: `require('source')` or `require('source/...')`
      eff.O.exists((arg) => arg.value === source || arg.value.startsWith(`${source}/`))
    );
  }
  return tsPattern.isMatching({ type: "ImportDeclaration", source: { value: source } }, parent);
}
function getRequireExpressionArguments(node) {
  switch (true) {
    // require('source')
    case (node.type === types.AST_NODE_TYPES.CallExpression && node.callee.type === types.AST_NODE_TYPES.Identifier && node.callee.name === "require"): {
      return eff.O.some(node.arguments);
    }
    // require('source').variable
    case node.type === types.AST_NODE_TYPES.MemberExpression: {
      return getRequireExpressionArguments(node.object);
    }
  }
  return eff.O.none();
}
var thisBlockTypes = [
  types.AST_NODE_TYPES.FunctionDeclaration,
  types.AST_NODE_TYPES.FunctionExpression,
  types.AST_NODE_TYPES.ClassBody,
  types.AST_NODE_TYPES.Program
];
function isNodeValueEqual(a, b, initialScopes) {
  const [aScope, bScope] = initialScopes;
  switch (true) {
    case a === b: {
      return true;
    }
    case (a.type === types.AST_NODE_TYPES.Literal && b.type === types.AST_NODE_TYPES.Literal): {
      return a.value === b.value;
    }
    case (a.type === types.AST_NODE_TYPES.TemplateElement && b.type === types.AST_NODE_TYPES.TemplateElement): {
      return a.value.cooked === b.value.cooked;
    }
    case (a.type === types.AST_NODE_TYPES.Identifier && b.type === types.AST_NODE_TYPES.Identifier): {
      const aVar = findVariable2(a, aScope);
      const bVar = findVariable2(b, bScope);
      const aVarNode = eff.O.flatMap(aVar, getVariableNode(0));
      const bVarNode = eff.O.flatMap(bVar, getVariableNode(0));
      const aVarNodeParent = eff.O.flatMapNullable(aVarNode, (n) => n.parent);
      const bVarNodeParent = eff.O.flatMapNullable(bVarNode, (n) => n.parent);
      const aDef = eff.O.flatMapNullable(aVar, (v) => v.defs.at(0));
      const bDef = eff.O.flatMapNullable(bVar, (v) => v.defs.at(0));
      const aDefParentParent = eff.O.flatMapNullable(aDef, (d) => d.parent?.parent);
      const bDefParentParent = eff.O.flatMapNullable(bDef, (d) => d.parent?.parent);
      switch (true) {
        case (eff.O.exists(aVarNodeParent, AST3__namespace.is(types.AST_NODE_TYPES.CallExpression)) && eff.O.exists(bVarNodeParent, AST3__namespace.is(types.AST_NODE_TYPES.CallExpression)) && eff.O.exists(aVarNode, AST3__namespace.isFunction) && eff.O.exists(bVarNode, AST3__namespace.isFunction)): {
          const hasSameCallee = eff.F.pipe(
            eff.O.Do,
            eff.O.bind("aCallee", () => eff.O.map(aVarNodeParent, (n) => n.callee)),
            eff.O.bind("bCallee", () => eff.O.map(bVarNodeParent, (n) => n.callee)),
            eff.O.exists(({ aCallee, bCallee }) => AST3__namespace.isNodeEqual(aCallee, bCallee))
          );
          if (!hasSameCallee) return false;
          return eff.F.pipe(
            eff.O.Do,
            eff.O.bind("aParams", () => eff.O.map(aVarNode, (n) => n.params)),
            eff.O.bind("bParams", () => eff.O.map(bVarNode, (n) => n.params)),
            eff.O.let("aPos", ({ aParams }) => aParams.findIndex(AST3__namespace.isNodeEqual(a))),
            eff.O.let("bPos", ({ bParams }) => bParams.findIndex(AST3__namespace.isNodeEqual(b))),
            eff.O.filter(({ aPos, bPos }) => aPos !== -1 && bPos !== -1),
            eff.O.exists(({ aPos, bPos }) => aPos === bPos)
          );
        }
        case (eff.O.exists(aDefParentParent, AST3__namespace.is(types.AST_NODE_TYPES.ForOfStatement)) && eff.O.exists(bDefParentParent, AST3__namespace.is(types.AST_NODE_TYPES.ForOfStatement))): {
          return eff.F.pipe(
            eff.O.Do,
            eff.O.bind("aLeft", () => eff.O.map(aDefParentParent, (d) => d.left)),
            eff.O.bind("bLeft", () => eff.O.map(bDefParentParent, (d) => d.left)),
            eff.O.filter(({ aLeft, bLeft }) => aLeft.type === bLeft.type),
            eff.O.bind("aRight", () => eff.O.map(aDefParentParent, (d) => d.right)),
            eff.O.bind("bRight", () => eff.O.map(bDefParentParent, (d) => d.right)),
            eff.O.exists(({ aRight, bRight }) => AST3__namespace.isNodeEqual(aRight, bRight))
          );
        }
        default: {
          return eff.O.isSome(aVar) && eff.O.isSome(bVar) && aVar.value === bVar.value;
        }
      }
    }
    case (a.type === types.AST_NODE_TYPES.MemberExpression && b.type === types.AST_NODE_TYPES.MemberExpression): {
      return AST3__namespace.isNodeEqual(a.property, b.property) && isNodeValueEqual(a.object, b.object, initialScopes);
    }
    case (a.type === types.AST_NODE_TYPES.ThisExpression && b.type === types.AST_NODE_TYPES.ThisExpression): {
      if (aScope.block === bScope.block) return true;
      return eff.F.pipe(
        eff.O.Do,
        eff.O.bind("aFunction", () => AST3__namespace.findParentNode(a, AST3__namespace.isOneOf(thisBlockTypes))),
        eff.O.bind("bFunction", () => AST3__namespace.findParentNode(b, AST3__namespace.isOneOf(thisBlockTypes))),
        eff.O.exists(({ aFunction, bFunction }) => aFunction === bFunction)
      );
    }
    default: {
      return eff.F.pipe(
        eff.O.Do,
        eff.O.bind("aStatic", () => getStaticValue2(a, aScope)),
        eff.O.bind("bStatic", () => getStaticValue2(b, bScope)),
        eff.O.exists(({ aStatic, bStatic }) => aStatic === bStatic)
      );
    }
  }
}
var ValueConstructionHint = {
  None: 0n,
  StrictCallExpression: 1n << 0n
};
function getValueConstruction(node, initialScope, hint = ValueConstructionHint.None) {
  switch (node.type) {
    case types.AST_NODE_TYPES.JSXElement:
    case types.AST_NODE_TYPES.JSXFragment: {
      return { kind: "JSXElement", node };
    }
    case types.AST_NODE_TYPES.ArrayExpression: {
      return { kind: "ArrayExpression", node };
    }
    case types.AST_NODE_TYPES.ObjectExpression: {
      return { kind: "ObjectExpression", node };
    }
    case types.AST_NODE_TYPES.ClassExpression: {
      return { kind: "ClassExpression", node };
    }
    case types.AST_NODE_TYPES.NewExpression: {
      return { kind: "NewExpression", node };
    }
    case types.AST_NODE_TYPES.FunctionExpression:
    case types.AST_NODE_TYPES.ArrowFunctionExpression: {
      return { kind: "FunctionExpression", node };
    }
    case types.AST_NODE_TYPES.CallExpression: {
      if (hint & ValueConstructionHint.StrictCallExpression) {
        return { kind: "CallExpression", node };
      }
      return { kind: "None", node };
    }
    case types.AST_NODE_TYPES.MemberExpression: {
      if (!("object" in node)) return { kind: "None", node };
      return getValueConstruction(node.object, initialScope, hint);
    }
    case types.AST_NODE_TYPES.AssignmentExpression:
    case types.AST_NODE_TYPES.AssignmentPattern: {
      if (!("right" in node)) return { kind: "None", node };
      return getValueConstruction(node.right, initialScope, hint);
    }
    case types.AST_NODE_TYPES.LogicalExpression: {
      const lvc = getValueConstruction(node.left, initialScope, hint);
      if (lvc.kind !== "None") return lvc;
      return getValueConstruction(node.right, initialScope, hint);
    }
    case types.AST_NODE_TYPES.ConditionalExpression: {
      const cvc = getValueConstruction(node.consequent, initialScope, hint);
      if (cvc.kind !== "None") return cvc;
      return getValueConstruction(node.alternate, initialScope, hint);
    }
    case types.AST_NODE_TYPES.Identifier: {
      if (!("name" in node && eff.isString(node.name))) return { kind: "None", node };
      const construction = eff.F.pipe(
        eff.O.fromNullable(initialScope.set.get(node.name)),
        eff.O.flatMap(getVariableNode(-1)),
        eff.O.map((node2) => getValueConstruction(node2, initialScope, hint)),
        eff.O.filter((vc) => vc.kind !== "None")
      );
      if (eff.O.isNone(construction)) return { kind: "None", node };
      return {
        ...construction.value
      };
    }
    case types.AST_NODE_TYPES.Literal: {
      if ("regex" in node) {
        return { kind: "RegExpLiteral", node };
      }
      return { kind: "None", node };
    }
    default: {
      if (!("expression" in node && eff.isObject(node.expression))) {
        return { kind: "None", node };
      }
      return getValueConstruction(node.expression, initialScope, hint);
    }
  }
}

exports.ValueConstructionHint = ValueConstructionHint;
exports.findVariable = findVariable2;
exports.getChidScopes = getChidScopes;
exports.getScope = getScope;
exports.getStaticValue = getStaticValue2;
exports.getValueConstruction = getValueConstruction;
exports.getVariableDeclaratorID = getVariableDeclaratorID;
exports.getVariableNode = getVariableNode;
exports.getVariables = getVariables;
exports.isInitializedFromSource = isInitializedFromSource;
exports.isNodeValueEqual = isNodeValueEqual;
