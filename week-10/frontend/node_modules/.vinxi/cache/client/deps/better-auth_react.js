import {
  require_react
} from "./chunk-CEHRAWMB.js";
import {
  __toESM
} from "./chunk-QWN5BXRD.js";

// node_modules/better-auth/dist/react.js
var import_react = __toESM(require_react());
var me = Object.defineProperty;
var ge = Object.defineProperties;
var ve = Object.getOwnPropertyDescriptors;
var $ = Object.getOwnPropertySymbols;
var Se = Object.prototype.hasOwnProperty;
var be = Object.prototype.propertyIsEnumerable;
var z = (e, t, r) => t in e ? me(e, t, { enumerable: true, configurable: true, writable: true, value: r }) : e[t] = r;
var v = (e, t) => {
  for (var r in t || (t = {})) Se.call(t, r) && z(e, r, t[r]);
  if ($) for (var r of $(t)) be.call(t, r) && z(e, r, t[r]);
  return e;
};
var R = (e, t) => ge(e, ve(t));
var Re = class extends Error {
  constructor(e, t, r) {
    super(t || e.toString(), { cause: r }), this.status = e, this.statusText = t, this.error = r;
  }
};
var Te = async (e, t) => {
  var r, n, o, a, s, c;
  let u = t || {}, i = { onRequest: [t == null ? void 0 : t.onRequest], onResponse: [t == null ? void 0 : t.onResponse], onSuccess: [t == null ? void 0 : t.onSuccess], onError: [t == null ? void 0 : t.onError], onRetry: [t == null ? void 0 : t.onRetry] };
  if (!t || !(t == null ? void 0 : t.plugins)) return { url: e, options: u, hooks: i };
  for (let l of (t == null ? void 0 : t.plugins) || []) {
    if (l.init) {
      let f = await ((r = l.init) == null ? void 0 : r.call(l, e.toString(), t));
      u = f.options || u, e = f.url;
    }
    i.onRequest.push((n = l.hooks) == null ? void 0 : n.onRequest), i.onResponse.push((o = l.hooks) == null ? void 0 : o.onResponse), i.onSuccess.push((a = l.hooks) == null ? void 0 : a.onSuccess), i.onError.push((s = l.hooks) == null ? void 0 : s.onError), i.onRetry.push((c = l.hooks) == null ? void 0 : c.onRetry);
  }
  return { url: e, options: u, hooks: i };
};
var K = class {
  constructor(e) {
    this.options = e;
  }
  shouldAttemptRetry(e, t) {
    return this.options.shouldRetry ? Promise.resolve(e < this.options.attempts && this.options.shouldRetry(t)) : Promise.resolve(e < this.options.attempts);
  }
  getDelay() {
    return this.options.delay;
  }
};
var Pe = class {
  constructor(e) {
    this.options = e;
  }
  shouldAttemptRetry(e, t) {
    return this.options.shouldRetry ? Promise.resolve(e < this.options.attempts && this.options.shouldRetry(t)) : Promise.resolve(e < this.options.attempts);
  }
  getDelay(e) {
    return Math.min(this.options.maxDelay, this.options.baseDelay * 2 ** e);
  }
};
function Oe(e) {
  if (typeof e == "number") return new K({ type: "linear", attempts: e, delay: 1e3 });
  switch (e.type) {
    case "linear":
      return new K(e);
    case "exponential":
      return new Pe(e);
    default:
      throw new Error("Invalid retry strategy");
  }
}
var we = (e) => {
  let t = {}, r = (n) => typeof n == "function" ? n() : n;
  if (e == null ? void 0 : e.auth) {
    if (e.auth.type === "Bearer") {
      let n = r(e.auth.token);
      if (!n) return t;
      t.authorization = `Bearer ${n}`;
    } else if (e.auth.type === "Basic") {
      let n = r(e.auth.username), o = r(e.auth.password);
      if (!n || !o) return t;
      t.authorization = `Basic ${btoa(`${n}:${o}`)}`;
    } else if (e.auth.type === "Custom") {
      let n = r(e.auth.value);
      if (!n) return t;
      t.authorization = `${r(e.auth.prefix)} ${n}`;
    }
  }
  return t;
};
var X = ["get", "post", "put", "patch", "delete"];
var _e = (e) => ({ id: "apply-schema", name: "Apply Schema", version: "1.0.0", async init(t, r) {
  var n, o, a, s;
  let c = ((o = (n = e.plugins) == null ? void 0 : n.find((u) => {
    var i;
    return (i = u.schema) != null && i.config ? t.startsWith(u.schema.config.baseURL || "") || t.startsWith(u.schema.config.prefix || "") : false;
  })) == null ? void 0 : o.schema) || e.schema;
  if (c) {
    let u = t;
    (a = c.config) != null && a.prefix && u.startsWith(c.config.prefix) && (u = u.replace(c.config.prefix, ""), c.config.baseURL && (t = t.replace(c.config.prefix, c.config.baseURL))), (s = c.config) != null && s.baseURL && u.startsWith(c.config.baseURL) && (u = u.replace(c.config.baseURL, ""));
    let i = c.schema[u];
    if (i) {
      let l = R(v({}, r), { method: i.method, output: i.output });
      return (r == null ? void 0 : r.disableValidation) || (l = R(v({}, l), { body: i.input ? i.input.parse(r == null ? void 0 : r.body) : r == null ? void 0 : r.body, params: i.params ? i.params.parse(r == null ? void 0 : r.params) : r == null ? void 0 : r.params, query: i.query ? i.query.parse(r == null ? void 0 : r.query) : r == null ? void 0 : r.query })), { url: t, options: l };
    }
  }
  return { url: t, options: r };
} });
var Z = (e) => {
  async function t(r, n) {
    let o = R(v(v({}, e), n), { plugins: [...(e == null ? void 0 : e.plugins) || [], _e(e || {})] });
    if (e == null ? void 0 : e.catchAllError) try {
      return await M(r, o);
    } catch (a) {
      return { data: null, error: { status: 500, statusText: "Fetch Error", message: "Fetch related error. Captured by catchAllError option. See error property for more details.", error: a } };
    }
    return await M(r, o);
  }
  return t;
};
var Ee = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
function xe(e) {
  let t = e.headers.get("content-type"), r = /* @__PURE__ */ new Set(["image/svg", "application/xml", "application/xhtml", "application/html"]);
  if (!t) return "json";
  let n = t.split(";").shift() || "";
  return Ee.test(n) ? "json" : r.has(n) || n.startsWith("text/") ? "text" : "blob";
}
function Ae(e) {
  try {
    return JSON.parse(e), true;
  } catch {
    return false;
  }
}
function ee(e) {
  if (e === void 0) return false;
  let t = typeof e;
  return t === "string" || t === "number" || t === "boolean" || t === null ? true : t !== "object" ? false : Array.isArray(e) ? true : e.buffer ? false : e.constructor && e.constructor.name === "Object" || typeof e.toJSON == "function";
}
function Q(e) {
  try {
    return JSON.parse(e);
  } catch {
    return e;
  }
}
function Y(e) {
  return typeof e == "function";
}
function Ue(e) {
  if (e == null ? void 0 : e.customFetchImpl) return e.customFetchImpl;
  if (typeof globalThis < "u" && Y(globalThis.fetch)) return globalThis.fetch;
  if (typeof window < "u" && Y(window.fetch)) return window.fetch;
  throw new Error("No fetch implementation found");
}
function Le(e) {
  let t = new Headers(e == null ? void 0 : e.headers), r = we(e);
  for (let [n, o] of Object.entries(r || {})) t.set(n, o);
  if (!t.has("content-type")) {
    let n = Ie(e == null ? void 0 : e.body);
    n && t.set("content-type", n);
  }
  return t;
}
function Ie(e) {
  return ee(e) ? "application/json" : null;
}
function ke(e) {
  if (!(e == null ? void 0 : e.body)) return null;
  let t = new Headers(e == null ? void 0 : e.headers);
  return ee(e.body) && !t.has("content-type") ? JSON.stringify(e.body) : e.body;
}
function Ne(e, t) {
  var r;
  if (t == null ? void 0 : t.method) return t.method.toUpperCase();
  if (e.startsWith("@")) {
    let n = (r = e.split("@")[1]) == null ? void 0 : r.split("/")[0];
    return X.includes(n) ? n.toUpperCase() : (t == null ? void 0 : t.body) ? "POST" : "GET";
  }
  return (t == null ? void 0 : t.body) ? "POST" : "GET";
}
function Ce(e, t) {
  let r;
  return !(e == null ? void 0 : e.signal) && (e == null ? void 0 : e.timeout) && (r = setTimeout(() => t == null ? void 0 : t.abort(), e == null ? void 0 : e.timeout)), { abortTimeout: r, clearTimeout: () => {
    r && clearTimeout(r);
  } };
}
function Be(e, t) {
  let { baseURL: r, params: n, query: o } = t || { query: {}, params: {}, baseURL: "" }, a = e.startsWith("http") ? e.split("/").slice(0, 3).join("/") : r;
  if (!a) throw new TypeError(`Invalid URL ${e}. Are you passing in a relative URL but not setting the baseURL?`);
  if (e.startsWith("@")) {
    let f = e.toString().split("@")[1].split("/")[0];
    X.includes(f) && (e = e.replace(`@${f}/`, "/"));
  }
  a.endsWith("/") || (a += "/");
  let [s, c] = e.replace(a, "").split("?"), u = new URLSearchParams(c);
  for (let [f, d] of Object.entries(o || {})) u.set(f, String(d));
  if (n) if (Array.isArray(n)) {
    let f = s.split("/").filter((d) => d.startsWith(":"));
    for (let [d, p] of f.entries()) {
      let b = n[d];
      s = s.replace(p, b);
    }
  } else for (let [f, d] of Object.entries(n)) s = s.replace(`:${f}`, String(d));
  s = s.split("/").map(encodeURIComponent).join("/"), s.startsWith("/") && (s = s.slice(1));
  let i = u.size > 0 ? `?${u}`.replace(/\+/g, "%20") : "";
  return new URL(`${s}${i}`, a);
}
var M = async (e, t) => {
  var r, n, o, a, s, c, u, i;
  let { hooks: l, url: f, options: d } = await Te(e, t), p = Ue(d), b = new AbortController(), k = (r = d.signal) != null ? r : b.signal, _ = Be(f, d), N = ke(d), A = Le(d), E = Ne(f, d), h = R(v({}, d), { url: _, headers: A, body: N, method: E, signal: k });
  for (let g of l.onRequest) if (g) {
    let m = await g(h);
    m instanceof Object && (h = m);
  }
  ("pipeTo" in h && typeof h.pipeTo == "function" || typeof ((n = t == null ? void 0 : t.body) == null ? void 0 : n.pipe) == "function") && ("duplex" in h || (h.duplex = "half"));
  let { clearTimeout: j } = Ce(d, b), y = await p(h.url, h);
  j();
  let J = { response: y, request: h };
  for (let g of l.onResponse) if (g) {
    let m = await g(R(v({}, J), { response: (o = t == null ? void 0 : t.hookOptions) != null && o.cloneResponse ? y.clone() : y }));
    m instanceof Response ? y = m : m instanceof Object && (y = m.response);
  }
  if (y.ok) {
    if (!(h.method !== "HEAD")) return { data: "", error: null };
    let m = xe(y), T = { data: "", response: y, request: h };
    if (m === "json" || m === "text") {
      let P = await y.text(), he = await ((a = h.jsonParser) != null ? a : Q)(P);
      T.data = he;
    } else T.data = await y[m]();
    (h == null ? void 0 : h.output) && h.output && !h.disableValidation && (T.data = h.output.parse(T.data));
    for (let P of l.onSuccess) P && await P(R(v({}, T), { response: (s = t == null ? void 0 : t.hookOptions) != null && s.cloneResponse ? y.clone() : y }));
    return (t == null ? void 0 : t.throw) ? T.data : { data: T.data, error: null };
  }
  let de = (c = t == null ? void 0 : t.jsonParser) != null ? c : Q, G = await y.text(), q = Ae(G) ? await de(G) : {}, ye = { response: y, request: h, error: R(v({}, q), { status: y.status, statusText: y.statusText }) };
  for (let g of l.onError) g && await g(R(v({}, ye), { response: (u = t == null ? void 0 : t.hookOptions) != null && u.cloneResponse ? y.clone() : y }));
  if (t == null ? void 0 : t.retry) {
    let g = Oe(t.retry), m = (i = t.retryAttempt) != null ? i : 0;
    if (await g.shouldAttemptRetry(m, y)) {
      for (let P of l.onRetry) P && await P(J);
      let T = g.getDelay(m);
      return await new Promise((P) => setTimeout(P, T)), await M(e, R(v({}, t), { retryAttempt: m + 1 }));
    }
  }
  if (t == null ? void 0 : t.throw) throw new Re(y.status, y.statusText, q);
  return { data: null, error: R(v({}, q), { status: y.status, statusText: y.statusText }) };
};
var C = /* @__PURE__ */ Object.create(null);
var U = (e) => {
  var _a, _b;
  return ((_a = globalThis.process) == null ? void 0 : _a.env) || ((_b = globalThis.Deno) == null ? void 0 : _b.env.toObject()) || globalThis.__env__ || (e ? C : globalThis);
};
var O = new Proxy(C, { get(e, t) {
  return U()[t] ?? C[t];
}, has(e, t) {
  let r = U();
  return t in r || t in C;
}, set(e, t, r) {
  let n = U(true);
  return n[t] = r, true;
}, deleteProperty(e, t) {
  if (!t) return false;
  let r = U(true);
  return delete r[t], true;
}, ownKeys() {
  let e = U(true);
  return Object.keys(e);
} });
function Fe(e) {
  return e ? e !== "false" : false;
}
var De = typeof process < "u" && process.env && "development" || "";
var it = De === "test" || Fe(O.TEST);
var B = class extends Error {
  constructor(t, r) {
    super(t), this.name = "BetterAuthError", this.message = t, this.cause = r, this.stack = "";
  }
};
function je(e) {
  try {
    return new URL(e).pathname !== "/";
  } catch {
    throw new B(`Invalid base URL: ${e}. Please provide a valid base URL.`);
  }
}
function W(e, t = "/api/auth") {
  return je(e) ? e : (t = t.startsWith("/") ? t : `/${t}`, `${e.replace(/\/+$/, "")}${t}`);
}
function te(e, t) {
  if (e) return W(e, t);
  let r = O.BETTER_AUTH_URL || O.NEXT_PUBLIC_BETTER_AUTH_URL || O.PUBLIC_BETTER_AUTH_URL || O.NUXT_PUBLIC_BETTER_AUTH_URL || O.NUXT_PUBLIC_AUTH_URL || (O.BASE_URL !== "/" ? O.BASE_URL : void 0);
  if (r) return W(r, t);
  if (typeof window < "u" && window.location) return W(window.location.origin, t);
}
var L = Symbol("clean");
var S = [];
var w = 0;
var F = 4;
var qe = 0;
var I = (e) => {
  let t = [], r = { get() {
    return r.lc || r.listen(() => {
    })(), r.value;
  }, lc: 0, listen(n) {
    return r.lc = t.push(n), () => {
      for (let a = w + F; a < S.length; ) S[a] === n ? S.splice(a, F) : a += F;
      let o = t.indexOf(n);
      ~o && (t.splice(o, 1), --r.lc || r.off());
    };
  }, notify(n, o) {
    qe++;
    let a = !S.length;
    for (let s of t) S.push(s, r.value, n, o);
    if (a) {
      for (w = 0; w < S.length; w += F) S[w](S[w + 1], S[w + 2], S[w + 3]);
      S.length = 0;
    }
  }, off() {
  }, set(n) {
    let o = r.value;
    o !== n && (r.value = n, r.notify(o));
  }, subscribe(n) {
    let o = r.listen(n);
    return n(r.value), o;
  }, value: e };
  return r[L] = () => {
    t = [], r.lc = 0, r.off();
  }, r;
};
var Me = 5;
var x = 6;
var D = 10;
var We = (e, t, r, n) => (e.events = e.events || {}, e.events[r + D] || (e.events[r + D] = n((o) => {
  e.events[r].reduceRight((a, s) => (s(a), a), { shared: {}, ...o });
})), e.events[r] = e.events[r] || [], e.events[r].push(t), () => {
  let o = e.events[r], a = o.indexOf(t);
  o.splice(a, 1), o.length || (delete e.events[r], e.events[r + D](), delete e.events[r + D]);
});
var re = 1e3;
var V = (e, t) => We(e, (n) => {
  let o = t(n);
  o && e.events[x].push(o);
}, Me, (n) => {
  let o = e.listen;
  e.listen = (...s) => (!e.lc && !e.active && (e.active = true, n()), o(...s));
  let a = e.off;
  if (e.events[x] = [], e.off = () => {
    a(), setTimeout(() => {
      if (e.active && !e.lc) {
        e.active = false;
        for (let s of e.events[x]) s();
        e.events[x] = [];
      }
    }, re);
  }, true) {
    let s = e[L];
    e[L] = () => {
      for (let c of e.events[x]) c();
      e.events[x] = [], e.active = false, s();
    };
  }
  return () => {
    e.listen = o, e.off = a;
  };
});
function H(e, t, r) {
  let n = /* @__PURE__ */ new Set([...t, void 0]);
  return e.listen((o, a, s) => {
    n.has(s) && r(o, a, s);
  });
}
var ne = { id: "redirect", name: "Redirect", hooks: { onSuccess(e) {
  var _a, _b;
  if (((_a = e.data) == null ? void 0 : _a.url) && ((_b = e.data) == null ? void 0 : _b.redirect) && typeof window < "u" && window.location && window.location) try {
    window.location.href = e.data.url;
  } catch {
  }
} } };
var oe = { id: "add-current-url", name: "Add current URL", hooks: { onRequest(e) {
  if (typeof window < "u" && window.location && window.location) try {
    let t = new URL(e.url);
    t.searchParams.set("currentURL", window.location.href), e.url = t;
  } catch {
  }
  return e;
} } };
var se = (e, t, r, n) => {
  let o = I({ data: null, error: null, isPending: true, isRefetching: false }), a = () => {
    let c = typeof n == "function" ? n({ data: o.get().data, error: o.get().error, isPending: o.get().isPending }) : n;
    return r(t, { ...c, async onSuccess(u) {
      var _a;
      typeof window < "u" && o.set({ data: u.data, error: null, isPending: false, isRefetching: false }), await ((_a = c == null ? void 0 : c.onSuccess) == null ? void 0 : _a.call(c, u));
    }, async onError(u) {
      var _a, _b;
      let { request: i } = u, l = typeof i.retry == "number" ? i.retry : (_a = i.retry) == null ? void 0 : _a.attempts, f = i.retryAttempt || 0;
      l && f < l || (o.set({ error: u.error, data: null, isPending: false, isRefetching: false }), await ((_b = c == null ? void 0 : c.onError) == null ? void 0 : _b.call(c, u)));
    }, async onRequest(u) {
      var _a;
      let i = o.get();
      o.set({ isPending: i.data === null, data: i.data, error: null, isRefetching: true }), await ((_a = c == null ? void 0 : c.onRequest) == null ? void 0 : _a.call(c, u));
    } });
  };
  e = Array.isArray(e) ? e : [e];
  let s = false;
  for (let c of e) c.subscribe(() => {
    s ? a() : V(o, () => (a(), s = true, () => {
      o.off(), c.off();
    }));
  });
  return o;
};
function ie(e) {
  let t = I(false);
  return { session: se(t, "/get-session", e, { method: "GET" }), $sessionSignal: t };
}
var Ve = { proto: /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, constructor: /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, protoShort: /"__proto__"\s*:/, constructorShort: /"constructor"\s*:/ };
var He = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
var ae = { true: true, false: false, null: null, undefined: void 0, nan: Number.NaN, infinity: Number.POSITIVE_INFINITY, "-infinity": Number.NEGATIVE_INFINITY };
var Je = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.(\d{1,7}))?(?:Z|([+-])(\d{2}):(\d{2}))$/;
function Ge(e) {
  return e instanceof Date && !isNaN(e.getTime());
}
function $e(e) {
  let t = Je.exec(e);
  if (!t) return null;
  let [, r, n, o, a, s, c, u, i, l, f] = t, d = new Date(Date.UTC(parseInt(r, 10), parseInt(n, 10) - 1, parseInt(o, 10), parseInt(a, 10), parseInt(s, 10), parseInt(c, 10), u ? parseInt(u.padEnd(3, "0"), 10) : 0));
  if (i) {
    let p = (parseInt(l, 10) * 60 + parseInt(f, 10)) * (i === "+" ? -1 : 1);
    d.setUTCMinutes(d.getUTCMinutes() + p);
  }
  return Ge(d) ? d : null;
}
function ze(e, t = {}) {
  let { strict: r = false, warnings: n = false, reviver: o, parseDates: a = true } = t;
  if (typeof e != "string") return e;
  let s = e.trim();
  if (s[0] === '"' && s.endsWith('"') && !s.slice(1, -1).includes('"')) return s.slice(1, -1);
  let c = s.toLowerCase();
  if (c.length <= 9 && c in ae) return ae[c];
  if (!He.test(s)) {
    if (r) throw new SyntaxError("[better-json] Invalid JSON");
    return e;
  }
  if (Object.entries(Ve).some(([i, l]) => {
    let f = l.test(s);
    return f && n && console.warn(`[better-json] Detected potential prototype pollution attempt using ${i} pattern`), f;
  }) && r) throw new Error("[better-json] Potential prototype pollution attempt detected");
  try {
    return JSON.parse(s, (l, f) => {
      if (l === "__proto__" || l === "constructor" && f && typeof f == "object" && "prototype" in f) {
        n && console.warn(`[better-json] Dropping "${l}" key to prevent prototype pollution`);
        return;
      }
      if (a && typeof f == "string") {
        let d = $e(f);
        if (d) return d;
      }
      return o ? o(l, f) : f;
    });
  } catch (i) {
    if (r) throw i;
    return e;
  }
}
function le(e, t = { strict: true }) {
  return ze(e, t);
}
var ue = (e) => {
  var _a, _b, _c, _d, _e2;
  let t = "credentials" in Request.prototype, r = te(e == null ? void 0 : e.baseURL), n = ((_a = e == null ? void 0 : e.plugins) == null ? void 0 : _a.flatMap((p) => p.fetchPlugins).filter((p) => p !== void 0)) || [], o = Z({ baseURL: r, ...t ? { credentials: "include" } : {}, method: "GET", jsonParser(p) {
    return le(p, { strict: false });
  }, customFetchImpl: async (p, b) => {
    try {
      return await fetch(p, b);
    } catch {
      return Response.error();
    }
  }, ...e == null ? void 0 : e.fetchOptions, plugins: (e == null ? void 0 : e.disableDefaultFetchPlugins) ? [...((_b = e == null ? void 0 : e.fetchOptions) == null ? void 0 : _b.plugins) || [], ...n] : [ne, oe, ...((_c = e == null ? void 0 : e.fetchOptions) == null ? void 0 : _c.plugins) || [], ...n] }), { $sessionSignal: a, session: s } = ie(o), c = (e == null ? void 0 : e.plugins) || [], u = {}, i = { $sessionSignal: a, session: s }, l = { "/sign-out": "POST", "/revoke-sessions": "POST", "/revoke-other-sessions": "POST", "/delete-user": "POST" }, f = [{ signal: "$sessionSignal", matcher(p) {
    return p === "/sign-out" || p === "/update-user" || p.startsWith("/sign-in") || p.startsWith("/sign-up");
  } }];
  for (let p of c) p.getAtoms && Object.assign(i, (_d = p.getAtoms) == null ? void 0 : _d.call(p, o)), p.pathMethods && Object.assign(l, p.pathMethods), p.atomListeners && f.push(...p.atomListeners);
  let d = { notify: (p) => {
    i[p].set(!i[p].get());
  }, listen: (p, b) => {
    i[p].subscribe(b);
  }, atoms: i };
  for (let p of c) p.getActions && Object.assign(u, (_e2 = p.getActions) == null ? void 0 : _e2.call(p, o, d));
  return { pluginsActions: u, pluginsAtoms: i, pluginPathMethods: l, atomListeners: f, $fetch: o, $store: d };
};
function Ke(e, t, r) {
  let n = t[e], { fetchOptions: o, query: a, ...s } = r || {};
  return n || ((o == null ? void 0 : o.method) ? o.method : s && Object.keys(s).length > 0 ? "POST" : "GET");
}
function ce(e, t, r, n, o) {
  function a(s = []) {
    return new Proxy(function() {
    }, { get(c, u) {
      let i = [...s, u], l = e;
      for (let f of i) if (l && typeof l == "object" && f in l) l = l[f];
      else {
        l = void 0;
        break;
      }
      return typeof l == "function" ? l : a(i);
    }, apply: async (c, u, i) => {
      let l = "/" + s.map((A) => A.replace(/[A-Z]/g, (E) => `-${E.toLowerCase()}`)).join("/"), f = i[0] || {}, d = i[1] || {}, { query: p, fetchOptions: b, ...k } = f, _ = { ...d, ...b }, N = Ke(l, r, f);
      return await t(l, { ..._, body: N === "GET" ? void 0 : { ...k, ...(_ == null ? void 0 : _.body) || {} }, query: p || (_ == null ? void 0 : _.query), method: N, async onSuccess(A) {
        var _a;
        await ((_a = _ == null ? void 0 : _.onSuccess) == null ? void 0 : _a.call(_, A));
        let E = o == null ? void 0 : o.find((y) => y.matcher(l));
        if (!E) return;
        let h = n[E.signal];
        if (!h) return;
        let j = h.get();
        setTimeout(() => {
          h.set(!j);
        }, 10);
      } });
    } });
  }
  return a();
}
var fe = (e, t) => (r) => {
  e.current = r, t();
};
function pe(e, { keys: t, deps: r = [e, t] } = {}) {
  let n = (0, import_react.useRef)();
  n.current = e.get();
  let o = (0, import_react.useCallback)((s) => ((t == null ? void 0 : t.length) || 0) > 0 ? H(e, t, fe(n, s)) : e.listen(fe(n, s)), r), a = () => n.current;
  return (0, import_react.useSyncExternalStore)(o, a, a);
}
function Ze(e) {
  return `use${et(e)}`;
}
function et(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
function Qt(e) {
  let { pluginPathMethods: t, pluginsActions: r, pluginsAtoms: n, $fetch: o, $store: a, atomListeners: s } = ue(e), c = {};
  for (let [l, f] of Object.entries(n)) c[Ze(l)] = () => pe(f);
  let u = { ...r, ...c, $fetch: o, $store: a };
  return ce(u, o, t, n, s);
}
export {
  et as capitalizeFirstLetter,
  Qt as createAuthClient,
  pe as useStore
};
//# sourceMappingURL=better-auth_react.js.map
