{
  "version": 3,
  "sources": ["../../../../@tanstack/start/src/client/Asset.tsx", "../../../../@tanstack/start/src/client/createIsomorphicFn.ts", "../../../../@tanstack/start/src/client/headers.ts", "../../../../@tanstack/start/src/client/registerGlobalMiddleware.ts", "../../../../@tanstack/start/src/client/createServerFn.ts", "../../../../@tanstack/start/src/client/createMiddleware.ts", "../../../../@tanstack/start/src/client/envOnly.ts", "../../../../@tanstack/start/src/client/DehydrateRouter.tsx", "../../../../@tanstack/start/src/client/json.ts", "../../../../@tanstack/react-cross-context/src/Context.ts", "../../../../@tanstack/start/src/client/serialization.tsx", "../../../../@tanstack/start/src/client/useServerFn.ts"],
  "sourcesContent": ["/* eslint-disable @eslint-react/dom/no-dangerously-set-innerhtml */\nimport type { RouterManagedTag } from '@tanstack/react-router'\n\nexport function Asset({ tag, attrs, children }: RouterManagedTag): any {\n  switch (tag) {\n    case 'title':\n      return (\n        <title {...attrs} suppressHydrationWarning>\n          {children}\n        </title>\n      )\n    case 'meta':\n      return <meta {...attrs} suppressHydrationWarning />\n    case 'link':\n      return <link {...attrs} suppressHydrationWarning />\n    case 'style':\n      return (\n        <style\n          {...attrs}\n          dangerouslySetInnerHTML={{ __html: children as any }}\n        />\n      )\n    case 'script':\n      if ((attrs as any) && (attrs as any).src) {\n        return <script {...attrs} suppressHydrationWarning />\n      }\n      if (typeof children === 'string')\n        return (\n          <script\n            {...attrs}\n            dangerouslySetInnerHTML={{\n              __html: children,\n            }}\n            suppressHydrationWarning\n          />\n        )\n      return null\n    default:\n      return null\n  }\n}\n", "// a function that can have different implementations on the client and server.\n// implementations not provided will default to a no-op function.\n\nexport type IsomorphicFn<\n  TArgs extends Array<any> = [],\n  TServer = undefined,\n  TClient = undefined,\n> = (...args: TArgs) => TServer | TClient\n\nexport interface ServerOnlyFn<TArgs extends Array<any>, TServer>\n  extends IsomorphicFn<TArgs, TServer> {\n  client: <TClient>(\n    clientImpl: (...args: TArgs) => TClient,\n  ) => IsomorphicFn<TArgs, TServer, TClient>\n}\n\nexport interface ClientOnlyFn<TArgs extends Array<any>, TClient>\n  extends IsomorphicFn<TArgs, undefined, TClient> {\n  server: <TServer>(\n    serverImpl: (...args: TArgs) => TServer,\n  ) => IsomorphicFn<TArgs, TServer, TClient>\n}\n\nexport interface IsomorphicFnBase extends IsomorphicFn {\n  server: <TArgs extends Array<any>, TServer>(\n    serverImpl: (...args: TArgs) => TServer,\n  ) => ServerOnlyFn<TArgs, TServer>\n  client: <TArgs extends Array<any>, TClient>(\n    clientImpl: (...args: TArgs) => TClient,\n  ) => ClientOnlyFn<TArgs, TClient>\n}\n\n// this is a dummy function, it will be replaced by the transformer\nexport function createIsomorphicFn(): IsomorphicFnBase {\n  return null!\n}\n", "import type { OutgoingHttpHeaders } from 'node:http2'\n\n// A utility function to turn HeadersInit into an object\nexport function headersInitToObject(\n  headers: HeadersInit,\n): Record<keyof OutgoingHttpHeaders, string> {\n  const obj: Record<keyof OutgoingHttpHeaders, string> = {}\n  const headersInstance = new Headers(headers)\n  for (const [key, value] of headersInstance.entries()) {\n    obj[key] = value\n  }\n  return obj\n}\n\ntype AnyHeaders =\n  | Headers\n  | HeadersInit\n  | Record<string, string>\n  | Array<[string, string]>\n  | OutgoingHttpHeaders\n  | undefined\n\n// Helper function to convert various HeaderInit types to a Headers instance\nfunction toHeadersInstance(init: AnyHeaders) {\n  if (init instanceof Headers) {\n    return new Headers(init)\n  } else if (Array.isArray(init)) {\n    return new Headers(init)\n  } else if (typeof init === 'object') {\n    return new Headers(init as HeadersInit)\n  } else {\n    return new Headers()\n  }\n}\n\n// Function to merge headers with proper overrides\nexport function mergeHeaders(...headers: Array<AnyHeaders>) {\n  return headers.reduce((acc: Headers, header) => {\n    const headersInstance = toHeadersInstance(header)\n    for (const [key, value] of headersInstance.entries()) {\n      acc.set(key, value)\n    }\n    return acc\n  }, new Headers())\n}\n", "import type { AnyMiddleware } from './createMiddleware'\n\nexport const globalMiddleware: Array<AnyMiddleware> = []\n\nexport function registerGlobalMiddleware(options: {\n  middleware: Array<AnyMiddleware>\n}) {\n  globalMiddleware.push(...options.middleware)\n}\n", "import invariant from 'tiny-invariant'\nimport {\n  defaultTransformer,\n  isNotFound,\n  isRedirect,\n} from '@tanstack/react-router'\nimport { mergeHeaders } from './headers'\nimport { globalMiddleware } from './registerGlobalMiddleware'\nimport type {\n  AnyValidator,\n  Constrain,\n  DefaultTransformerParse,\n  DefaultTransformerStringify,\n  Expand,\n  ResolveValidatorInput,\n  TransformerStringify,\n  Validator,\n} from '@tanstack/react-router'\nimport type {\n  AnyMiddleware,\n  MergeAllServerContext,\n  MergeAllValidatorInputs,\n  MergeAllValidatorOutputs,\n  MiddlewareClientFnResult,\n  MiddlewareServerFnResult,\n} from './createMiddleware'\n\nexport interface JsonResponse<TData> extends Response {\n  json: () => Promise<TData>\n}\n\nexport type CompiledFetcherFnOptions = {\n  method: Method\n  data: unknown\n  headers?: HeadersInit\n  context?: any\n}\n\nexport type Fetcher<TMiddlewares, TValidator, TResponse> = {\n  url: string\n  __executeServer: (opts: {\n    method: Method\n    data: unknown\n    headers?: HeadersInit\n    context?: any\n  }) => Promise<unknown>\n} & FetcherImpl<TMiddlewares, TValidator, TResponse>\n\nexport type FetcherImpl<TMiddlewares, TValidator, TResponse> =\n  undefined extends MergeAllValidatorInputs<TMiddlewares, TValidator>\n    ? (\n        opts?: OptionalFetcherDataOptions<\n          Expand<MergeAllValidatorInputs<TMiddlewares, TValidator>>\n        >,\n      ) => Promise<FetcherData<TResponse>>\n    : (\n        opts: RequiredFetcherDataOptions<\n          Expand<MergeAllValidatorInputs<TMiddlewares, TValidator>>\n        >,\n      ) => Promise<FetcherData<TResponse>>\n\nexport type FetcherBaseOptions = {\n  headers?: HeadersInit\n}\n\nexport interface RequiredFetcherDataOptions<TInput> extends FetcherBaseOptions {\n  data: TInput\n}\n\nexport interface OptionalFetcherDataOptions<TInput> extends FetcherBaseOptions {\n  data?: TInput\n}\n\nexport type FetcherData<TResponse> = DefaultTransformerParse<\n  TResponse extends JsonResponse<infer TData> ? TData : TResponse\n>\n\nexport type RscStream<T> = {\n  __cacheState: T\n}\n\nexport type Method = 'GET' | 'POST'\n\nexport type ServerFn<TMethod, TMiddlewares, TValidator, TResponse> = (\n  ctx: ServerFnCtx<TMethod, TMiddlewares, TValidator>,\n) =>\n  | Promise<DefaultTransformerStringify<TResponse>>\n  | DefaultTransformerStringify<TResponse>\n\nexport interface ServerFnCtx<TMethod, TMiddlewares, TValidator> {\n  method: TMethod\n  data: Expand<MergeAllValidatorOutputs<TMiddlewares, TValidator>>\n  context: Expand<MergeAllServerContext<TMiddlewares>>\n}\n\nexport type CompiledFetcherFn<TResponse> = {\n  (\n    opts: CompiledFetcherFnOptions & ServerFnBaseOptions<Method>,\n  ): Promise<TResponse>\n  url: string\n}\n\ntype ServerFnBaseOptions<\n  TMethod extends Method = 'GET',\n  TResponse = unknown,\n  TMiddlewares = unknown,\n  TInput = unknown,\n> = {\n  method: TMethod\n  validateClient?: boolean\n  middleware?: Constrain<TMiddlewares, ReadonlyArray<AnyMiddleware>>\n  validator?: ConstrainValidator<TInput>\n  extractedFn?: CompiledFetcherFn<TResponse>\n  serverFn?: ServerFn<TMethod, TMiddlewares, TInput, TResponse>\n  filename: string\n  functionId: string\n}\n\nexport type ConstrainValidator<TValidator> = unknown extends TValidator\n  ? TValidator\n  : Constrain<\n      TValidator,\n      Validator<\n        TransformerStringify<\n          ResolveValidatorInput<TValidator>,\n          Date | undefined | FormData\n        >,\n        any\n      >\n    >\n\nexport interface ServerFnMiddleware<TMethod extends Method, TValidator> {\n  middleware: <const TNewMiddlewares = undefined>(\n    middlewares: Constrain<TNewMiddlewares, ReadonlyArray<AnyMiddleware>>,\n  ) => ServerFnAfterMiddleware<TMethod, TNewMiddlewares, TValidator>\n}\n\nexport interface ServerFnAfterMiddleware<\n  TMethod extends Method,\n  TMiddlewares,\n  TValidator,\n> extends ServerFnValidator<TMethod, TMiddlewares>,\n    ServerFnHandler<TMethod, TMiddlewares, TValidator> {}\n\nexport interface ServerFnValidator<TMethod extends Method, TMiddlewares> {\n  validator: <TValidator>(\n    validator: ConstrainValidator<TValidator>,\n  ) => ServerFnAfterValidator<TMethod, TMiddlewares, TValidator>\n}\n\nexport interface ServerFnAfterValidator<\n  TMethod extends Method,\n  TMiddlewares,\n  TValidator,\n> extends ServerFnMiddleware<TMethod, TValidator>,\n    ServerFnHandler<TMethod, TMiddlewares, TValidator> {}\n\nexport interface ServerFnHandler<\n  TMethod extends Method,\n  TMiddlewares,\n  TValidator,\n> {\n  handler: <TNewResponse>(\n    fn?: ServerFn<TMethod, TMiddlewares, TValidator, TNewResponse>,\n  ) => Fetcher<TMiddlewares, TValidator, TNewResponse>\n}\n\nexport interface ServerFnBuilder<\n  TMethod extends Method = 'GET',\n  TResponse = unknown,\n  TMiddlewares = unknown,\n  TValidator = unknown,\n> extends ServerFnMiddleware<TMethod, TValidator>,\n    ServerFnValidator<TMethod, TMiddlewares>,\n    ServerFnHandler<TMethod, TMiddlewares, TValidator> {\n  options: ServerFnBaseOptions<TMethod, TResponse, TMiddlewares, TValidator>\n}\n\nexport function createServerFn<\n  TMethod extends Method,\n  TResponse = unknown,\n  TMiddlewares = undefined,\n  TValidator = undefined,\n>(\n  options?: {\n    method: TMethod\n  },\n  __opts?: ServerFnBaseOptions<TMethod, TResponse, TMiddlewares, TValidator>,\n): ServerFnBuilder<TMethod, TResponse, TMiddlewares, TValidator> {\n  const resolvedOptions = (__opts || options || {}) as ServerFnBaseOptions<\n    TMethod,\n    TResponse,\n    TMiddlewares,\n    TValidator\n  >\n\n  if (typeof resolvedOptions.method === 'undefined') {\n    resolvedOptions.method = 'GET' as TMethod\n  }\n\n  return {\n    options: resolvedOptions as any,\n    middleware: (middleware) => {\n      return createServerFn<TMethod, TResponse, TMiddlewares, TValidator>(\n        undefined,\n        Object.assign(resolvedOptions, { middleware }),\n      ) as any\n    },\n    validator: (validator) => {\n      return createServerFn<TMethod, TResponse, TMiddlewares, TValidator>(\n        undefined,\n        Object.assign(resolvedOptions, { validator }),\n      ) as any\n    },\n    handler: (...args) => {\n      // This function signature changes due to AST transformations\n      // in the babel plugin. We need to cast it to the correct\n      // function signature post-transformation\n      const [extractedFn, serverFn] = args as unknown as [\n        CompiledFetcherFn<TResponse>,\n        ServerFn<TMethod, TMiddlewares, TValidator, TResponse>,\n      ]\n\n      // Keep the original function around so we can use it\n      // in the server environment\n      Object.assign(resolvedOptions, {\n        ...extractedFn,\n        extractedFn,\n        serverFn,\n      })\n\n      invariant(\n        extractedFn.url,\n        `createServerFn must be called with a function that is marked with the 'use server' pragma. Are you using the @tanstack/start-vite-plugin ?`,\n      )\n\n      const resolvedMiddleware = [\n        ...(resolvedOptions.middleware || []),\n        serverFnBaseToMiddleware(resolvedOptions),\n      ]\n\n      // We want to make sure the new function has the same\n      // properties as the original function\n      return Object.assign(\n        async (opts?: CompiledFetcherFnOptions) => {\n          // Start by executing the client-side middleware chain\n          return executeMiddleware(resolvedMiddleware, 'client', {\n            ...extractedFn,\n            method: resolvedOptions.method,\n            data: opts?.data as any,\n            headers: opts?.headers,\n            context: {},\n          }).then((d) => {\n            if (d.error) throw d.error\n            return d.result\n          })\n        },\n        {\n          // This copies over the URL, function ID and filename\n          ...extractedFn,\n          // The extracted function on the server-side calls\n          // this function\n          __executeServer: async (opts: any) => {\n            const parsedOpts =\n              opts instanceof FormData ? extractFormDataContext(opts) : opts\n\n            const result = await executeMiddleware(\n              resolvedMiddleware,\n              'server',\n              {\n                ...extractedFn,\n                ...parsedOpts,\n              },\n            ).then((d) => ({\n              // Only send the result and sendContext back to the client\n              result: d.result,\n              error: d.error,\n              context: d.sendContext,\n            }))\n\n            return result\n          },\n        },\n      ) as any\n    },\n  }\n}\n\nfunction extractFormDataContext(formData: FormData) {\n  const serializedContext = formData.get('__TSR_CONTEXT')\n  formData.delete('__TSR_CONTEXT')\n\n  if (typeof serializedContext !== 'string') {\n    return {\n      context: {},\n      data: formData,\n    }\n  }\n\n  try {\n    const context = defaultTransformer.parse(serializedContext)\n    return {\n      context,\n      data: formData,\n    }\n  } catch (e) {\n    return {\n      data: formData,\n    }\n  }\n}\n\nfunction flattenMiddlewares(\n  middlewares: Array<AnyMiddleware>,\n): Array<AnyMiddleware> {\n  const seen = new Set<AnyMiddleware>()\n  const flattened: Array<AnyMiddleware> = []\n\n  const recurse = (middleware: Array<AnyMiddleware>) => {\n    middleware.forEach((m) => {\n      if (m.options.middleware) {\n        recurse(m.options.middleware)\n      }\n\n      if (!seen.has(m)) {\n        seen.add(m)\n        flattened.push(m)\n      }\n    })\n  }\n\n  recurse(middlewares)\n\n  return flattened\n}\n\nexport type MiddlewareOptions = {\n  method: Method\n  data: any\n  headers?: HeadersInit\n  sendContext?: any\n  context?: any\n}\n\nexport type MiddlewareResult = MiddlewareOptions & {\n  result?: unknown\n  error?: unknown\n}\n\nexport type NextFn = (ctx: MiddlewareResult) => Promise<MiddlewareResult>\n\nexport type MiddlewareFn = (\n  ctx: MiddlewareOptions & {\n    next: NextFn\n  },\n) => Promise<MiddlewareResult>\n\nconst applyMiddleware = async (\n  middlewareFn: MiddlewareFn,\n  ctx: MiddlewareOptions,\n  nextFn: NextFn,\n) => {\n  return middlewareFn({\n    ...ctx,\n    next: (async (userCtx: MiddlewareResult | undefined = {} as any) => {\n      // Return the next middleware\n      return nextFn({\n        ...ctx,\n        ...userCtx,\n        context: {\n          ...ctx.context,\n          ...userCtx.context,\n        },\n        sendContext: {\n          ...ctx.sendContext,\n          ...(userCtx.sendContext ?? {}),\n        },\n        headers: mergeHeaders(ctx.headers, userCtx.headers),\n        result:\n          userCtx.result !== undefined ? userCtx.result : (ctx as any).result,\n        error: userCtx.error ?? (ctx as any).error,\n      })\n    }) as any,\n  })\n}\n\nfunction execValidator(validator: AnyValidator, input: unknown): unknown {\n  if (validator == null) return {}\n\n  if ('~standard' in validator) {\n    const result = validator['~standard'].validate(input)\n\n    if (result instanceof Promise)\n      throw new Error('Async validation not supported')\n\n    if (result.issues)\n      throw new Error(JSON.stringify(result.issues, undefined, 2))\n\n    return result.value\n  }\n\n  if ('parse' in validator) {\n    return validator.parse(input)\n  }\n\n  if (typeof validator === 'function') {\n    return validator(input)\n  }\n\n  throw new Error('Invalid validator type!')\n}\n\nasync function executeMiddleware(\n  middlewares: Array<AnyMiddleware>,\n  env: 'client' | 'server',\n  opts: MiddlewareOptions,\n): Promise<MiddlewareResult> {\n  const flattenedMiddlewares = flattenMiddlewares([\n    ...globalMiddleware,\n    ...middlewares,\n  ])\n\n  const next: NextFn = async (ctx) => {\n    // Get the next middleware\n    const nextMiddleware = flattenedMiddlewares.shift()\n\n    // If there are no more middlewares, return the context\n    if (!nextMiddleware) {\n      return ctx\n    }\n\n    if (\n      nextMiddleware.options.validator &&\n      (env === 'client' ? nextMiddleware.options.validateClient : true)\n    ) {\n      // Execute the middleware's input function\n      ctx.data = await execValidator(nextMiddleware.options.validator, ctx.data)\n    }\n\n    const middlewareFn = (\n      env === 'client'\n        ? nextMiddleware.options.client\n        : nextMiddleware.options.server\n    ) as MiddlewareFn | undefined\n\n    if (middlewareFn) {\n      // Execute the middleware\n      return applyMiddleware(middlewareFn, ctx, async (newCtx) => {\n        // If there is a clientAfter function and we are on the client\n        const clientAfter = nextMiddleware.options.clientAfter as\n          | MiddlewareFn\n          | undefined\n\n        if (env === 'client' && clientAfter) {\n          // We need to await the next middleware and get the result\n          const result = await next(newCtx)\n\n          // Then we can execute the clientAfter function\n          return applyMiddleware(\n            clientAfter,\n            {\n              ...newCtx,\n              ...result,\n            },\n            // Identity, because there \"next\" is just returning\n            (d: any) => d,\n          )\n        }\n\n        return next(newCtx).catch((error) => {\n          if (isRedirect(error) || isNotFound(error)) {\n            return {\n              ...newCtx,\n              error,\n            }\n          }\n\n          throw error\n        })\n      })\n    }\n\n    return next(ctx)\n  }\n\n  // Start the middleware chain\n  return next({\n    ...opts,\n    headers: opts.headers || {},\n    sendContext: opts.sendContext || {},\n    context: opts.context || {},\n  })\n}\n\nfunction serverFnBaseToMiddleware(\n  options: ServerFnBaseOptions<any, any, any, any>,\n): AnyMiddleware {\n  return {\n    _types: undefined!,\n    options: {\n      validator: options.validator,\n      validateClient: options.validateClient,\n      client: async ({ next, sendContext, ...ctx }) => {\n        // Execute the extracted function\n        // but not before serializing the context\n        const serverCtx = await options.extractedFn?.({\n          ...ctx,\n          // switch the sendContext over to context\n          context: sendContext,\n        })\n\n        return next(serverCtx) as unknown as MiddlewareClientFnResult<any, any>\n      },\n      server: async ({ next, ...ctx }) => {\n        // Execute the server function\n        const result = await options.serverFn?.(ctx)\n\n        return next({\n          ...ctx,\n          result,\n        } as any) as unknown as MiddlewareServerFnResult<any, any>\n      },\n    },\n  }\n}\n", "import type { ConstrainValidator, Method } from './createServerFn'\nimport type {\n  Assign,\n  Constrain,\n  DefaultTransformerStringify,\n  Expand,\n  ResolveValidatorInput,\n  ResolveValidatorOutput,\n} from '@tanstack/react-router'\n\nexport type MergeAllMiddleware<\n  TMiddlewares,\n  TType extends keyof AnyMiddleware['_types'],\n  TAcc = undefined,\n> = TMiddlewares extends readonly [\n  infer TMiddleware extends AnyMiddleware,\n  ...infer TRest,\n]\n  ? MergeAllMiddleware<TRest, TType, Assign<TAcc, TMiddleware['_types'][TType]>>\n  : TAcc\n\nexport type MergeAllClientAfterContext<\n  TMiddlewares,\n  TClientContext = undefined,\n  TClientAfterContext = undefined,\n> = unknown extends TClientContext\n  ? TClientContext\n  : Assign<\n      MergeAllMiddleware<TMiddlewares, 'allClientAfterContext'>,\n      Assign<TClientContext, TClientAfterContext>\n    >\n\n/**\n * Recursively resolve the client context type produced by a sequence of middleware\n */\nexport type MergeAllClientContext<\n  TMiddlewares,\n  TContext = undefined,\n> = unknown extends TContext\n  ? TContext\n  : Assign<MergeAllMiddleware<TMiddlewares, 'allClientContext'>, TContext>\n\n/**\n * Recursively resolve the server context type produced by a sequence of middleware\n */\nexport type MergeAllServerContext<\n  TMiddlewares,\n  TContext = undefined,\n> = unknown extends TContext\n  ? TContext\n  : Assign<MergeAllMiddleware<TMiddlewares, 'allServerContext'>, TContext>\n\n/**\n * Recursively resolve the input type produced by a sequence of middleware\n */\nexport type MergeAllValidatorInputs<TMiddlewares, TValidator> =\n  unknown extends TValidator\n    ? TValidator\n    : Assign<\n        MergeAllMiddleware<TMiddlewares, 'allInput'>,\n        TValidator extends undefined\n          ? undefined\n          : ResolveValidatorInput<TValidator>\n      >\n/**\n * Recursively merge the output type produced by a sequence of middleware\n */\nexport type MergeAllValidatorOutputs<TMiddlewares, TValidator> =\n  unknown extends TValidator\n    ? TValidator\n    : Assign<\n        MergeAllMiddleware<TMiddlewares, 'allOutput'>,\n        TValidator extends undefined\n          ? undefined\n          : ResolveValidatorOutput<TValidator>\n      >\n\nexport interface MiddlewareOptions<\n  in out TMiddlewares,\n  in out TValidator,\n  in out TServerContext,\n  in out TClientContext,\n> {\n  validateClient?: boolean\n  middleware?: TMiddlewares\n  validator?: ConstrainValidator<TValidator>\n  client?: MiddlewareClientFn<\n    TMiddlewares,\n    TValidator,\n    TServerContext,\n    TClientContext\n  >\n  server?: MiddlewareServerFn<\n    TMiddlewares,\n    TValidator,\n    TServerContext,\n    unknown,\n    unknown\n  >\n  clientAfter?: MiddlewareClientAfterFn<\n    TMiddlewares,\n    TValidator,\n    TClientContext,\n    unknown,\n    unknown\n  >\n}\n\nexport type MiddlewareServerNextFn = <\n  TNewServerContext = undefined,\n  TNewClientAfterContext = undefined,\n>(ctx?: {\n  context?: TNewServerContext\n  sendContext?: DefaultTransformerStringify<TNewClientAfterContext>\n}) => Promise<\n  ServerResultWithContext<TNewServerContext, TNewClientAfterContext>\n>\n\nexport interface MiddlewareServerFnOptions<\n  in out TMiddlewares,\n  in out TValidator,\n  in out TServerContext,\n> {\n  data: Expand<MergeAllValidatorOutputs<TMiddlewares, TValidator>>\n  context: Expand<MergeAllServerContext<TMiddlewares, TServerContext>>\n  next: MiddlewareServerNextFn\n  method: Method\n  filename: string\n  functionId: string\n}\n\nexport type MiddlewareServerFn<\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TNewServerContext,\n  TNewClientAfterContext,\n> = (\n  options: MiddlewareServerFnOptions<TMiddlewares, TValidator, TServerContext>,\n) => MiddlewareServerFnResult<TNewServerContext, TNewClientAfterContext>\n\nexport type MiddlewareServerFnResult<TServerContext, TClientAfterContext> =\n  | Promise<ServerResultWithContext<TServerContext, TClientAfterContext>>\n  | ServerResultWithContext<TServerContext, TClientAfterContext>\n\nexport type MiddlewareClientNextFn = <\n  TNewServerContext = undefined,\n  TNewClientContext = undefined,\n>(ctx?: {\n  context?: TNewClientContext\n  sendContext?: DefaultTransformerStringify<TNewServerContext>\n  headers?: HeadersInit\n}) => Promise<ClientResultWithContext<TNewServerContext, TNewClientContext>>\n\nexport interface MiddlewareClientFnOptions<\n  in out TMiddlewares,\n  in out TValidator,\n> {\n  data: Expand<MergeAllValidatorInputs<TMiddlewares, TValidator>>\n  context: Expand<MergeAllClientContext<TMiddlewares>>\n  sendContext?: unknown // cc Chris Horobin\n  method: Method\n  next: MiddlewareClientNextFn\n  filename: string\n  functionId: string\n}\n\nexport type MiddlewareClientFn<\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TClientContext,\n> = (\n  options: MiddlewareClientFnOptions<TMiddlewares, TValidator>,\n) => MiddlewareClientFnResult<TServerContext, TClientContext>\n\nexport type MiddlewareClientFnResult<TServerContext, TClientContext> =\n  | Promise<ClientResultWithContext<TServerContext, TClientContext>>\n  | ClientResultWithContext<TServerContext, TClientContext>\n\nexport type MiddlewareClientAfterNextFn = <\n  TNewClientAfterContext = undefined,\n>(ctx?: {\n  context?: TNewClientAfterContext\n  sendContext?: never\n  headers?: HeadersInit\n}) => Promise<ClientAfterResultWithContext<TNewClientAfterContext>>\n\nexport interface MiddlewareClientAfterFnOptions<\n  in out TMiddlewares,\n  in out TValidator,\n  in out TClientContext,\n  in out TClientAfterContext,\n> {\n  data: Expand<MergeAllValidatorInputs<TMiddlewares, TValidator>>\n  context: Expand<\n    MergeAllClientAfterContext<\n      TMiddlewares,\n      TClientContext,\n      TClientAfterContext\n    >\n  >\n  method: Method\n  next: MiddlewareClientAfterNextFn\n}\n\nexport type MiddlewareClientAfterFn<\n  TMiddlewares,\n  TValidator,\n  TClientContext,\n  TClientAfterContext,\n  TNewClientAfterContext,\n> = (\n  options: MiddlewareClientAfterFnOptions<\n    TMiddlewares,\n    TValidator,\n    TClientContext,\n    TClientAfterContext\n  >,\n) => MiddlewareClientAfterFnResult<TNewClientAfterContext>\n\nexport type MiddlewareClientAfterFnResult<TNewClientAfterContext> =\n  | Promise<ClientAfterResultWithContext<TNewClientAfterContext>>\n  | ClientAfterResultWithContext<TNewClientAfterContext>\n\nexport type ServerResultWithContext<TContext, TClientAfterContext> = {\n  'use functions must return the result of next()': true\n  context: TContext\n  clientAfterContext: TClientAfterContext\n}\n\nexport type ClientAfterResultWithContext<TClientContext> = {\n  'use functions must return the result of next()': true\n  context: TClientContext\n  headers: HeadersInit\n}\n\nexport type ClientResultWithContext<TServerContext, TClientContext> = {\n  'use functions must return the result of next()': true\n  context: TClientContext\n  serverContext: TServerContext\n  headers: HeadersInit\n}\n\nexport type AnyMiddleware = MiddlewareTypes<any, any, any, any, any, any>\n\nexport interface MiddlewareTypes<\n  TId,\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TClientContext,\n  TClientAfterContext,\n> {\n  _types: {\n    id: TId\n    middlewares: TMiddlewares\n    input: ResolveValidatorInput<TValidator>\n    allInput: MergeAllValidatorInputs<TMiddlewares, TValidator>\n    output: ResolveValidatorOutput<TValidator>\n    allOutput: MergeAllValidatorOutputs<TMiddlewares, TValidator>\n    clientContext: TClientContext\n    allClientContext: MergeAllClientContext<TMiddlewares, TClientContext>\n    serverContext: TServerContext\n    allServerContext: MergeAllServerContext<TMiddlewares, TServerContext>\n    clientAfterContext: TClientAfterContext\n    allClientAfterContext: MergeAllClientAfterContext<\n      TMiddlewares,\n      TClientContext,\n      TClientAfterContext\n    >\n    validator: TValidator\n  }\n  options: MiddlewareOptions<\n    TMiddlewares,\n    TValidator,\n    TServerContext,\n    TClientContext\n  >\n}\n\nexport interface MiddlewareValidator<\n  TId,\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TClientContext,\n  TClientAfterContext,\n> {\n  validator: <TNewValidator>(\n    input: ConstrainValidator<TNewValidator>,\n  ) => MiddlewareAfterMiddleware<\n    TId,\n    TMiddlewares,\n    NonNullable<TValidator> | TNewValidator,\n    TServerContext,\n    TClientContext,\n    TClientAfterContext\n  >\n}\n\nexport interface MiddlewareClientAfter<\n  TId,\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TClientContext,\n  TClientAfterContext,\n> {\n  clientAfter: <TNewClientAfterContext = undefined>(\n    clientAfter: MiddlewareClientAfterFn<\n      TMiddlewares,\n      TValidator,\n      TClientContext,\n      TClientAfterContext,\n      TNewClientAfterContext\n    >,\n  ) => MiddlewareAfterServer<\n    TId,\n    TMiddlewares,\n    TValidator,\n    TServerContext,\n    TClientContext,\n    Assign<TClientAfterContext, TNewClientAfterContext>\n  >\n}\n\nexport interface MiddlewareAfterServer<\n  TId,\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TClientContext,\n  TClientAfterContext,\n> extends MiddlewareTypes<\n      TId,\n      TMiddlewares,\n      TValidator,\n      TServerContext,\n      TClientContext,\n      TClientAfterContext\n    >,\n    MiddlewareClientAfter<\n      TId,\n      TMiddlewares,\n      TValidator,\n      TServerContext,\n      TClientContext,\n      TClientAfterContext\n    > {}\n\nexport interface MiddlewareServer<\n  TId,\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TClientContext,\n  TClientAfterContext,\n> {\n  server: <TNewServerContext = undefined, TNewClientAfterContext = undefined>(\n    server: MiddlewareServerFn<\n      TMiddlewares,\n      TValidator,\n      TServerContext,\n      TNewServerContext,\n      TNewClientAfterContext\n    >,\n  ) => MiddlewareAfterServer<\n    TId,\n    TMiddlewares,\n    TValidator,\n    Assign<TServerContext, TNewServerContext>,\n    TClientContext,\n    Assign<TClientAfterContext, TNewClientAfterContext>\n  >\n}\n\nexport interface MiddlewareAfterClient<\n  TId,\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TClientContext,\n  TClientAfterContext,\n> extends MiddlewareTypes<\n      TId,\n      TMiddlewares,\n      TValidator,\n      TServerContext,\n      TClientContext,\n      TClientAfterContext\n    >,\n    MiddlewareServer<\n      TId,\n      TMiddlewares,\n      TValidator,\n      TServerContext,\n      TClientContext,\n      TClientAfterContext\n    > {}\n\nexport interface MiddlewareClient<\n  TId,\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TClientContext,\n  TClientAfterContext,\n> {\n  client: <TNewServerContext = undefined, TNewClientContext = undefined>(\n    client: MiddlewareClientFn<\n      TMiddlewares,\n      TValidator,\n      TNewServerContext,\n      TNewClientContext\n    >,\n  ) => MiddlewareAfterClient<\n    TId,\n    TMiddlewares,\n    TValidator,\n    Assign<TServerContext, TNewServerContext>,\n    Assign<TClientContext, TNewClientContext>,\n    TClientAfterContext\n  >\n}\n\nexport interface MiddlewareAfterMiddleware<\n  TId,\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TClientContext,\n  TClientAfterContext,\n> extends MiddlewareTypes<\n      TId,\n      TMiddlewares,\n      TValidator,\n      TServerContext,\n      TClientContext,\n      TClientAfterContext\n    >,\n    MiddlewareServer<\n      TId,\n      TMiddlewares,\n      TValidator,\n      TServerContext,\n      TClientContext,\n      TClientAfterContext\n    >,\n    MiddlewareClient<\n      TId,\n      TMiddlewares,\n      TValidator,\n      TServerContext,\n      TClientContext,\n      TClientAfterContext\n    >,\n    MiddlewareValidator<\n      TId,\n      TMiddlewares,\n      TValidator,\n      TServerContext,\n      TClientContext,\n      TClientAfterContext\n    > {}\n\nexport interface Middleware<\n  TId,\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TClientContext,\n  TClientAfterContext,\n> extends MiddlewareAfterMiddleware<\n    TId,\n    TMiddlewares,\n    TValidator,\n    TServerContext,\n    TClientContext,\n    TClientAfterContext\n  > {\n  middleware: <const TNewMiddlewares = undefined>(\n    middlewares: Constrain<TNewMiddlewares, ReadonlyArray<AnyMiddleware>>,\n  ) => MiddlewareAfterMiddleware<\n    TId,\n    TNewMiddlewares,\n    TValidator,\n    TServerContext,\n    TClientContext,\n    TClientAfterContext\n  >\n}\n\nexport function createMiddleware<\n  const TId,\n  const TMiddlewares,\n  TValidator = undefined,\n  TServerContext = undefined,\n  TClientContext = undefined,\n  TClientAfterContext = undefined,\n>(\n  options?: {\n    validateClient?: boolean\n  },\n  __opts?: MiddlewareOptions<\n    TMiddlewares,\n    TValidator,\n    TServerContext,\n    TClientContext\n  >,\n): Middleware<\n  TId,\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TClientContext,\n  TClientAfterContext\n> {\n  // const resolvedOptions = (__opts || options) as MiddlewareOptions<\n  const resolvedOptions =\n    __opts ||\n    ((options || {}) as MiddlewareOptions<\n      TMiddlewares,\n      TValidator,\n      TServerContext,\n      TClientContext\n    >)\n\n  return {\n    options: resolvedOptions as any,\n    middleware: (middleware: any) => {\n      return createMiddleware<\n        TId,\n        TMiddlewares,\n        TValidator,\n        TServerContext,\n        TClientContext\n      >(undefined, Object.assign(resolvedOptions, { middleware })) as any\n    },\n    validator: (validator: any) => {\n      return createMiddleware<\n        TId,\n        TMiddlewares,\n        TValidator,\n        TServerContext,\n        TClientContext\n      >(undefined, Object.assign(resolvedOptions, { validator })) as any\n    },\n    client: (client: any) => {\n      return createMiddleware<\n        TId,\n        TMiddlewares,\n        TValidator,\n        TServerContext,\n        TClientContext\n      >(undefined, Object.assign(resolvedOptions, { client })) as any\n    },\n    server: (server: any) => {\n      return createMiddleware<\n        TId,\n        TMiddlewares,\n        TValidator,\n        TServerContext,\n        TClientContext\n      >(undefined, Object.assign(resolvedOptions, { server })) as any\n    },\n    clientAfter: (clientAfter: any) => {\n      return createMiddleware<\n        TId,\n        TMiddlewares,\n        TValidator,\n        TServerContext,\n        TClientContext\n      >(undefined, Object.assign(resolvedOptions, { clientAfter })) as any\n    },\n  } as unknown as Middleware<\n    TId,\n    TMiddlewares,\n    TValidator,\n    TServerContext,\n    TClientContext,\n    TClientAfterContext\n  >\n}\n", "type EnvOnlyFn = <TFn extends (...args: Array<any>) => any>(fn: TFn) => TFn\n\n// A function that will only be available in the server build\n// If called on the client, it will throw an error\nexport const serverOnly: EnvOnlyFn = (fn) => fn\n\n// A function that will only be available in the client build\n// If called on the server, it will throw an error\nexport const clientOnly: EnvOnlyFn = (fn) => fn\n", "export function DehydrateRouter() {\n  return null\n}\n", "import { mergeHeaders } from './headers'\nimport type { JsonResponse } from './createServerFn'\n\nexport function json<TData>(\n  payload: TData,\n  init?: ResponseInit,\n): JsonResponse<TData> {\n  return new Response(JSON.stringify(payload), {\n    ...init,\n    headers: mergeHeaders(\n      { 'content-type': 'application/json' },\n      init?.headers,\n    ),\n  })\n}\n", "import { createContext } from 'react'\n\nclass Context {\n  cache = new Map()\n\n  private static instance: Context | undefined\n\n  public static create(): Context {\n    if (!Context.instance) {\n      Context.instance = new Context()\n    }\n\n    return Context.instance\n  }\n\n  private createContext<T>(key: string, initialValue: T) {\n    const context = createContext(initialValue)\n\n    this.cache.set(key, context)\n\n    return context\n  }\n\n  get<T>(key: string, initialValue?: T) {\n    return this.cache.get(key) || this.createContext(key, initialValue)\n  }\n}\n\nconst context = Context.create()\n\nexport default context\n", "import * as React from 'react'\nimport {\n  ScriptOnce,\n  TSR_DEFERRED_PROMISE,\n  createControlledPromise,\n  defer,\n  isPlainArray,\n  isPlainObject,\n  pick,\n  useRouter,\n} from '@tanstack/react-router'\nimport jsesc from 'jsesc'\nimport invariant from 'tiny-invariant'\nimport type {\n  AnyRouteMatch,\n  AnyRouter,\n  ExtractedEntry,\n  ExtractedPromise,\n  ExtractedStream,\n  StreamState,\n} from '@tanstack/react-router'\n\nexport function serializeLoaderData(\n  dataType: '__beforeLoadContext' | 'loaderData',\n  data: any,\n  ctx: {\n    match: AnyRouteMatch\n    router: AnyRouter\n  },\n) {\n  if (!ctx.router.isServer) {\n    return data\n  }\n\n  ;(ctx.match as any).extracted = (ctx.match as any).extracted || []\n\n  const extracted = (ctx.match as any).extracted\n\n  const replacedLoaderData = replaceBy(data, (value, path) => {\n    const type =\n      value instanceof ReadableStream\n        ? 'stream'\n        : value instanceof Promise\n          ? 'promise'\n          : undefined\n\n    // If it's a stream, we need to tee it so we can read it multiple times\n    if (type === 'stream') {\n      const [copy1, copy2] = value.tee()\n      const entry: ExtractedStream = {\n        dataType,\n        type,\n        path,\n        id: extracted.length,\n        matchIndex: ctx.match.index,\n        streamState: createStreamState({ stream: copy2 }),\n      }\n\n      extracted.push(entry)\n      return copy1\n    } else if (type === 'promise') {\n      defer(value)\n      const entry: ExtractedPromise = {\n        dataType,\n        type,\n        path,\n        id: extracted.length,\n        matchIndex: ctx.match.index,\n        promiseState: value,\n      }\n      extracted.push(entry)\n    }\n\n    return value\n  })\n\n  return replacedLoaderData\n}\n\n// Right after hydration and before the first render, we need to rehydrate each match\n// This includes rehydrating the loaderData and also using the beforeLoadContext\n// to reconstruct any context that was serialized on the server\nexport function afterHydrate({ router }: { router: AnyRouter }) {\n  router.state.matches.forEach((match) => {\n    const route = router.looseRoutesById[match.routeId]!\n    const dMatch = window.__TSR__?.matches[match.index]\n    if (dMatch) {\n      const parentMatch = router.state.matches[match.index - 1]\n      const parentContext = parentMatch?.context ?? router.options.context ?? {}\n      if (dMatch.__beforeLoadContext) {\n        match.__beforeLoadContext = router.options.transformer.parse(\n          dMatch.__beforeLoadContext,\n        ) as any\n\n        match.context = {\n          ...parentContext,\n          ...match.context,\n          ...match.__beforeLoadContext,\n        }\n      }\n\n      if (dMatch.loaderData) {\n        match.loaderData = router.options.transformer.parse(dMatch.loaderData)\n      }\n\n      const extracted = dMatch.extracted\n\n      if (extracted) {\n        Object.entries(extracted).forEach(([_, ex]: any) => {\n          deepMutableSetByPath(match, ['loaderData', ...ex.path], ex.value)\n        })\n      }\n    }\n\n    const headFnContent = route.options.head?.({\n      matches: router.state.matches,\n      match,\n      params: match.params,\n      loaderData: match.loaderData,\n    })\n\n    Object.assign(match, {\n      meta: headFnContent?.meta,\n      links: headFnContent?.links,\n      scripts: headFnContent?.scripts,\n    })\n  })\n}\n\nexport function AfterEachMatch(props: { match: any; matchIndex: number }) {\n  const router = useRouter()\n\n  const fullMatch = router.state.matches[props.matchIndex]!\n\n  if (!router.isServer) {\n    return null\n  }\n\n  const extracted = (fullMatch as any).extracted as\n    | undefined\n    | Array<ExtractedEntry>\n\n  const [serializedBeforeLoadData, serializedLoaderData] = (\n    ['__beforeLoadContext', 'loaderData'] as const\n  ).map((dataType) => {\n    return extracted\n      ? extracted.reduce(\n          (acc: any, entry: ExtractedEntry) => {\n            if (entry.dataType !== dataType) {\n              return deepImmutableSetByPath(\n                acc,\n                ['temp', ...entry.path],\n                undefined,\n              )\n            }\n            return acc\n          },\n          { temp: fullMatch[dataType] },\n        ).temp\n      : fullMatch[dataType]\n  })\n\n  if (\n    serializedBeforeLoadData !== undefined ||\n    serializedLoaderData !== undefined ||\n    extracted?.length\n  ) {\n    const initCode = `__TSR__.initMatch(${jsesc(\n      {\n        index: props.matchIndex,\n        __beforeLoadContext: router.options.transformer.stringify(\n          serializedBeforeLoadData,\n        ),\n        loaderData: router.options.transformer.stringify(serializedLoaderData),\n        extracted: extracted\n          ? Object.fromEntries(\n              extracted.map((entry) => {\n                return [entry.id, pick(entry, ['type', 'path'])]\n              }),\n            )\n          : {},\n      },\n      {\n        isScriptContext: true,\n        wrap: true,\n        json: true,\n      },\n    )})`\n\n    return (\n      <>\n        <ScriptOnce children={initCode} />\n        {extracted\n          ? extracted.map((d) => {\n              if (d.type === 'stream') {\n                return <DehydrateStream key={d.id} entry={d} />\n              }\n\n              return <DehydratePromise key={d.id} entry={d} />\n            })\n          : null}\n      </>\n    )\n  }\n\n  return null\n}\n\nexport function replaceBy<T>(\n  obj: T,\n  cb: (value: any, path: Array<string>) => any,\n  path: Array<string> = [],\n): T {\n  if (isPlainArray(obj)) {\n    return obj.map((value, i) => replaceBy(value, cb, [...path, `${i}`])) as any\n  }\n\n  if (isPlainObject(obj)) {\n    // Do not allow objects with illegal\n    const newObj: any = {}\n\n    for (const key in obj) {\n      newObj[key] = replaceBy(obj[key], cb, [...path, key])\n    }\n\n    return newObj\n  }\n\n  // // Detect classes, functions, and other non-serializable objects\n  // // and return undefined. Exclude some known types that are serializable\n  // if (\n  //   typeof obj === 'function' ||\n  //   (typeof obj === 'object' &&\n  //     ![Object, Promise, ReadableStream].includes((obj as any)?.constructor))\n  // ) {\n  //   console.info(obj)\n  //   warning(false, `Non-serializable value ☝️ found at ${path.join('.')}`)\n  //   return undefined as any\n  // }\n\n  const newObj = cb(obj, path)\n\n  if (newObj !== obj) {\n    return newObj\n  }\n\n  return obj\n}\n\nfunction DehydratePromise({ entry }: { entry: ExtractedPromise }) {\n  return (\n    <div className=\"tsr-once\">\n      <React.Suspense fallback={null}>\n        <InnerDehydratePromise entry={entry} />\n      </React.Suspense>\n    </div>\n  )\n}\n\nfunction InnerDehydratePromise({ entry }: { entry: ExtractedPromise }) {\n  const router = useRouter()\n  if (entry.promiseState[TSR_DEFERRED_PROMISE].status === 'pending') {\n    throw entry.promiseState\n  }\n\n  const code = `__TSR__.resolvePromise(${jsesc(\n    { ...entry, value: entry.promiseState[TSR_DEFERRED_PROMISE] },\n    {\n      isScriptContext: true,\n      wrap: true,\n      json: true,\n    },\n  )})`\n\n  router.injectScript(code)\n\n  return <></>\n}\n\nfunction DehydrateStream({ entry }: { entry: ExtractedStream }) {\n  invariant(entry.streamState, 'StreamState should be defined')\n  const router = useRouter()\n\n  return (\n    <StreamChunks\n      streamState={entry.streamState}\n      children={(chunk) => {\n        const code = chunk\n          ? `__TSR__.matches[${entry.matchIndex}].extracted[${entry.id}].value.controller.enqueue(new TextEncoder().encode(${jsesc(\n              chunk.toString(),\n              {\n                isScriptContext: true,\n                wrap: true,\n                json: true,\n              },\n            )}))`\n          : `__TSR__.matches[${entry.matchIndex}].extracted[${entry.id}].value.controller.close()`\n\n        router.injectScript(code)\n\n        return <></>\n      }}\n    />\n  )\n}\n\n// Readable stream with state is a stream that has a promise that resolves to the next chunk\nfunction createStreamState({\n  stream,\n}: {\n  stream: ReadableStream\n}): StreamState {\n  const streamState: StreamState = {\n    promises: [],\n  }\n\n  const reader = stream.getReader()\n\n  const read = (index: number): any => {\n    streamState.promises[index] = createControlledPromise()\n\n    return reader.read().then(({ done, value }) => {\n      if (done) {\n        streamState.promises[index]!.resolve(null)\n        reader.releaseLock()\n        return\n      }\n\n      streamState.promises[index]!.resolve(value)\n\n      return read(index + 1)\n    })\n  }\n\n  read(0).catch((err: any) => {\n    console.error('stream read error', err)\n  })\n\n  return streamState\n}\n\nfunction StreamChunks({\n  streamState,\n  children,\n  __index = 0,\n}: {\n  streamState: StreamState\n  children: (chunk: string | null) => React.JSX.Element\n  __index?: number\n}) {\n  const promise = streamState.promises[__index]\n\n  if (!promise) {\n    return null\n  }\n\n  if (promise.status === 'pending') {\n    throw promise\n  }\n\n  const chunk = promise.value!\n\n  return (\n    <>\n      {children(chunk)}\n      <div className=\"tsr-once\">\n        <React.Suspense fallback={null}>\n          <StreamChunks\n            streamState={streamState}\n            __index={__index + 1}\n            children={children}\n          />\n        </React.Suspense>\n      </div>\n    </>\n  )\n}\n\nfunction deepImmutableSetByPath<T>(obj: T, path: Array<string>, value: any): T {\n  // immutable set by path retaining array and object references\n  if (path.length === 0) {\n    return value\n  }\n\n  const [key, ...rest] = path\n\n  if (Array.isArray(obj)) {\n    return obj.map((item, i) => {\n      if (i === Number(key)) {\n        return deepImmutableSetByPath(item, rest, value)\n      }\n      return item\n    }) as T\n  }\n\n  if (isPlainObject(obj)) {\n    return {\n      ...obj,\n      [key!]: deepImmutableSetByPath((obj as any)[key!], rest, value),\n    }\n  }\n\n  return obj\n}\n\nfunction deepMutableSetByPath<T>(obj: T, path: Array<string>, value: any) {\n  // mutable set by path retaining array and object references\n  if (path.length === 1) {\n    ;(obj as any)[path[0]!] = value\n  }\n\n  const [key, ...rest] = path\n\n  if (Array.isArray(obj)) {\n    deepMutableSetByPath(obj[Number(key)], rest, value)\n  } else if (isPlainObject(obj)) {\n    deepMutableSetByPath((obj as any)[key!], rest, value)\n  }\n}\n", "import { isRedirect, useRouter } from '@tanstack/react-router'\n\nexport function useServerFn<T extends (...deps: Array<any>) => Promise<any>>(\n  serverFn: T,\n): (...args: Parameters<T>) => ReturnType<T> {\n  const router = useRouter()\n\n  return (async (...args: Array<any>) => {\n    try {\n      const res = await serverFn(...args)\n\n      if (isRedirect(res)) {\n        throw res\n      }\n\n      return res\n    } catch (err) {\n      if (isRedirect(err)) {\n        const resolvedRedirect = router.resolveRedirect({\n          ...err,\n          _fromLocation: router.state.location,\n        })\n\n        return router.navigate(resolvedRedirect)\n      }\n\n      throw err\n    }\n  }) as any\n}\n"],
  "mappings": "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",
  "names": ["context", "context", "preloadMeta", "jsesc", "assetScripts"]
}
