import {
  RouterProvider,
  ScriptOnce,
  defaultTransformer,
  invariant,
  isNotFound,
  isPlainObject,
  isRedirect,
  require_jsesc,
  useRouter,
  useRouterState
} from "./chunk-FSOJFAXD.js";
import {
  require_jsx_runtime
} from "./chunk-I7TO7CYR.js";
import "./chunk-ZSFNEFF4.js";
import {
  require_react
} from "./chunk-CEHRAWMB.js";
import {
  __toESM
} from "./chunk-QWN5BXRD.js";

// node_modules/@tanstack/start/dist/esm/client/Asset.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
function Asset({ tag, attrs, children }) {
  switch (tag) {
    case "title":
      return (0, import_jsx_runtime.jsx)("title", { ...attrs, suppressHydrationWarning: true, children });
    case "meta":
      return (0, import_jsx_runtime.jsx)("meta", { ...attrs, suppressHydrationWarning: true });
    case "link":
      return (0, import_jsx_runtime.jsx)("link", { ...attrs, suppressHydrationWarning: true });
    case "style":
      return (0, import_jsx_runtime.jsx)(
        "style",
        {
          ...attrs,
          dangerouslySetInnerHTML: { __html: children }
        }
      );
    case "script":
      if (attrs && attrs.src) {
        return (0, import_jsx_runtime.jsx)("script", { ...attrs, suppressHydrationWarning: true });
      }
      if (typeof children === "string")
        return (0, import_jsx_runtime.jsx)(
          "script",
          {
            ...attrs,
            dangerouslySetInnerHTML: {
              __html: children
            },
            suppressHydrationWarning: true
          }
        );
      return null;
    default:
      return null;
  }
}

// node_modules/@tanstack/start/dist/esm/client/createIsomorphicFn.js
function createIsomorphicFn() {
  return null;
}

// node_modules/@tanstack/start/dist/esm/client/headers.js
function toHeadersInstance(init) {
  if (init instanceof Headers) {
    return new Headers(init);
  } else if (Array.isArray(init)) {
    return new Headers(init);
  } else if (typeof init === "object") {
    return new Headers(init);
  } else {
    return new Headers();
  }
}
function mergeHeaders(...headers) {
  return headers.reduce((acc, header) => {
    const headersInstance = toHeadersInstance(header);
    for (const [key, value] of headersInstance.entries()) {
      acc.set(key, value);
    }
    return acc;
  }, new Headers());
}

// node_modules/@tanstack/start/dist/esm/client/registerGlobalMiddleware.js
var globalMiddleware = [];
function registerGlobalMiddleware(options) {
  globalMiddleware.push(...options.middleware);
}

// node_modules/@tanstack/start/dist/esm/client/createServerFn.js
function createServerFn(options, __opts) {
  const resolvedOptions = __opts || options || {};
  if (typeof resolvedOptions.method === "undefined") {
    resolvedOptions.method = "GET";
  }
  return {
    options: resolvedOptions,
    middleware: (middleware) => {
      return createServerFn(
        void 0,
        Object.assign(resolvedOptions, { middleware })
      );
    },
    validator: (validator) => {
      return createServerFn(
        void 0,
        Object.assign(resolvedOptions, { validator })
      );
    },
    handler: (...args) => {
      const [extractedFn, serverFn] = args;
      Object.assign(resolvedOptions, {
        ...extractedFn,
        extractedFn,
        serverFn
      });
      invariant(
        extractedFn.url,
        `createServerFn must be called with a function that is marked with the 'use server' pragma. Are you using the @tanstack/start-vite-plugin ?`
      );
      const resolvedMiddleware = [
        ...resolvedOptions.middleware || [],
        serverFnBaseToMiddleware(resolvedOptions)
      ];
      return Object.assign(
        async (opts) => {
          return executeMiddleware(resolvedMiddleware, "client", {
            ...extractedFn,
            method: resolvedOptions.method,
            data: opts == null ? void 0 : opts.data,
            headers: opts == null ? void 0 : opts.headers,
            context: {}
          }).then((d) => {
            if (d.error) throw d.error;
            return d.result;
          });
        },
        {
          // This copies over the URL, function ID and filename
          ...extractedFn,
          // The extracted function on the server-side calls
          // this function
          __executeServer: async (opts) => {
            const parsedOpts = opts instanceof FormData ? extractFormDataContext(opts) : opts;
            const result = await executeMiddleware(
              resolvedMiddleware,
              "server",
              {
                ...extractedFn,
                ...parsedOpts
              }
            ).then((d) => ({
              // Only send the result and sendContext back to the client
              result: d.result,
              error: d.error,
              context: d.sendContext
            }));
            return result;
          }
        }
      );
    }
  };
}
function extractFormDataContext(formData) {
  const serializedContext = formData.get("__TSR_CONTEXT");
  formData.delete("__TSR_CONTEXT");
  if (typeof serializedContext !== "string") {
    return {
      context: {},
      data: formData
    };
  }
  try {
    const context2 = defaultTransformer.parse(serializedContext);
    return {
      context: context2,
      data: formData
    };
  } catch (e) {
    return {
      data: formData
    };
  }
}
function flattenMiddlewares(middlewares) {
  const seen = /* @__PURE__ */ new Set();
  const flattened = [];
  const recurse = (middleware) => {
    middleware.forEach((m) => {
      if (m.options.middleware) {
        recurse(m.options.middleware);
      }
      if (!seen.has(m)) {
        seen.add(m);
        flattened.push(m);
      }
    });
  };
  recurse(middlewares);
  return flattened;
}
var applyMiddleware = async (middlewareFn, ctx, nextFn) => {
  return middlewareFn({
    ...ctx,
    next: async (userCtx = {}) => {
      return nextFn({
        ...ctx,
        ...userCtx,
        context: {
          ...ctx.context,
          ...userCtx.context
        },
        sendContext: {
          ...ctx.sendContext,
          ...userCtx.sendContext ?? {}
        },
        headers: mergeHeaders(ctx.headers, userCtx.headers),
        result: userCtx.result !== void 0 ? userCtx.result : ctx.result,
        error: userCtx.error ?? ctx.error
      });
    }
  });
};
function execValidator(validator, input) {
  if (validator == null) return {};
  if ("~standard" in validator) {
    const result = validator["~standard"].validate(input);
    if (result instanceof Promise)
      throw new Error("Async validation not supported");
    if (result.issues)
      throw new Error(JSON.stringify(result.issues, void 0, 2));
    return result.value;
  }
  if ("parse" in validator) {
    return validator.parse(input);
  }
  if (typeof validator === "function") {
    return validator(input);
  }
  throw new Error("Invalid validator type!");
}
async function executeMiddleware(middlewares, env, opts) {
  const flattenedMiddlewares = flattenMiddlewares([
    ...globalMiddleware,
    ...middlewares
  ]);
  const next = async (ctx) => {
    const nextMiddleware = flattenedMiddlewares.shift();
    if (!nextMiddleware) {
      return ctx;
    }
    if (nextMiddleware.options.validator && (env === "client" ? nextMiddleware.options.validateClient : true)) {
      ctx.data = await execValidator(nextMiddleware.options.validator, ctx.data);
    }
    const middlewareFn = env === "client" ? nextMiddleware.options.client : nextMiddleware.options.server;
    if (middlewareFn) {
      return applyMiddleware(middlewareFn, ctx, async (newCtx) => {
        const clientAfter = nextMiddleware.options.clientAfter;
        if (env === "client" && clientAfter) {
          const result = await next(newCtx);
          return applyMiddleware(
            clientAfter,
            {
              ...newCtx,
              ...result
            },
            // Identity, because there "next" is just returning
            (d) => d
          );
        }
        return next(newCtx).catch((error) => {
          if (isRedirect(error) || isNotFound(error)) {
            return {
              ...newCtx,
              error
            };
          }
          throw error;
        });
      });
    }
    return next(ctx);
  };
  return next({
    ...opts,
    headers: opts.headers || {},
    sendContext: opts.sendContext || {},
    context: opts.context || {}
  });
}
function serverFnBaseToMiddleware(options) {
  return {
    _types: void 0,
    options: {
      validator: options.validator,
      validateClient: options.validateClient,
      client: async ({ next, sendContext, ...ctx }) => {
        var _a;
        const serverCtx = await ((_a = options.extractedFn) == null ? void 0 : _a.call(options, {
          ...ctx,
          // switch the sendContext over to context
          context: sendContext
        }));
        return next(serverCtx);
      },
      server: async ({ next, ...ctx }) => {
        var _a;
        const result = await ((_a = options.serverFn) == null ? void 0 : _a.call(options, ctx));
        return next({
          ...ctx,
          result
        });
      }
    }
  };
}

// node_modules/@tanstack/start/dist/esm/client/createMiddleware.js
function createMiddleware(options, __opts) {
  const resolvedOptions = __opts || (options || {});
  return {
    options: resolvedOptions,
    middleware: (middleware) => {
      return createMiddleware(void 0, Object.assign(resolvedOptions, { middleware }));
    },
    validator: (validator) => {
      return createMiddleware(void 0, Object.assign(resolvedOptions, { validator }));
    },
    client: (client) => {
      return createMiddleware(void 0, Object.assign(resolvedOptions, { client }));
    },
    server: (server) => {
      return createMiddleware(void 0, Object.assign(resolvedOptions, { server }));
    },
    clientAfter: (clientAfter) => {
      return createMiddleware(void 0, Object.assign(resolvedOptions, { clientAfter }));
    }
  };
}

// node_modules/@tanstack/start/dist/esm/client/envOnly.js
var serverOnly = (fn) => fn;
var clientOnly = (fn) => fn;

// node_modules/@tanstack/start/dist/esm/client/DehydrateRouter.js
function DehydrateRouter() {
  return null;
}

// node_modules/@tanstack/start/dist/esm/client/json.js
function json(payload, init) {
  return new Response(JSON.stringify(payload), {
    ...init,
    headers: mergeHeaders(
      { "content-type": "application/json" },
      init == null ? void 0 : init.headers
    )
  });
}

// node_modules/@tanstack/start/dist/esm/client/Meta.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var React = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var import_jsesc = __toESM(require_jsesc(), 1);

// node_modules/@tanstack/react-cross-context/dist/esm/Context.js
var import_react = __toESM(require_react(), 1);
var Context = class _Context {
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
  }
  static create() {
    if (!_Context.instance) {
      _Context.instance = new _Context();
    }
    return _Context.instance;
  }
  createContext(key, initialValue) {
    const context2 = (0, import_react.createContext)(initialValue);
    this.cache.set(key, context2);
    return context2;
  }
  get(key, initialValue) {
    return this.cache.get(key) || this.createContext(key, initialValue);
  }
};
var context = Context.create();

// node_modules/@tanstack/start/dist/esm/client/Meta.js
var useMeta = () => {
  const router = useRouter();
  const routeMeta = useRouterState({
    select: (state) => {
      return state.matches.map((match) => match.meta).filter(Boolean);
    }
  });
  const meta = React.useMemo(() => {
    const resultMeta = [];
    const metaByAttribute = {};
    let title;
    [...routeMeta].reverse().forEach((metas) => {
      [...metas].reverse().forEach((m) => {
        if (!m) return;
        if (m.title) {
          if (!title) {
            title = {
              tag: "title",
              children: m.title
            };
          }
        } else {
          const attribute = m.name ?? m.property;
          if (attribute) {
            if (metaByAttribute[attribute]) {
              return;
            } else {
              metaByAttribute[attribute] = true;
            }
          }
          resultMeta.push({
            tag: "meta",
            attrs: {
              ...m
            }
          });
        }
      });
    });
    if (title) {
      resultMeta.push(title);
    }
    resultMeta.reverse();
    return resultMeta;
  }, [routeMeta]);
  const links = useRouterState({
    select: (state) => state.matches.map((match) => match.links).filter(Boolean).flat(1).map((link) => ({
      tag: "link",
      attrs: {
        ...link
      }
    })),
    structuralSharing: true
  });
  const preloadMeta = useRouterState({
    select: (state) => {
      const preloadMeta2 = [];
      state.matches.map((match) => router.looseRoutesById[match.routeId]).forEach(
        (route) => {
          var _a, _b, _c;
          return (_c = (_b = (_a = router.manifest) == null ? void 0 : _a.routes[route.id]) == null ? void 0 : _b.preloads) == null ? void 0 : _c.filter(Boolean).forEach((preload) => {
            preloadMeta2.push({
              tag: "link",
              attrs: {
                rel: "modulepreload",
                href: preload
              }
            });
          });
        }
      );
      return preloadMeta2;
    },
    structuralSharing: true
  });
  return uniqBy(
    [...meta, ...preloadMeta, ...links],
    (d) => {
      return JSON.stringify(d);
    }
  );
};
var useMetaElements = () => {
  const router = useRouter();
  const meta = useMeta();
  const dehydratedCtx = React.useContext(
    context.get("TanStackRouterHydrationContext", {})
  );
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    meta.map((asset, i) => (0, import_react2.createElement)(Asset, { ...asset, key: `tsr-meta-${JSON.stringify(asset)}` })),
    (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      (0, import_jsx_runtime2.jsx)(
        ScriptOnce,
        {
          log: false,
          children: `__TSR__={matches:[],streamedValues:{},queue:[],runQueue:()=>{let e=!1;__TSR__.queue=__TSR__.queue.filter((_=>!_()||(e=!0,!1))),e&&__TSR__.runQueue()},initMatch:e=>{__TSR__.queue.push((()=>(__TSR__.matches[e.index]||(__TSR__.matches[e.index]=e,Object.entries(e.extracted).forEach((([e,_])=>{if("stream"===_.type){let e;_.value=new ReadableStream({start(_){e=_}}),_.value.controller=e}else if("promise"===_.type){let e,t;_.value=new Promise(((_,u)=>{e=_,t=u})),_.resolve=e,_.reject=t}}))),!0))),__TSR__.runQueue()},resolvePromise:e=>{__TSR__.queue.push((()=>{const _=__TSR__.matches[e.matchIndex];if(_){const t=_.extracted[e.id];if(t)return t.resolve(e.value.data),!0}return!1})),__TSR__.runQueue()},cleanScripts:()=>{document.querySelectorAll(".tsr-once").forEach((e=>{e.remove()}))}};`
        }
      ),
      (0, import_jsx_runtime2.jsx)(
        ScriptOnce,
        {
          children: `__TSR__.dehydrated = ${(0, import_jsesc.default)(
            router.options.transformer.stringify(dehydratedCtx),
            {
              isScriptContext: true,
              wrap: true,
              json: true
            }
          )}`
        }
      )
    ] })
  ] });
};
var Meta = () => {
  return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: useMetaElements() });
};
function uniqBy(arr, fn) {
  const seen = /* @__PURE__ */ new Set();
  return arr.filter((item) => {
    const key = fn(item);
    if (seen.has(key)) {
      return false;
    }
    seen.add(key);
    return true;
  });
}

// node_modules/@tanstack/start/dist/esm/client/Scripts.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);
var Scripts = () => {
  const router = useRouter();
  const assetScripts = useRouterState({
    select: (state) => {
      const assetScripts2 = [];
      state.matches.map((match) => router.looseRoutesById[match.routeId]).forEach(
        (route) => {
          var _a, _b, _c;
          return (_c = (_b = (_a = router.manifest) == null ? void 0 : _a.routes[route.id]) == null ? void 0 : _b.assets) == null ? void 0 : _c.filter((d) => d.tag === "script").forEach((asset) => {
            assetScripts2.push({
              tag: "script",
              attrs: asset.attrs,
              children: asset.children
            });
          });
        }
      );
      return assetScripts2;
    },
    structuralSharing: true
  });
  const { scripts } = useRouterState({
    select: (state) => ({
      scripts: state.matches.map((match) => match.scripts).flat(1).filter(Boolean).map(({ children, ...script }) => ({
        tag: "script",
        attrs: {
          ...script,
          suppressHydrationWarning: true
        },
        children
      }))
    })
  });
  const allScripts = [...scripts, ...assetScripts];
  return (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, { children: allScripts.map((asset, i) => (
    // eslint-disable-next-line @eslint-react/no-array-index-key
    (0, import_react3.createElement)(Asset, { ...asset, key: `tsr-scripts-${asset.tag}-${i}` })
  )) });
};

// node_modules/@tanstack/start/dist/esm/client/StartClient.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);

// node_modules/@tanstack/start/dist/esm/client/serialization.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var React2 = __toESM(require_react(), 1);
var import_jsesc2 = __toESM(require_jsesc(), 1);
function afterHydrate({ router }) {
  router.state.matches.forEach((match) => {
    var _a, _b, _c;
    const route = router.looseRoutesById[match.routeId];
    const dMatch = (_a = window.__TSR__) == null ? void 0 : _a.matches[match.index];
    if (dMatch) {
      const parentMatch = router.state.matches[match.index - 1];
      const parentContext = (parentMatch == null ? void 0 : parentMatch.context) ?? router.options.context ?? {};
      if (dMatch.__beforeLoadContext) {
        match.__beforeLoadContext = router.options.transformer.parse(
          dMatch.__beforeLoadContext
        );
        match.context = {
          ...parentContext,
          ...match.context,
          ...match.__beforeLoadContext
        };
      }
      if (dMatch.loaderData) {
        match.loaderData = router.options.transformer.parse(dMatch.loaderData);
      }
      const extracted = dMatch.extracted;
      if (extracted) {
        Object.entries(extracted).forEach(([_, ex]) => {
          deepMutableSetByPath(match, ["loaderData", ...ex.path], ex.value);
        });
      }
    }
    const headFnContent = (_c = (_b = route.options).head) == null ? void 0 : _c.call(_b, {
      matches: router.state.matches,
      match,
      params: match.params,
      loaderData: match.loaderData
    });
    Object.assign(match, {
      meta: headFnContent == null ? void 0 : headFnContent.meta,
      links: headFnContent == null ? void 0 : headFnContent.links,
      scripts: headFnContent == null ? void 0 : headFnContent.scripts
    });
  });
}
function deepMutableSetByPath(obj, path, value) {
  if (path.length === 1) {
    obj[path[0]] = value;
  }
  const [key, ...rest] = path;
  if (Array.isArray(obj)) {
    deepMutableSetByPath(obj[Number(key)], rest, value);
  } else if (isPlainObject(obj)) {
    deepMutableSetByPath(obj[key], rest, value);
  }
}

// node_modules/@tanstack/start/dist/esm/client/StartClient.js
function StartClient(props) {
  if (!props.router.state.matches.length) {
    props.router.hydrate();
    afterHydrate({ router: props.router });
  }
  return (0, import_jsx_runtime5.jsx)(RouterProvider, { router: props.router });
}

// node_modules/@tanstack/start/dist/esm/client/renderRSC.js
var import_react4 = __toESM(require_react(), 1);
function renderRsc(input) {
  if ((0, import_react4.isValidElement)(input)) {
    return input;
  }
  if (typeof input === "object" && !input.state) {
    input.state = {
      status: "pending",
      promise: Promise.resolve().then(() => {
        invariant(false, "renderRSC() is coming soon!");
      }).then((element) => {
        input.state.value = element;
        input.state.status = "success";
      }).catch((err) => {
        input.state.status = "error";
        input.state.error = err;
      })
    };
  }
  if (input.state.status === "pending") {
    throw input.state.promise;
  }
  return input.state.value;
}

// node_modules/@tanstack/start/dist/esm/client/useServerFn.js
function useServerFn(serverFn) {
  const router = useRouter();
  return async (...args) => {
    try {
      const res = await serverFn(...args);
      if (isRedirect(res)) {
        throw res;
      }
      return res;
    } catch (err) {
      if (isRedirect(err)) {
        const resolvedRedirect = router.resolveRedirect({
          ...err,
          _fromLocation: router.state.location
        });
        return router.navigate(resolvedRedirect);
      }
      throw err;
    }
  };
}
export {
  Asset,
  DehydrateRouter,
  Meta,
  Scripts,
  StartClient,
  clientOnly,
  createIsomorphicFn,
  createMiddleware,
  createServerFn,
  globalMiddleware,
  json,
  mergeHeaders,
  registerGlobalMiddleware,
  renderRsc,
  serverOnly,
  useServerFn
};
//# sourceMappingURL=@tanstack_start.js.map
