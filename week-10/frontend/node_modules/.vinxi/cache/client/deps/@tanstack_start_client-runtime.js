import {
  defaultTransformer,
  encode,
  isNotFound,
  isPlainObject,
  isRedirect
} from "./chunk-FSOJFAXD.js";
import "./chunk-I7TO7CYR.js";
import "./chunk-ZSFNEFF4.js";
import "./chunk-CEHRAWMB.js";
import "./chunk-QWN5BXRD.js";

// node_modules/@tanstack/start/dist/esm/client-runtime/fetcher.js
async function fetcher(base, args, handler) {
  var _a;
  const _first = args[0];
  if (isPlainObject(_first) && _first.method) {
    const first = _first;
    const type = first.data instanceof FormData ? "formData" : "payload";
    const headers = new Headers({
      ...type === "payload" ? {
        "content-type": "application/json",
        accept: "application/json"
      } : {},
      ...first.headers instanceof Headers ? Object.fromEntries(first.headers.entries()) : first.headers || {}
    });
    if (first.method === "GET") {
      const encodedPayload = encode({
        payload: defaultTransformer.stringify({
          data: first.data,
          context: first.context
        })
      });
      if (encodedPayload) base += `&${encodedPayload}`;
    }
    const request2 = new Request(base, {
      method: first.method,
      headers,
      ...getFetcherRequestOptions(first)
    });
    const handlerResponse = await handler(request2);
    const response2 = await handleResponseErrors(handlerResponse);
    if ((_a = response2.headers.get("content-type")) == null ? void 0 : _a.includes("application/json")) {
      const json = defaultTransformer.decode(await response2.json());
      if (isRedirect(json) || isNotFound(json) || json instanceof Error) {
        throw json;
      }
      return json;
    }
    return response2;
  }
  const request = new Request(base, {
    method: "POST",
    headers: {
      Accept: "application/json",
      "Content-Type": "application/json"
    },
    body: JSON.stringify(args)
  });
  const response = await handleResponseErrors(await handler(request));
  const contentType = response.headers.get("content-type");
  if (contentType && contentType.includes("application/json")) {
    return defaultTransformer.decode(await response.json());
  } else {
    return response.text();
  }
}
function getFetcherRequestOptions(opts) {
  if (opts.method === "POST") {
    if (opts.data instanceof FormData) {
      opts.data.set("__TSR_CONTEXT", defaultTransformer.stringify(opts.context));
      return {
        body: opts.data
      };
    }
    return {
      body: defaultTransformer.stringify({
        data: opts.data ?? null,
        context: opts.context
      })
    };
  }
  return {};
}
async function handleResponseErrors(response) {
  if (!response.ok) {
    const contentType = response.headers.get("content-type");
    const isJson = contentType && contentType.includes("application/json");
    if (isJson) {
      throw defaultTransformer.decode(await response.json());
    }
    throw new Error(await response.text());
  }
  return response;
}

// node_modules/@tanstack/start/dist/esm/client-runtime/getBaseUrl.js
function sanitizeBase(base) {
  if (!base) {
    throw new Error(
      "ðŸš¨ process.env.TSS_SERVER_BASE is required in start/client-runtime/getBaseUrl"
    );
  }
  return base.replace(/^\/|\/$/g, "");
}
function getBaseUrl(base, id, name) {
  return `${base}/${sanitizeBase(process.env.TSS_SERVER_BASE)}/?_serverFnId=${encodeURI(id)}&_serverFnName=${encodeURI(name)}`;
}

// node_modules/@tanstack/start/dist/esm/client-runtime/index.js
function createServerReference(_fn, id, name) {
  const base = getBaseUrl(window.location.origin, id, name);
  const proxyFn = (...args) => fetcher(base, args, fetch);
  return Object.assign(proxyFn, {
    url: base,
    filename: id,
    functionId: name
  });
}
export {
  createServerReference,
  fetcher
};
//# sourceMappingURL=@tanstack_start_client-runtime.js.map
