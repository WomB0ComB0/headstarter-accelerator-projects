{
  "version": 3,
  "sources": ["../../../../@tanstack/start/src/client-runtime/fetcher.tsx", "../../../../@tanstack/start/src/client-runtime/getBaseUrl.tsx", "../../../../@tanstack/start/src/client-runtime/index.tsx"],
  "sourcesContent": ["import {\n  defaultTransformer,\n  encode,\n  isNotFound,\n  isPlainObject,\n  isRedirect,\n} from '@tanstack/react-router'\nimport type { MiddlewareOptions } from '../client/createServerFn'\n\nexport async function fetcher(\n  base: string,\n  args: Array<any>,\n  handler: (request: Request) => Promise<Response>,\n) {\n  const _first = args[0]\n\n  // If createServerFn was used to wrap the fetcher,\n  // We need to handle the arguments differently\n  if (isPlainObject(_first) && _first.method) {\n    const first = _first as MiddlewareOptions\n    const type = first.data instanceof FormData ? 'formData' : 'payload'\n\n    // Arrange the headers\n    const headers = new Headers({\n      ...(type === 'payload'\n        ? {\n            'content-type': 'application/json',\n            accept: 'application/json',\n          }\n        : {}),\n      ...(first.headers instanceof Headers\n        ? Object.fromEntries(first.headers.entries())\n        : first.headers || {}),\n    })\n\n    // If the method is GET, we need to move the payload to the query string\n    if (first.method === 'GET') {\n      // If the method is GET, we need to move the payload to the query string\n      const encodedPayload = encode({\n        payload: defaultTransformer.stringify({\n          data: first.data,\n          context: first.context,\n        }),\n      })\n\n      if (encodedPayload) base += `&${encodedPayload}`\n    }\n\n    // Create the request\n    const request = new Request(base, {\n      method: first.method,\n      headers,\n      ...getFetcherRequestOptions(first),\n    })\n\n    const handlerResponse = await handler(request)\n\n    const response = await handleResponseErrors(handlerResponse)\n\n    // Check if the response is JSON\n    if (response.headers.get('content-type')?.includes('application/json')) {\n      // Even though the response is JSON, we need to decode it\n      // because the server may have transformed it\n      const json = defaultTransformer.decode(await response.json())\n\n      // If the response is a redirect or not found, throw it\n      // for the router to handle\n      if (isRedirect(json) || isNotFound(json) || json instanceof Error) {\n        throw json\n      }\n\n      return json\n    }\n\n    // Must be a raw response\n    return response\n  }\n\n  // If not a custom fetcher, just proxy the arguments\n  // through as a POST request\n  const request = new Request(base, {\n    method: 'POST',\n    headers: {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(args),\n  })\n\n  const response = await handleResponseErrors(await handler(request))\n\n  // If the response is JSON, return it parsed\n  const contentType = response.headers.get('content-type')\n  if (contentType && contentType.includes('application/json')) {\n    return defaultTransformer.decode(await response.json())\n  } else {\n    // Otherwise, return the text as a fallback\n    // If the user wants more than this, they can pass a\n    // request instead\n    return response.text()\n  }\n}\n\nfunction getFetcherRequestOptions(opts: MiddlewareOptions) {\n  if (opts.method === 'POST') {\n    if (opts.data instanceof FormData) {\n      opts.data.set('__TSR_CONTEXT', defaultTransformer.stringify(opts.context))\n      return {\n        body: opts.data,\n      }\n    }\n\n    return {\n      body: defaultTransformer.stringify({\n        data: opts.data ?? null,\n        context: opts.context,\n      }),\n    }\n  }\n\n  return {}\n}\n\nasync function handleResponseErrors(response: Response) {\n  if (!response.ok) {\n    const contentType = response.headers.get('content-type')\n    const isJson = contentType && contentType.includes('application/json')\n\n    if (isJson) {\n      throw defaultTransformer.decode(await response.json())\n    }\n\n    throw new Error(await response.text())\n  }\n\n  return response\n}\n", "function sanitizeBase(base: string | undefined) {\n  if (!base) {\n    throw new Error(\n      'ðŸš¨ process.env.TSS_SERVER_BASE is required in start/client-runtime/getBaseUrl',\n    )\n  }\n\n  // remove the leading and trailing slash\n  return base.replace(/^\\/|\\/$/g, '')\n}\n\nexport function getBaseUrl(base: string | undefined, id: string, name: string) {\n  return `${base}/${sanitizeBase(process.env.TSS_SERVER_BASE)}/?_serverFnId=${encodeURI(id)}&_serverFnName=${encodeURI(name)}`\n}\n", "import { fetcher } from './fetcher'\nimport { getBaseUrl } from './getBaseUrl'\nimport type { ServerFn } from '../client/createServerFn'\n\nexport function createServerReference(\n  _fn: ServerFn<any, any, any, any>,\n  id: string,\n  name: string,\n) {\n  // let base = getBaseUrl(import.meta.env.SERVER_BASE_URL, id, name)\n  const base = getBaseUrl(window.location.origin, id, name)\n\n  const proxyFn = (...args: Array<any>) => fetcher(base, args, fetch)\n\n  return Object.assign(proxyFn, {\n    url: base,\n    filename: id,\n    functionId: name,\n  })\n}\n\nexport { fetcher }\n"],
  "mappings": ";;;;;;;;;;;;;AASsB,eAAA,QACpB,MACA,MACA,SACA;;AACM,QAAA,SAAS,KAAK,CAAC;AAIrB,MAAI,cAAc,MAAM,KAAK,OAAO,QAAQ;AAC1C,UAAM,QAAQ;AACd,UAAM,OAAO,MAAM,gBAAgB,WAAW,aAAa;AAGrD,UAAA,UAAU,IAAI,QAAQ;MAC1B,GAAI,SAAS,YACT;QACE,gBAAgB;QAChB,QAAQ;MAAA,IAEV,CAAC;MACL,GAAI,MAAM,mBAAmB,UACzB,OAAO,YAAY,MAAM,QAAQ,QAAQ,CAAC,IAC1C,MAAM,WAAW,CAAA;IAAC,CACvB;AAGG,QAAA,MAAM,WAAW,OAAO;AAE1B,YAAM,iBAAiB,OAAO;QAC5B,SAAS,mBAAmB,UAAU;UACpC,MAAM,MAAM;UACZ,SAAS,MAAM;QAChB,CAAA;MAAA,CACF;AAEG,UAAA,eAAwB,SAAA,IAAI,cAAc;IAAA;AAI1CA,UAAAA,WAAU,IAAI,QAAQ,MAAM;MAChC,QAAQ,MAAM;MACd;MACA,GAAG,yBAAyB,KAAK;IAAA,CAClC;AAEK,UAAA,kBAAkB,MAAM,QAAQA,QAAO;AAEvCC,UAAAA,YAAW,MAAM,qBAAqB,eAAe;AAG3D,SAAIA,KAAAA,UAAS,QAAQ,IAAI,cAAc,MAAnCA,OAAAA,SAAAA,GAAsC,SAAS,kBAAA,GAAqB;AAGtE,YAAM,OAAO,mBAAmB,OAAO,MAAMA,UAAS,KAAA,CAAM;AAI5D,UAAI,WAAW,IAAI,KAAK,WAAW,IAAI,KAAK,gBAAgB,OAAO;AAC3D,cAAA;MAAA;AAGD,aAAA;IAAA;AAIFA,WAAAA;EAAA;AAKH,QAAA,UAAU,IAAI,QAAQ,MAAM;IAChC,QAAQ;IACR,SAAS;MACP,QAAQ;MACR,gBAAgB;IAClB;IACA,MAAM,KAAK,UAAU,IAAI;EAAA,CAC1B;AAED,QAAM,WAAW,MAAM,qBAAqB,MAAM,QAAQ,OAAO,CAAC;AAGlE,QAAM,cAAc,SAAS,QAAQ,IAAI,cAAc;AACvD,MAAI,eAAe,YAAY,SAAS,kBAAkB,GAAG;AAC3D,WAAO,mBAAmB,OAAO,MAAM,SAAS,KAAA,CAAM;EAAA,OACjD;AAIL,WAAO,SAAS,KAAK;EAAA;AAEzB;AAEA,SAAS,yBAAyB,MAAyB;AACrD,MAAA,KAAK,WAAW,QAAQ;AACtB,QAAA,KAAK,gBAAgB,UAAU;AACjC,WAAK,KAAK,IAAI,iBAAiB,mBAAmB,UAAU,KAAK,OAAO,CAAC;AAClE,aAAA;QACL,MAAM,KAAK;MACb;IAAA;AAGK,WAAA;MACL,MAAM,mBAAmB,UAAU;QACjC,MAAM,KAAK,QAAQ;QACnB,SAAS,KAAK;MACf,CAAA;IACH;EAAA;AAGF,SAAO,CAAC;AACV;AAEA,eAAe,qBAAqB,UAAoB;AAClD,MAAA,CAAC,SAAS,IAAI;AAChB,UAAM,cAAc,SAAS,QAAQ,IAAI,cAAc;AACvD,UAAM,SAAS,eAAe,YAAY,SAAS,kBAAkB;AAErE,QAAI,QAAQ;AACV,YAAM,mBAAmB,OAAO,MAAM,SAAS,KAAA,CAAM;IAAA;AAGvD,UAAM,IAAI,MAAM,MAAM,SAAS,KAAA,CAAM;EAAA;AAGhC,SAAA;AACT;;;ACxIA,SAAS,aAAa,MAA0B;AAC9C,MAAI,CAAC,MAAM;AACT,UAAM,IAAI;MACR;IACF;EAAA;AAIK,SAAA,KAAK,QAAQ,YAAY,EAAE;AACpC;AAEgB,SAAA,WAAW,MAA0B,IAAY,MAAc;AAC7E,SAAO,GAAG,IAAI,IAAI,aAAa,QAAQ,IAAI,eAAe,CAAC,iBAAiB,UAAU,EAAE,CAAC,kBAAkB,UAAU,IAAI,CAAC;AAC5H;;;ACTgB,SAAA,sBACd,KACA,IACA,MACA;AAEA,QAAM,OAAO,WAAW,OAAO,SAAS,QAAQ,IAAI,IAAI;AAExD,QAAM,UAAU,IAAI,SAAqB,QAAQ,MAAM,MAAM,KAAK;AAE3D,SAAA,OAAO,OAAO,SAAS;IAC5B,KAAK;IACL,UAAU;IACV,YAAY;EAAA,CACb;AACH;",
  "names": ["request", "response"]
}
